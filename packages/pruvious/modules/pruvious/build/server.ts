import { validatorsMeta } from '@pruvious/orm'
import { camelCase, isArray, kebabCase, pascalCase } from '@pruvious/utils'
import fs from 'node:fs'
import { createResolver, useNuxt } from 'nuxt/kit'
import { basename, extname, isAbsolute, relative, resolve } from 'pathe'
import { resolveCollectionFiles } from '../collections/resolver'
import { debug } from '../debug/console'
import { resolveFieldDefinitionFiles } from '../fields/resolver'
import {
  resolveActionCallbackFiles,
  resolveActionDefinitionFiles,
  resolveFilterCallbackFiles,
  resolveFilterDefinitionFiles,
} from '../hooks/resolver'
import { resolveJobFiles } from '../queue/resolver'
import { resolveSingletonFiles } from '../singletons/resolver'
import { resolveTemplateFiles } from '../templates/resolver'
import { resolveTranslationFiles } from '../translations/resolver'
import { getSimpleValidatorsMeta } from './validators'

/**
 * Generates the `#pruvious/server` files.
 */
export function generateServerFiles() {
  const nuxt = useNuxt()
  const buildDir = nuxt.options.runtimeConfig.pruvious.dir.build

  if (!fs.existsSync(`${buildDir}/server/blocks.ts`)) {
    fs.writeFileSync(`${buildDir}/server/blocks.ts`, 'export const blocks = {}\n')
  }

  fs.writeFileSync(`${buildDir}/server/fields.ts`, getServerFieldsFileContent() + '\n')

  fs.writeFileSync(
    `${buildDir}/server/dynamic-routes-collection.ts`,
    getServerDynamicRoutesCollectionFileContent() + '\n',
  )

  fs.writeFileSync(`${buildDir}/server/hooks.ts`, getServerHooksFileContent() + '\n')

  fs.writeFileSync(`${buildDir}/server/index.ts`, getServerFileContent() + '\n')
  fs.writeFileSync(`${buildDir}/server/index.d.ts`, getServerTypeFileContent() + '\n')

  fs.appendFileSync(`${buildDir}/server/index.ts`, getServerFileContentPatch() + '\n')
  fs.appendFileSync(`${buildDir}/server/index.d.ts`, getServerTypeFileContentPatch() + '\n')
}

/**
 * Generates the `#pruvious/server/fields.ts` file content.
 */
function getServerFieldsFileContent() {
  const nuxt = useNuxt()
  const pruviousOptions = nuxt.options.runtimeConfig.pruvious

  debug(`Generating <${relative(nuxt.options.workspaceDir, pruviousOptions.dir.build)}/server/fields.ts>`)

  const fieldDefinitionFiles = resolveFieldDefinitionFiles()
  const fieldDefinitionEntries = Object.entries(fieldDefinitionFiles)

  return [
    ...fieldDefinitionEntries.map(([name, { file }]) => `import _${camelCase(name)}Field from '${file.import}'`),
    ``,
    `/**`,
    ` * Type representing all defined field types.`,
    ` * The keys are the field names, and the values are the \`Field\` definition objects.`,
    ` */`,
    `export type Fields = {`,
    ...fieldDefinitionEntries.map(([name]) => `  '${name}': ReturnType<typeof _${camelCase(name)}Field.serverFn>,`),
    `}`,
    ``,
    `/**`,
    ` * Represents the type structure for all available field configuration options.`,
    ` * The keys are the field names, and the values are the field options.`,
    ` */`,
    `export type FieldOptions = {`,
    ...fieldDefinitionEntries.map(([name]) => `  '${name}': typeof _${camelCase(name)}Field.TOptions,`),
    `}`,
    ``,
    ...fieldDefinitionEntries.flatMap(([name, location]) => [
      `export const ${camelCase(name)}Field = _${camelCase(name)}Field.serverFn.bind({ fieldType: '${camelCase(name)}', location: ${JSON.stringify({ file: { absolute: location.file.absolute, relative: location.file.relative }, srcDir: location.layer.config.srcDir })} })`,
    ]),
  ].join('\n')
}

/**
 * Generates the `#pruvious/server/dynamic-routes-collection.ts` file content.
 */
function getServerDynamicRoutesCollectionFileContent() {
  const nuxt = useNuxt()
  const pruviousOptions = nuxt.options.runtimeConfig.pruvious

  const collectionFiles = resolveCollectionFiles()
  const collectionEntries = Object.entries(collectionFiles)
  const singletonFiles = resolveSingletonFiles()
  const singletonEntries = Object.entries(singletonFiles)

  debug(
    `Generating <${relative(nuxt.options.workspaceDir, pruviousOptions.dir.build)}/server/dynamic-routes-collection.ts>`,
  )

  const output = [
    `import {`,
    `  chipsField,`,
    `  defineCollection,`,
    `  getSanitizedInput,`,
    `  isPublicFieldPreset,`,
    `  languages,`,
    `  nullableSelectField,`,
    `  nullableTextField,`,
    `  numberField,`,
    `  patchSanitizedInput,`,
    `  pathValidator,`,
    `  repeaterField,`,
    `  scheduledAtFieldPreset,`,
    `  seoFieldPreset,`,
    `  textField,`,
    `  trueFalseField,`,
    `  uniqueValidator,`,
    `  urlValidator,`,
    `} from '#pruvious/server'`,
    `import {`,
    `  isNotNull,`,
    `  isNull,`,
    `  isString,`,
    `  withLeadingSlash,`,
    `  withoutTrailingSlash,`,
    `} from '@pruvious/utils'`,
    ``,
    `export default defineCollection({`,
    `  translatable: false,`,
    `  fields: {`,
    `    referencedCollections: chipsField({`,
    `      choices: [${collectionEntries.map(([name]) => `{ value: '${name}' }`).join(', ')}],`,
    `      allowEmptyArray: true,`,
    `      enforceUniqueItems: true,`,
    `      validators: [`,
    `        async (value, { context, path }, errors) => {`,
    `          if (isNotNull(value)) {`,
    `            let hasErrors = false`,
    `            const { getRouteReferences } = await import('#pruvious/server')`,
    `            const collectionNames = Object.values(await getRouteReferences())`,
    `              .filter(({ dataContainerType }) => dataContainerType === 'collection')`,
    `              .map(({ dataContainerName }) => dataContainerName)`,
    `            for (const [i, item] of value.entries()) {`,
    `              if (!collectionNames.includes(item)) {`,
    `                errors[\`\${path}.\${i}\`] = context.__('pruvious-orm', 'Invalid value')`,
    `                hasErrors = true`,
    `              }`,
    `            }`,
    `            if (hasErrors) {`,
    `              throw new Error(context.__('pruvious-orm', 'This field contains invalid values'))`,
    `            }`,
    `          }`,
    `        },`,
    `      ],`,
    `      ui: {`,
    `        label: ({ __ }) => __('pruvious-dashboard', 'Collections'),`,
    `        description: ({ __ }) => [`,
    `          __('pruvious-dashboard', 'Select a routable collection to create child routes from its records.'),`,
    `          __('pruvious-dashboard', 'Collections are resolved in the order they are provided.'),`,
    `        ].join('\\n\\n'),`,
    `        placeholder: ({ __ }) => __('pruvious-dashboard', 'Add collection'),`,
    `      },`,
    `    }),`,
    `    referencedSingleton: nullableSelectField({`,
    `      choices: [${singletonEntries.map(([name]) => `{ value: '${name}' }`).join(', ')}],`,
    `      validators: [`,
    `        async (value, { context }) => {`,
    `          if (isNotNull(value)) {`,
    `            const { getRouteReferences } = await import('#pruvious/server')`,
    `            if (!Object.values(await getRouteReferences()).some(`,
    `              ({ dataContainerType, dataContainerName }) => dataContainerType === 'singleton' && dataContainerName === value,`,
    `            )) {`,
    `              throw new Error(context.__('pruvious-api', 'Invalid input'))`,
    `            }`,
    `          }`,
    `        },`,
    `      ],`,
    `      ui: {`,
    `        label: ({ __ }) => __('pruvious-dashboard', 'Singleton'),`,
    `        description: ({ __ }) => __('pruvious-dashboard', 'Select a routable singleton to use its data for this specific route.'),`,
    `        nullChoiceLabel: ({ __ }) => '-',`,
    `      },`,
    `    }),`,
  ]

  for (const { code } of pruviousOptions.i18n.languages) {
    const suffix = code.toUpperCase()
    output.push(
      `    path${suffix}: nullableTextField({`,
      `      sanitizers: [`,
      `        (value) => {`,
      `          if (isString(value)) {`,
      `            return withLeadingSlash(withoutTrailingSlash(value.replace(/\\s+/g, '-').replace(/\\/+/g, '/')))`,
      `          }`,
      `          return value`,
      `        },`,
      `      ],`,
      `      validators: [`,
      `        pathValidator(),`,
      `        uniqueValidator({ errorMessage: ({ __ }) => __('pruvious-api', 'The path must be unique'), caseSensitive: false }),`,
      `      ],`,
      `      ui: {`,
      `        customComponent: 'PathField',`,
      `        customTableComponent: 'PathField.table',`,
      `        customFilterComponent: 'PathField.filter',`,
      `        label: ({ __ }) => __('pruvious-dashboard', 'Path'),`,
      `        description: ({ __ }) => __('pruvious-dashboard', 'The portion of the URL path after the base URL.'),`,
      `        placeholder: ({ __ }) => __('pruvious-dashboard', '/example/path'),`,
      `      },`,
      `    }),`,
      `    isPublic${suffix}: isPublicFieldPreset({`,
      `      conditionalLogic: { path${suffix}: { '!=': null } },`,
      `    }),`,
      `    scheduledAt${suffix}: scheduledAtFieldPreset({`,
      `      conditionalLogic: { path${suffix}: { '!=': null } },`,
      `    }),`,
      `    redirects${suffix}: repeaterField({`,
      `      subfields: {`,
      `        match: nullableTextField({`,
      `          validators: [`,
      `            (value, { context }) => {`,
      `              if (isString(value)) {`,
      `                try {`,
      `                  new RegExp(value)`,
      `                } catch {`,
      `                  throw new Error(context.__('pruvious-api', 'Invalid RegExp pattern'))`,
      `                }`,
      `              }`,
      `            },`,
      `          ],`,
      `          ui: {`,
      `            label: ({ __ }) => __('pruvious-dashboard', 'Match pattern'),`,
      `            description: ({ __ }) => [`,
      `              __('pruvious-dashboard', 'The RegExp pattern to match incoming requests.'),`,
      `              __('pruvious-dashboard', "It matches the URL portion after the current route path."),`,
      `              __('pruvious-dashboard', 'Use capture groups (e.g. \`(.+)\`) to extract parts of the matched path for use in the redirect URL.'),`,
      `              __('pruvious-dashboard', 'Disable to use the exact route path.')`,
      `            ].join('\\n\\n'),`,
      `            placeholder: ({ __ }) => __('pruvious-dashboard', 'e.g. report-(.+)-2024$'),`,
      `          },`,
      `        }),`,
      `        to: textField({`,
      `          required: true,`,
      `          allowEmptyString: true,`,
      `          validators: [`,
      `            async (value, sanitizedFieldContext, errors) => {`,
      `              if (value.startsWith('http://') || value.startsWith('https://')) {`,
      `                await urlValidator()(value, sanitizedFieldContext, errors)`,
      `              } else {`,
      `                await pathValidator()(\`/\${value}\`, sanitizedFieldContext, errors)`,
      `              }`,
      `            }`,
      `          ],`,
      `          ui: {`,
      `            label: ({ __ }) => __('pruvious-dashboard', 'Redirect URL'),`,
      `            description: ({ __ }) => [`,
      `              __('pruvious-dashboard', 'The URL or path where users will be redirected.'),`,
      `              __('pruvious-dashboard', 'Use a relative path (without leading slash) to append to the current route path.'),`,
      `              __('pruvious-dashboard', 'Use \`$1\`, \`$2\`, etc. to reference capture groups from the match pattern.'),`,
      `              __('pruvious-dashboard', 'Leave empty to redirect to the current route path.'),`,
      `            ].join('\\n\\n'),`,
      `            placeholder: ({ __ }) => __('pruvious-dashboard', 'e.g. archive/reports/2024/$1'),`,
      `          },`,
      `        }),`,
      `        code: numberField({`,
      `          min: 301,`,
      `          max: 302,`,
      `          required: true,`,
      `          default: 302,`,
      `          ui: {`,
      `            customComponent: 'RedirectCodeField',`,
      `            label: ({ __ }) => __('pruvious-dashboard', 'Status code'),`,
      `            description: ({ __ }) => __('pruvious-dashboard', 'Choose \`301\` for permanent redirects or \`302\` for temporary redirects.'),`,
      `          },`,
      `        }),`,
      `        forwardQueryParams: trueFalseField({`,
      `          default: true,`,
      `          ui: {`,
      `            label: ({ __ }) => __('pruvious-dashboard', 'Forward query parameters'),`,
      `            description: ({ __ }) => __('pruvious-dashboard', 'Controls whether query parameters from the current URL are added to the redirect URL.'),`,
      `          },`,
      `        }),`,
      `      },`,
      `      ui: {`,
      `        label: ({ __ }) => __('pruvious-dashboard', 'Redirects'),`,
      `        description: ({ __ }) => [`,
      `          __('pruvious-dashboard', 'Redirects take priority over all other routing configurations.'),`,
      `          __('pruvious-dashboard', 'They are resolved in the order they are provided.'),`,
      `        ].join('\\n\\n'),`,
      `        addItemLabel: ({ __ }) => __('pruvious-dashboard', 'Add redirect'),`,
      `        itemLabelConfiguration: { subfieldValue: 'to' },`,
      `      },`,
      `    }),`,
      `    seo${suffix}: seoFieldPreset({`,
      `      conditionalLogic: { path${suffix}: { '!=': null } },`,
      `    }),`,
    )
  }

  output.push(
    `  },`,
    `  indexes: [`,
    ...pruviousOptions.i18n.languages.flatMap(({ code }) => [
      `    { fields: ['path${code.toUpperCase()}'], unique: true },`,
      `    { fields: ['isPublic${code.toUpperCase()}'] },`,
    ]),
    `  ],`,
    `  hooks: {`,
    `    beforeQueryPreparation: [`,
    `      (({ operation, queryBuilder }) => {`,
    `        if (operation === 'update') {`,
    `          for (const { code } of languages) {`,
    `            if (isNull(getSanitizedInput(queryBuilder!)[\`path\${code.toUpperCase()}\`])) {`,
    `              patchSanitizedInput(queryBuilder!, {`,
    `                [\`isPublic\${code.toUpperCase()}\`]: false,`,
    `                [\`scheduledAt\${code.toUpperCase()}\`]: null,`,
    `              })`,
    `            }`,
    `          }`,
    `        }`,
    `      }),`,
    `    ],`,
    `  },`,
    `  ui: {`,
    `    label: ({ __ }) => __('pruvious-dashboard', 'Routes'),`,
    `    icon: 'route',`,
    `    menu: { group: 'general', order: 2 },`,
    `    indexPage: {`,
    `      table: {`,
    `        columns: ['path', ${pruviousOptions.i18n.languages.length > 1 ? "{ component: 'RouteTranslationsColumn', key: '$translations', label: ({ __ }: any) => __('pruvious-dashboard', 'Translations') }, " : ''}'referencedCollections', 'referencedSingleton', 'isPublic | 150px', 'scheduledAt | 150px', 'createdAt | 150px', 'updatedAt | 150px'] as any,`,
    `        orderBy: 'createdAt:desc',`,
    `      },`,
    `    },`,
    `    createPage: {`,
    `      fieldsLayout: [`,
    `        'referencedCollections',`,
    `        'referencedSingleton',`,
  )

  if (pruviousOptions.i18n.languages.length > 1) {
    output.push(
      `        {`,
      `          card: {`,
      `            header: ({ __ }) => __('pruvious-dashboard', 'Translations'),`,
      `            fields: [`,
      `              {`,
      `                tabs: [`,
      ...pruviousOptions.i18n.languages.flatMap(({ name, code }) => [
        `                  {`,
        `                    label: '${name}',`,
        `                    queryParam: { language: '${code}' },`,
        `                    fields: [`,
        `                      'path${code.toUpperCase()}',`,
        `                      'isPublic${code.toUpperCase()}',`,
        `                      'scheduledAt${code.toUpperCase()}',`,
        `                      'redirects${code.toUpperCase()}',`,
        `                      'seo${code.toUpperCase()}',`,
        `                    ],`,
        `                  },`,
      ]),
      `                ],`,
      `              },`,
      `            ],`,
      `          },`,
      `        },`,
    )
  } else {
    output.push(
      `        'path${pruviousOptions.i18n.primaryLanguage.toUpperCase()}',`,
      `        'isPublic${pruviousOptions.i18n.primaryLanguage.toUpperCase()}',`,
      `        'scheduledAt${pruviousOptions.i18n.primaryLanguage.toUpperCase()}',`,
      `        'redirects${pruviousOptions.i18n.primaryLanguage.toUpperCase()}',`,
      `        'seo${pruviousOptions.i18n.primaryLanguage.toUpperCase()}',`,
    )
  }

  output.push(`      ]`, `    },`, `    updatePage: { fieldsLayout: 'mirror' },`, `  },`, `})`)

  return output.join('\n')
}

/**
 * Generates the `#pruvious/server/hooks.ts` file content.
 */
function getServerHooksFileContent() {
  const nuxt = useNuxt()
  const pruviousOptions = nuxt.options.runtimeConfig.pruvious

  debug(`Generating <${relative(nuxt.options.workspaceDir, pruviousOptions.dir.build)}/server/hooks.ts>`)

  const actionDefinitionFiles = resolveActionDefinitionFiles()
  const serverActionDefinitionEntries = Object.entries(actionDefinitionFiles.server)
  const actionCallbackFiles = resolveActionCallbackFiles()
  const serverActionCallbackEntries = Object.entries(actionCallbackFiles.server)
  const filterDefinitionFiles = resolveFilterDefinitionFiles()
  const serverFilterDefinitionEntries = Object.entries(filterDefinitionFiles.server)
  const filterCallbackFiles = resolveFilterCallbackFiles()
  const serverFilterCallbackEntries = Object.entries(filterCallbackFiles.server)

  return [
    ...serverActionDefinitionEntries.map(
      ([name, { file }]) => `import type _${name.split(':').map(camelCase).join('_')}Action from '${file.import}'`,
    ),
    ...serverFilterDefinitionEntries.map(
      ([name, { file }]) => `import type _${name.split(':').map(camelCase).join('_')}Filter from '${file.import}'`,
    ),
    ``,
    `/**`,
    ` * Type representing all defined server-side action hooks.`,
    ` * The keys are the action names, and the values are the \`Action\` definition objects.`,
    ` */`,
    `export type Actions = {`,
    ...serverActionDefinitionEntries.map(
      ([name]) => `  '${name}': typeof _${name.split(':').map(camelCase).join('_')}Action,`,
    ),
    `}`,
    ``,
    `/**`,
    ` * Type representing all defined server-side filter hooks.`,
    ` * The keys are the filter names, and the values are the \`Filter\` definition objects.`,
    ` */`,
    `export type Filters = {`,
    ...serverFilterDefinitionEntries.map(
      ([name]) => `  '${name}': typeof _${name.split(':').map(camelCase).join('_')}Filter,`,
    ),
    `}`,
    ``,
    `/**`,
    ` * Stores all loaded server-side actions in a key-value structure.`,
    ` * The keys represent action names, and their values are arrays of objects containing the following properties:`,
    ` *`,
    ` * - \`callback\` - The action function to be executed.`,
    ` * - \`priority\` - The priority of the action.`,
    ` */`,
    `export const actions: Record<string, { callback: Function, priority: number }[]> = {}`,
    ``,
    `/**`,
    ` * Stores all loaded server-side filters in a key-value structure.`,
    ` * The keys represent filter names, and their values are arrays of objects containing the following properties:`,
    ` *`,
    ` * - \`callback\` - The filter function to be executed.`,
    ` * - \`priority\` - The priority of the filter.`,
    ` */`,
    `export const filters: Record<string, { callback: Function, priority: number }[]> = {}`,
    ``,
    `/**`,
    ` * Loads all server-side actions.`,
    ` *`,
    ` * Actions are functions that allow you to hook into specific points in the application flow.`,
    ` * They provide a way to execute custom code without changing the original implementation.`,
    ` *`,
    ` * This function is called automatically when the server starts.`,
    ` */`,
    `export async function loadActions() {`,
    ...serverActionCallbackEntries.flatMap(([_, locations]) =>
      locations.map(({ file }) => `  await import('${file.import}')`),
    ),
    `}`,
    ``,
    `/**`,
    ` * Loads all server-side filters.`,
    ` *`,
    ` * Filters are functions that allow modification of data at specific points in the application flow.`,
    ` * They provide a way to transform data without changing the original implementation.`,
    ` *`,
    ` * This function is called automatically when the server starts.`,
    ` */`,
    `export async function loadFilters() {`,
    ...serverFilterCallbackEntries.flatMap(([_, locations]) =>
      locations.map(({ file }) => `  await import('${file.import}')`),
    ),
    `}`,
  ].join('\n')
}

/**
 * Generates the `#pruvious/server` file content.
 */
function getServerFileContent() {
  const nuxt = useNuxt()
  const pruviousOptions = nuxt.options.runtimeConfig.pruvious

  debug(`Generating <${relative(nuxt.options.workspaceDir, pruviousOptions.dir.build)}/server/index.ts>`)

  const { resolve } = createResolver(import.meta.url)
  const templateFiles = resolveTemplateFiles()
  const templateEntries = Object.entries(templateFiles)
  const collectionFiles = resolveCollectionFiles()
  const collectionEntries = Object.entries(collectionFiles)
  const singletonFiles = resolveSingletonFiles()
  const singletonEntries = Object.entries(singletonFiles)
  const jobFiles = resolveJobFiles()
  const jobEntries = Object.entries(jobFiles)
  const translationFiles = resolveTranslationFiles()
  const dashboardLanguages = Object.keys(translationFiles['pruvious-dashboard'] ?? {}).map((code) => ({
    code,
    name: new Intl.DisplayNames([code, 'en'], { type: 'language' }).of(code) ?? code,
  }))
  const simpleValidatorsMeta = getSimpleValidatorsMeta()
  const iconNames = getIconNames()
  const permissions = [
    'access-dashboard',
    'update-own-account',
    'read-logs',
    'delete-logs',
    'clear-page-cache',
    'logout-other-users',
    ...collectionEntries
      .map(([name]) => kebabCase(name))
      .flatMap((name) =>
        ['create', 'read', 'update', 'delete', 'manage'].map((action) => `collection:${name}:${action}`),
      ),
    'collection:routes:create',
    'collection:routes:read',
    'collection:routes:update',
    'collection:routes:delete',
    'collection:routes:manage',
    ...singletonEntries
      .map(([name]) => kebabCase(name))
      .flatMap((name) => ['read', 'update'].map((action) => `singleton:${name}:${action}`)),
  ]
  const standardRoutes = [
    'auth/login',
    'auth/logout',
    'auth/logout/others',
    'auth/permissions',
    'auth/renew-token',
    'auth/state',
    'collections/:collection',
    'collections/:collection/:id',
    'collections/:collection/:id/copy-translation',
    'collections/:collection/:id/duplicate',
    'collections/:collection/query/create',
    'collections/:collection/query/read',
    'collections/:collection/query/update',
    'collections/:collection/query/delete',
    'collections/:collection/validate/create',
    'collections/:collection/validate/update',
    'collections/:collection/validate/update/:id',
    'logs/custom',
    'logs/custom/:id',
    'logs/custom/query/delete',
    'logs/custom/query/read',
    'logs/queries',
    'logs/queries/:id',
    'logs/queries/query/delete',
    'logs/queries/query/read',
    'logs/queue',
    'logs/queue/:id',
    'logs/queue/query/delete',
    'logs/queue/query/read',
    'logs/requests',
    'logs/requests/:id',
    'logs/requests/query/delete',
    'logs/requests/query/read',
    'logs/responses',
    'logs/responses/:id',
    'logs/responses/query/delete',
    'logs/responses/query/read',
    'me',
    'me/structure',
    'populate',
    'process-queue',
    'pruvious',
    'pruvious/dashboard',
    'pruvious/install',
    'routes',
    'routes/:path',
    'singletons/:singleton',
    'singletons/:singleton/copy-translation',
    'singletons/:singleton/validate',
    'translations',
    'uploads',
    'uploads/:id',
    'uploads/move/:id',
    'uploads/multipart',
    'uploads/multipart/:key',
  ]

  return [
    `import { I18n, type ExtractDomains, type ExtractHandlesByDomainAndLanguage, type ExtractInput, type ExtractTranslatableStringsDefinitions } from '@pruvious/i18n'`,
    `import { capitalize, isEmpty, isObject, pick, remap, retry } from '@pruvious/utils'`,
    `import { type CustomErrorMessage, Database, type GenericCollection, type GenericValidator, translatableStrings as _pruviousOrmEnTranslation, translatableStringsDe as _pruviousOrmDeTranslation } from '@pruvious/orm'`,
    `import { type PutResult, type GetResult, type StreamResult, type MoveResult, type DeleteResult, type MetaResult, Storage, type StorageFile } from '@pruvious/storage'`,
    `import { logsCollections } from '${resolve('../debug/logs')}'`,
    `import { log, debug } from '${resolve('../debug/console')}'`,
    `import { applyCollectionDebugHooks, applySingletonDebugHooks } from '${resolve('../debug/hooks')}'`,
    `import { collectionGuards } from '${resolve('../collections/guards')}'`,
    `import { cacheCollection } from '${resolve('../cache/collection')}'`,
    `import { queueCollection } from '${resolve('../queue/collection')}'`,
    `import { parseConditionalLogic } from '${resolve('../fields/utils.server')}'`,
    `import type { CollectionAPI, DynamicCollectionFieldTypes } from './dynamic-container-types'`,
    ...collectionEntries.map(([name, { file }]) => `import type ${name}Collection from '${file.import}'`),
    `import type routesCollection from './dynamic-routes-collection'`,
    ...templateEntries.map(([name, { file }]) => `import type ${name}Template from '${file.import}'`),
    ...singletonEntries.map(([name, { file }]) => `import type ${name}Singleton from '${file.import}'`),
    ...jobEntries.map(([name, { file }]) => `import type ${camelCase(name)}Job from '${file.import}'`),
    ...Object.entries(translationFiles).flatMap(([domain, languages]) =>
      Object.entries(languages).flatMap(([language, paths]) =>
        paths
          .filter(isAbsolute)
          .map((path, i) => `import _${camelCase(domain)}${pascalCase(language)}Translation${i || ''} from '${path}'`),
      ),
    ),
    ...(nuxt.options.nitro.preset?.startsWith('cloudflare')
      ? [`// @ts-ignore`, `import type Redis from 'ioredis'`]
      : [`// @ts-ignore`, `import pg from 'pg'`, `// @ts-ignore`, `import Redis from 'ioredis'`]),
    ``,
    `export interface PruviousContext<TUser = { id: number } & DynamicCollectionFieldTypes['Populated']['Users']> {`,
    `  /**`,
    `   * User authentication state and session data.`,
    `   */`,
    `  auth: {`,
    `    /**`,
    `     * Indicates an authenticated user session.`,
    `     */`,
    `    isLoggedIn: true`,
    ``,
    `    /**`,
    `     * The authenticated user's record from the \`Users\` collection.`,
    `     */`,
    `    user: TUser`,
    ``,
    `    /**`,
    `     * The permissions available to the authenticated user.`,
    `     */`,
    `    permissions: Permission[]`,
    `  } | {`,
    `    /**`,
    `     * Indicates no active user session.`,
    `     */`,
    `    isLoggedIn: false`,
    ``,
    `    /**`,
    `     * User object is \`null\` when no session exists.`,
    `     */`,
    `    user: null`,
    ``,
    `    /**`,
    `     * Permissions are only available within an established session.`,
    `     */`,
    `    permissions: []`,
    `  }`,
    ``,
    `  /**`,
    `   * A unique identifier used for debugging and tracing the HTTP request.`,
    `   */`,
    `  requestDebugId: string`,
    ``,
    `  /**`,
    `   * The parsed request body input parameters.`,
    `   *`,
    `   * It is automatically resolved based on \`Content-Type\` header:`,
    `   *`,
    `   * - JSON data - via \`readBody()\``,
    `   * - Multipart form data - via \`readMultipartFormData()\``,
    `   * - URL-encoded forms - via \`readFormData()\``,
    `   * - Raw body content - via \`readRawBody()\``,
    `   *`,
    `   * If the method does not have a body, this will be an empty object.`,
    `   */`,
    `  input: Record<string, any> | Record<string, any>[]`,
    ``,
    `  /**`,
    `   * Object containing all uploaded files.`,
    `   * The object keys are the file paths, and the values are the file contents as \`Buffer\` objects.`,
    `   * The file paths are formatted as \`name/filename\` for nested files, and \`filename\` for top-level files.`,
    `   *`,
    `   * It is automatically resolved based on \`Content-Type\` header:`,
    `   *`,
    `   * - Multipart form data - via \`readMultipartFormData()\``,
    `   *`,
    `   * If the method does not have a body, this will be an empty object.`,
    `   */`,
    `  files: Record<string, Buffer>`,
    ``,
    `  /**`,
    `   * The language code for the current request.`,
    `   * All context messages will be translated into this language.`,
    `   *`,
    `   * It is automatically resolved based on \`Accept-Language\` header.`,
    `   */`,
    `  language: LanguageCode`,
    `}`,
    ``,
    `declare module 'h3' {`,
    `  interface H3EventContext {`,
    `    /**`,
    `     * Context object containing Pruvious-specific data for the current HTTP request.`,
    `     */`,
    `    pruvious: PruviousContext`,
    `  }`,
    `}`,
    ``,
    `let _mainDatabase: MainDatabase`,
    `let _cacheDatabase: CacheDatabase`,
    `let _queueDatabase: QueueDatabase`,
    `let _logsDatabase: LogsDatabase`,
    `let _collectionsLoaded: Promise<void> | false = false`,
    `let _singletonsLoaded: Promise<void> | false = false`,
    `let _jobsLoaded: Promise<void> | false = false`,
    `let _storage: Storage`,
    ``,
    `/**`,
    ` * Type representing all available permissions that can be granted to users in the system.`,
    ` */`,
    `export type Permission = ${permissions.map((p) => `'${p}'`).join(' | ')}`,
    ``,
    `/**`,
    ` * Type definition for language codes supported by the application.`,
    ` * Represents ISO language codes like 'en', 'es', 'fr', etc.`,
    ` */`,
    `export type LanguageCode = ${Object.values(pruviousOptions.i18n.languages)
      .map(({ code }) => `'${code}'`)
      .join(' | ')}`,
    ``,
    `/**`,
    ` * Type representing the the primary language code.`,
    ` */`,
    `export type PrimaryLanguageCode = '${pruviousOptions.i18n.primaryLanguage}'`,
    ``,
    `/**`,
    ` * Type definition for language codes supported by the dashboard.`,
    ` * Represents ISO language codes like 'en', 'es', 'fr', etc.`,
    ` */`,
    `export type DashboardLanguageCode = ${Object.values(dashboardLanguages)
      .map(({ code }) => `'${code}'`)
      .join(' | ')}`,
    ``,
    `/**`,
    ` * Type representing a generic database with the currect I18n instance.`,
    ` */`,
    `export type GenericDatabase = Database<Record<string, GenericCollection>, typeof i18n>`,
    ``,
    `/**`,
    ` * Type representing the main database.`,
    ` */`,
    `export type MainDatabase = Database<Collections, typeof i18n>`,
    ``,
    `/**`,
    ` * Type representing the cache database.`,
    ` */`,
    `export type CacheDatabase = Database<{ Cache: typeof cacheCollection }, typeof i18n> | Redis`,
    ``,
    `/**`,
    ` * Type representing the job queue database.`,
    ` */`,
    `export type QueueDatabase = Database<{ Queue: typeof queueCollection }, typeof i18n>`,
    ``,
    `/**`,
    ` * Type representing the logs database.`,
    ` */`,
    `export type LogsDatabase = Database<typeof logsCollections, typeof i18n>`,
    ``,
    `/**`,
    ` * Type representing all collections utilized by the CMS.`,
    ` * The keys are the collection names, and the values are the \`Collection\` instances.`,
    ` */`,
    `export type Collections = {`,
    ...collectionEntries.map(([name]) => `  ${name}: ReturnType<Awaited<typeof ${name}Collection>>,`),
    `  Routes: ReturnType<typeof routesCollection>,`,
    `}`,
    ``,
    `/**`,
    ` * Type representing all available collection templates.`,
    ` * The keys are the collection names, and the values are the \`DefineCollectionOptions\` objects.`,
    ` */`,
    `export type Templates = {`,
    ...templateEntries.map(([name]) => `  ${name}: ReturnType<typeof ${name}Template>,`),
    `}`,
    ``,
    `/**`,
    ` * Type representing all singletons utilized by the CMS.`,
    ` * The keys are the singleton names, and the values are the \`Singleton\` instances.`,
    ` */`,
    `export type Singletons = {`,
    ...singletonEntries.map(([name]) => `  ${name}: ReturnType<typeof ${name}Singleton>,`),
    `}`,
    ``,
    `/**`,
    ` * Type representing all defined jobs.`,
    ` * The keys are the job names, and the values are the \`Job\` definition objects.`,
    ` */`,
    `export type Jobs = {`,
    ...jobEntries.map(([name]) => `  '${name}': typeof ${camelCase(name)}Job,`),
    `}`,
    ``,
    `/**`,
    ` * Type representing all standard Pruvious API routes.`,
    ` */`,
    `export type StandardRoutes = ${standardRoutes.map((route) => `'${pruviousOptions.api.basePath + route}'`).join(' | ')}`,
    ``,
    `/**`,
    ` * Type definition for custom icon names with their prefixes.`,
    ` * It is generated from the \`icons.customCollections\` option of the \`@nuxt/icon\` module.`,
    ` *`,
    ` * @see https://github.com/nuxt/icon`,
    ` */`,
    `export type IconName = ${iconNames.map((name) => `'${name}'`).join(' | ') || 'never'}`,
    ``,
    `/**`,
    ` * Array of all available user permissions in the system.`,
    ` */`,
    `export const permissions: Permission[] = [${permissions.map((p) => `'${p}'`).join(', ')}]`,
    ``,
    `/**`,
    ` * Array of all registered content languages in the CMS.`,
    ` */`,
    `export const languages = [`,
    ...Object.values(pruviousOptions.i18n.languages).map(({ code, name }) => `  { code: '${code}', name: '${name}' },`),
    `] as const`,
    ``,
    `/**`,
    ` * The primary content language used by the CMS.`,
    ` */`,
    `export const primaryLanguage = '${pruviousOptions.i18n.primaryLanguage}'`,
    ``,
    `/**`,
    ` * Array containing all supported languages for the dashboard interface.`,
    ` */`,
    `export const dashboardLanguages = [`,
    ...Object.values(dashboardLanguages).map(({ code, name }) => `  { code: '${code}', name: '${name}' },`),
    `] as const`,
    ``,
    `/**`,
    ` * Stores all CMS collections in a key-value structure.`,
    ` * The keys are the collection names, and the values are the \`Collection\` instances.`,
    ` */`,
    `export const collections: Collections = {} as any`,
    ``,
    `/**`,
    ` * Stores all CMS singletons in a key-value structure.`,
    ` * The keys are the singleton names, and the values are the \`Singleton\` instances.`,
    ` */`,
    `export const singletons: Singletons = {} as any`,
    ``,
    `/**`,
    ` * Stores all jobs in a key-value structure.`,
    ` * The keys are the job names, and the values are the \`Job\` definition objects.`,
    ` */`,
    `export const jobs: Jobs = {} as any`,
    ``,
    `/**`,
    ` * Array of all custom icon names with their prefixes.`,
    ` * It is generated from the \`icons.customCollections\` option of the \`@nuxt/icon\` module.`,
    ` *`,
    ` * @see https://github.com/nuxt/icon`,
    ` */`,
    `export const iconNames: IconName[] = [${iconNames.map((name) => `'${name}'`).join(', ')}]`,
    ``,
    `/**`,
    ` * Retrieves the \`DefineCollectionOptions\` for a collection \`template\`.`,
    ` *`,
    ` * @throws an error if the \`collection\` is not recognized.`,
    ` */`,
    `export async function getTemplate<TTemplateName extends keyof Templates>(template: TTemplateName) {`,
    `  switch (template) {`,
    ...templateEntries.map(
      ([name, { file }]) => `    case '${name}': return await import('${file.import}').then(m => m.default)`,
    ),
    `    default: throw new Error(\`Template \\\`\${template}\\\` does not exist\`)`,
    `  }`,
    `}`,
    ``,
    `/**`,
    ` * Retrieves the main database connection used by the CMS.`,
    ` */`,
    `export function database(): MainDatabase { return _mainDatabase }`,
    ``,
    `/**`,
    ` * Creates a \`QueryBuilder\` instance for building and executing database queries.`,
    ` *`,
    ` * @see https://pruvious.com/docs/query-builder (@todo set up this link)`,
    ` *`,
    ` * @example`,
    ` * \`\`\`ts`,
    ` * import { queryBuilder } from '#pruvious/server'`,
    ` *`,
    ` * const students = await queryBuilder().selectFrom('Students')`,
    ` *   .select(['firstName', 'lastName'])`,
    ` *   .all()`,
    ` *`,
    ` * console.log(students)`,
    ` * // {`,
    ` * //   success: true,`,
    ` * //   data: [`,
    ` * //     { firstName: 'Harry', lastName: 'Potter' },`,
    ` * //     { firstName: 'Hermione', lastName: 'Granger' },`,
    ` * //     { firstName: 'Ron', lastName: 'Weasley' },`,
    ` * //     // ...`,
    ` * //   ],`,
    ` * //   runtimeError: undefined,`,
    ` * //   inputErrors: undefined,`,
    ` * // }`,
    ` *`,
    ` * const spells = await queryBuilder().insertInto('Spells')`,
    ` *   .values([`,
    ` *     { name: 'Expecto Patronum', type: 'Charm', difficulty: 'Advanced' },`,
    ` *     { name: 'Lumos', type: 'Charm', difficulty: 'Beginner' },`,
    ` *   ])`,
    ` *   .returning(['name'])`,
    ` *   .run()`,
    ` *`,
    ` * console.log(spells)`,
    ` * // {`,
    ` * //   success: true,`,
    ` * //   data: [`,
    ` * //     { name: 'Expecto Patronum' },`,
    ` * //     { name: 'Lumos' },`,
    ` * //   ],`,
    ` * //   runtimeError: undefined,`,
    ` * //   inputErrors: undefined,`,
    ` * // }`,
    ` * \`\`\``,
    ` */`,
    `export function queryBuilder() {`,
    `  return {`,
    `    insertInto,`,
    `    selectFrom,`,
    `    update,`,
    `    deleteFrom,`,
    `  }`,
    `}`,
    ``,
    `/**`,
    ` * Creates a guarded \`QueryBuilder\` instance for building and executing database queries with permission checks.`,
    ` * Applies collection and field guards to ensure that only authorized users can perform operations on the database.`,
    ` *`,
    ` * @see https://pruvious.com/docs/query-builder#guards (@todo set up this link)`,
    ` *`,
    ` * @example`,
    ` * \`\`\`ts`,
    ` * import { guardedQueryBuilder } from '#pruvious/server'`,
    ` *`,
    ` * export default defineEventHandler(async () => {`,
    ` *   const students = await guardedQueryBuilder().selectFrom('Students')`,
    ` *     .select(['firstName', 'lastName'])`,
    ` *     .all()`,
    ` *  `,
    ` *   console.log(students)`,
    ` *   // {`,
    ` *   //   success: true,`,
    ` *   //   data: [`,
    ` *   //     { firstName: 'Harry', lastName: 'Potter' },`,
    ` *   //     { firstName: 'Hermione', lastName: 'Granger' },`,
    ` *   //     { firstName: 'Ron', lastName: 'Weasley' },`,
    ` *   //     // ...`,
    ` *   //   ],`,
    ` *   //   runtimeError: undefined,`,
    ` *   //   inputErrors: undefined,`,
    ` *   // }`,
    ` *  `,
    ` *   const spells = await guardedQueryBuilder().insertInto('Spells')`,
    ` *     .values([`,
    ` *       { name: 'Expecto Patronum', type: 'Charm', difficulty: 'Advanced' },`,
    ` *       { name: 'Lumos', type: 'Charm', difficulty: 'Beginner' },`,
    ` *     ])`,
    ` *     .returning(['name'])`,
    ` *     .run()`,
    ` *  `,
    ` *   console.log(spells)`,
    ` *   // {`,
    ` *   //   success: true,`,
    ` *   //   data: [`,
    ` *   //     { name: 'Expecto Patronum' },`,
    ` *   //     { name: 'Lumos' },`,
    ` *   //   ],`,
    ` *   //   runtimeError: undefined,`,
    ` *   //   inputErrors: undefined,`,
    ` *   // }`,
    ` * })`,
    ` * \`\`\``,
    ` */`,
    `export function guardedQueryBuilder() {`,
    `  return {`,
    `    /**`,
    `     * Creates a guarded \`InsertQueryBuilder\` for a specific \`collection\` that includes permission checks.`,
    `     */`,
    `    insertInto: <TCollectionName extends CollectionAPI['any']['create']>(collection: TCollectionName) => guardedInsertInto(collection),`,
    ``,
    `    /**`,
    `     * Creates a guarded \`SelectQueryBuilder\` for a specific \`collection\` that includes permission checks.`,
    `     */`,
    `    selectFrom: <TCollectionName extends CollectionAPI['any']['read']>(collection: TCollectionName) => guardedSelectFrom(collection),`,
    ``,
    `    /**`,
    `     * Creates a guarded \`UpdateQueryBuilder\` for a specific \`collection\` that includes permission checks.`,
    `     */`,
    `    update: <TCollectionName extends CollectionAPI['any']['update']>(collection: TCollectionName) => guardedUpdate(collection),`,
    ``,
    `    /**`,
    `     * Creates a guarded \`DeleteQueryBuilder\` for a specific \`collection\` that includes permission checks.`,
    `     */`,
    `    deleteFrom: <TCollectionName extends CollectionAPI['any']['delete']>(collection: TCollectionName) => guardedDeleteFrom(collection),`,
    `  }`,
    `}`,
    ``,
    `/**`,
    ` * Creates a \`InsertQueryBuilder\` for a specific \`collection\`.`,
    ` *`,
    ` * @see https://pruvious.com/docs/query-builder#insert-into (@todo set up this link)`,
    ` *`,
    ` * @example`,
    ` * \`\`\`ts`,
    ` * import { insertInto } from '#pruvious/server'`,
    ` *`,
    ` * const newStudents = await insertInto('Students')`,
    ` *   .values([`,
    ` *     { firstName: 'Harry', lastName: 'Potter', house: 1 },`,
    ` *     { firstName: 'Hermione', lastName: 'Granger', house: 1 },`,
    ` *     { firstName: 'Draco', lastName: 'Malfoy', house: 2, prefect: true },`,
    ` *   ])`,
    ` *   .returning(['firstName', 'lastName'])`,
    ` *   .run()`,
    ` *`,
    ` * console.log(newStudents)`,
    ` * // {`,
    ` * //   success: true,`,
    ` * //   data: [`,
    ` * //     { firstName: 'Harry', lastName: 'Potter' },`,
    ` * //     { firstName: 'Hermione', lastName: 'Granger' },`,
    ` * //     { firstName: 'Draco', lastName: 'Malfoy' },`,
    ` * //   ],`,
    ` * //   runtimeError: undefined,`,
    ` * //   inputErrors: undefined,`,
    ` * // }`,
    ` *`,
    ` * const insertedBookCount = await insertInto('Books')`,
    ` *   .values([`,
    ` *     { title: 'Hogwarts: A History', author: 'Bathilda Bagshot' },`,
    ` *     { title: 'Fantastic Beasts and Where to Find Them', author: 'Newt Scamander' },`,
    ` *   ])`,
    ` *   .run()`,
    ` *`,
    ` * console.log(insertedBookCount)`,
    ` * // {`,
    ` * //   success: true,`,
    ` * //   data: 2,`,
    ` * //   runtimeError: undefined,`,
    ` * //   inputErrors: undefined,`,
    ` * // }`,
    ` *`,
    ` * const failedInsert = await insertInto('Spells')`,
    ` *   .values([{ name: 'Avada Kedavra' }])`,
    ` *   .returning(['name'])`,
    ` *   .run()`,
    ` *`,
    ` * console.log(failedInsert)`,
    ` * // {`,
    ` * //   success: false,`,
    ` * //   data: undefined,`,
    ` * //   runtimeError: undefined,`,
    ` * //   inputErrors: [{`,
    ` * //     'type': 'This field is required',`,
    ` * //     'difficulty': 'This field is required',`,
    ` * //   }],`,
    ` * // }`,
    ` * \`\`\``,
    ` */`,
    `export function insertInto<TCollectionName extends CollectionAPI['any']['create']>(collection: TCollectionName) {`,
    `  const event = useEvent()`,
    `  const insertInto = database().queryBuilder({ contextLanguage: event.context.pruvious.language }).insertInto(collection)`,
    `  insertInto.parseConditionalLogic = parseConditionalLogic`,
    `  return insertInto`,
    `}`,
    ``,
    `/**`,
    ` * Creates a guarded \`InsertQueryBuilder\` for a specific \`collection\` that includes permission checks.`,
    ` * Applies collection and field guards to ensure that only authorized users can insert data into the database.`,
    ` *`,
    ` * @see https://pruvious.com/docs/query-builder#guarded-insert-into (@todo set up this link)`,
    ` *`,
    ` * @example`,
    ` * \`\`\`ts`,
    ` * import { guardedInsertInto } from '#pruvious/server'`,
    ` *`,
    ` * export default defineEventHandler(async () => {`,
    ` *   const newStudents = await guardedInsertInto('Students')`,
    ` *     .values([`,
    ` *       { firstName: 'Harry', lastName: 'Potter', house: 1 },`,
    ` *       { firstName: 'Hermione', lastName: 'Granger', house: 1 },`,
    ` *       { firstName: 'Draco', lastName: 'Malfoy', house: 2, prefect: true },`,
    ` *     ])`,
    ` *     .returning(['firstName', 'lastName'])`,
    ` *     .run()`,
    ` *  `,
    ` *   console.log(newStudents)`,
    ` *   // {`,
    ` *   //   success: true,`,
    ` *   //   data: [`,
    ` *   //     { firstName: 'Harry', lastName: 'Potter' },`,
    ` *   //     { firstName: 'Hermione', lastName: 'Granger' },`,
    ` *   //     { firstName: 'Draco', lastName: 'Malfoy' },`,
    ` *   //   ],`,
    ` *   //   runtimeError: undefined,`,
    ` *   //   inputErrors: undefined,`,
    ` *   // }`,
    ` *  `,
    ` *   const insertedBookCount = await guardedInsertInto('Books')`,
    ` *     .values([`,
    ` *       { title: 'Hogwarts: A History', author: 'Bathilda Bagshot' },`,
    ` *       { title: 'Fantastic Beasts and Where to Find Them', author: 'Newt Scamander' },`,
    ` *     ])`,
    ` *     .run()`,
    ` *  `,
    ` *   console.log(insertedBookCount)`,
    ` *   // {`,
    ` *   //   success: true,`,
    ` *   //   data: 2,`,
    ` *   //   runtimeError: undefined,`,
    ` *   //   inputErrors: undefined,`,
    ` *   // }`,
    ` *  `,
    ` *   const failedInsert = await guardedInsertInto('Spells')`,
    ` *     .values([{ name: 'Avada Kedavra' }])`,
    ` *     .returning(['name'])`,
    ` *     .run()`,
    ` *  `,
    ` *   console.log(failedInsert)`,
    ` *   // {`,
    ` *   //   success: false,`,
    ` *   //   data: undefined,`,
    ` *   //   runtimeError: undefined,`,
    ` *   //   inputErrors: [{`,
    ` *   //     'type': 'This field is required',`,
    ` *   //     'difficulty': 'This field is required',`,
    ` *   //   }],`,
    ` *   // }`,
    ` * })`,
    ` * \`\`\``,
    ` */`,
    `export function guardedInsertInto<TCollectionName extends CollectionAPI['any']['create']>(collection: TCollectionName) {`,
    `  const event = useEvent()`,
    `  const insertInto = database().queryBuilder({ contextLanguage: event.context.pruvious.language }).insertInto(collection).prepare(collectionGuards())`,
    `  insertInto.parseConditionalLogic = parseConditionalLogic`,
    `  return insertInto`,
    `}`,
    ``,
    `/**`,
    ` * Creates a \`SelectQueryBuilder\` for a specific \`collection\`.`,
    ` *`,
    ` * @see https://pruvious.com/docs/query-builder#select-from (@todo set up this link)`,
    ` *`,
    ` * @example`,
    ` * \`\`\`ts`,
    ` * import { selectFrom } from '#pruvious/server'`,
    ` *`,
    ` * const students = await selectFrom('Students')`,
    ` *   .select(['firstName', 'lastName'])`,
    ` *   .all()`,
    ` *`,
    ` * console.log(students)`,
    ` * // {`,
    ` * //   success: true,`,
    ` * //   data: [`,
    ` * //     { firstName: 'Harry', lastName: 'Potter' },`,
    ` * //     { firstName: 'Hermione', lastName: 'Granger' },`,
    ` * //     { firstName: 'Ron', lastName: 'Weasley' },`,
    ` * //     // ...`,
    ` * //   ],`,
    ` * //   runtimeError: undefined,`,
    ` * //   inputErrors: undefined,`,
    ` * // }`,
    ` *`,
    ` * const houses = await selectFrom('Houses')`,
    ` *   .selectAll()`,
    ` *   .all()`,
    ` *`,
    ` * console.log(houses)`,
    ` * // {`,
    ` * //   success: true,`,
    ` * //   data: [`,
    ` * //     {`,
    ` * //       id: 1,`,
    ` * //       name: 'Gryffindor',`,
    ` * //       founder: 'Godric Gryffindor',`,
    ` * //       createdAt: 1724091250000,`,
    ` * //       updatedAt: 1724091250000,`,
    ` * //     },`,
    ` * //     {`,
    ` * //       id: 2,`,
    ` * //       name: 'Slytherin',`,
    ` * //       founder: 'Salazar Slytherin',`,
    ` * //       createdAt: 1724091250000,`,
    ` * //       updatedAt: 1724091250000,`,
    ` * //     },`,
    ` * //     {`,
    ` * //       id: 3,`,
    ` * //       name: 'Ravenclaw',`,
    ` * //       founder: 'Rowena Ravenclaw',`,
    ` * //       createdAt: 1724091250000,`,
    ` * //       updatedAt: 1724091250000,`,
    ` * //     },`,
    ` * //     {`,
    ` * //       id: 4,`,
    ` * //       name: 'Hufflepuff',`,
    ` * //       founder: 'Helga Hufflepuff',`,
    ` * //       createdAt: 1724091250000,`,
    ` * //       updatedAt: 1724091250000,`,
    ` * //     },`,
    ` * //   ],`,
    ` * //   runtimeError: undefined,`,
    ` * //   inputErrors: undefined,`,
    ` * // }`,
    ` *`,
    ` * const failedSelect = await selectFrom('Wands')`,
    ` *   .select(['wood', 'core', 'length', 'wandmaker'])`,
    ` *   .all()`,
    ` *`,
    ` * console.log(failedSelect)`,
    ` * // {`,
    ` * //   success: false,`,
    ` * //   data: undefined,`,
    ` * //   runtimeError: "The field 'wandmaker' does not exist",`,
    ` * //   inputErrors: undefined,`,
    ` * // }`,
    ` * \`\`\``,
    ` */`,
    `export function selectFrom<TCollectionName extends CollectionAPI['any']['read']>(collection: TCollectionName) {`,
    `  const event = useEvent()`,
    `  return database().queryBuilder({ contextLanguage: event.context.pruvious.language }).selectFrom(collection)`,
    `}`,
    ``,
    `/**`,
    ` * Creates a \`SelectQueryBuilder\` for a specific \`collection\` that includes permission checks.`,
    ` * Applies collection and field guards to ensure that only authorized users can select data from the database.`,
    ` *`,
    ` * @see https://pruvious.com/docs/query-builder#guarded-select-from (@todo set up this link)`,
    ` *`,
    ` * @example`,
    ` * \`\`\`ts`,
    ` * import { guardedSelectFrom } from '#pruvious/server'`,
    ` *`,
    ` * export default defineEventHandler(async () => {`,
    ` *   const students = await guardedSelectFrom('Students')`,
    ` *     .select(['firstName', 'lastName'])`,
    ` *     .all()`,
    ` *  `,
    ` *   console.log(students)`,
    ` *   // {`,
    ` *   //   success: true,`,
    ` *   //   data: [`,
    ` *   //     { firstName: 'Harry', lastName: 'Potter' },`,
    ` *   //     { firstName: 'Hermione', lastName: 'Granger' },`,
    ` *   //     { firstName: 'Ron', lastName: 'Weasley' },`,
    ` *   //     // ...`,
    ` *   //   ],`,
    ` *   //   runtimeError: undefined,`,
    ` *   //   inputErrors: undefined,`,
    ` *   // }`,
    ` *  `,
    ` *   const houses = await guardedSelectFrom('Houses')`,
    ` *     .selectAll()`,
    ` *     .all()`,
    ` *  `,
    ` *   console.log(houses)`,
    ` *   // {`,
    ` *   //   success: true,`,
    ` *   //   data: [`,
    ` *   //     {`,
    ` *   //       id: 1,`,
    ` *   //       name: 'Gryffindor',`,
    ` *   //       founder: 'Godric Gryffindor',`,
    ` *   //       createdAt: 1724091250000,`,
    ` *   //       updatedAt: 1724091250000,`,
    ` *   //     },`,
    ` *   //     {`,
    ` *   //       id: 2,`,
    ` *   //       name: 'Slytherin',`,
    ` *   //       founder: 'Salazar Slytherin',`,
    ` *   //       createdAt: 1724091250000,`,
    ` *   //       updatedAt: 1724091250000,`,
    ` *   //     },`,
    ` *   //     {`,
    ` *   //       id: 3,`,
    ` *   //       name: 'Ravenclaw',`,
    ` *   //       founder: 'Rowena Ravenclaw',`,
    ` *   //       createdAt: 1724091250000,`,
    ` *   //       updatedAt: 1724091250000,`,
    ` *   //     },`,
    ` *   //     {`,
    ` *   //       id: 4,`,
    ` *   //       name: 'Hufflepuff',`,
    ` *   //       founder: 'Helga Hufflepuff',`,
    ` *   //       createdAt: 1724091250000,`,
    ` *   //       updatedAt: 1724091250000,`,
    ` *   //     },`,
    ` *   //   ],`,
    ` *   //   runtimeError: undefined,`,
    ` *   //   inputErrors: undefined,`,
    ` *   // }`,
    ` *  `,
    ` *   const failedSelect = await guardedSelectFrom('Wands')`,
    ` *     .select(['wood', 'core', 'length', 'wandmaker'])`,
    ` *     .all()`,
    ` *  `,
    ` *   console.log(failedSelect)`,
    ` *   // {`,
    ` *   //   success: false,`,
    ` *   //   data: undefined,`,
    ` *   //   runtimeError: "The field 'wandmaker' does not exist",`,
    ` *   //   inputErrors: undefined,`,
    ` *   // }`,
    ` * })`,
    ` * \`\`\``,
    ` */`,
    `export function guardedSelectFrom<TCollectionName extends CollectionAPI['any']['read']>(collection: TCollectionName) {`,
    `  const event = useEvent()`,
    `  return database().queryBuilder({ contextLanguage: event.context.pruvious.language }).selectFrom(collection).prepare(collectionGuards())`,
    `}`,
    ``,
    `/**`,
    ` * Creates a \`UpdateQueryBuilder\` for a specific \`collection\`.`,
    ` *`,
    ` * @see https://pruvious.com/docs/query-builder#update (@todo set up this link)`,
    ` *`,
    ` * @example`,
    ` * \`\`\`ts`,
    ` * import { update } from '#pruvious/server'`,
    ` *`,
    ` * const updatedStudent = await update('Students')`,
    ` *   .set({ house: 2, prefect: true })`,
    ` *   .where('firstName', '=', 'Harry')`,
    ` *   .where('lastName', '=', 'Potter')`,
    ` *   .returning(['firstName', 'lastName', 'house', 'prefect'])`,
    ` *   .run()`,
    ` *`,
    ` * console.log(updatedStudent)`,
    ` * // {`,
    ` * //   success: true,`,
    ` * //   data: [`,
    ` * //     { firstName: 'Harry', lastName: 'Potter', house: 2, prefect: true },`,
    ` * //   ],`,
    ` * //   runtimeError: undefined,`,
    ` * //   inputErrors: undefined,`,
    ` * // }`,
    ` *`,
    ` * const updatedBookCount = await update('Books')`,
    ` *   .set({ author: 'Newt Scamander' })`,
    ` *   .where('title', '=', 'Fantastic Beasts and Where to Find Them')`,
    ` *   .run()`,
    ` *`,
    ` * console.log(updatedBookCount)`,
    ` * // {`,
    ` * //   success: true,`,
    ` * //   data: 1,`,
    ` * //   runtimeError: undefined,`,
    ` * //   inputErrors: undefined,`,
    ` * // }`,
    ` *`,
    ` * const failedUpdate = await update('Spells')`,
    ` *   .set({ difficulty: 'Impossible' })`,
    ` *   .where('name', '=', 'Expelliarmus')`,
    ` *   .returning(['name', 'difficulty'])`,
    ` *   .run()`,
    ` *`,
    ` * console.log(failedUpdate)`,
    ` * // {`,
    ` * //   success: false,`,
    ` * //   data: undefined,`,
    ` * //   runtimeError: undefined,`,
    ` * //   inputErrors: {`,
    ` * //     'difficulty': 'Invalid difficulty level',`,
    ` * //   },`,
    ` * // }`,
    ` * \`\`\``,
    ` */`,
    `export function update<TCollectionName extends CollectionAPI['any']['update']>(collection: TCollectionName) {`,
    `  const event = useEvent()`,
    `  const update = database().queryBuilder({ contextLanguage: event.context.pruvious.language }).update(collection)`,
    `  update.parseConditionalLogic = parseConditionalLogic`,
    `  return update`,
    `}`,
    ``,
    `/**`,
    ` * Creates a \`UpdateQueryBuilder\` for a specific \`collection\` that includes permission checks.`,
    ` * Applies collection and field guards to ensure that only authorized users can update data in the database.`,
    ` *`,
    ` * @see https://pruvious.com/docs/query-builder#guarded-update (@todo set up this link)`,
    ` *`,
    ` * @example`,
    ` * \`\`\`ts`,
    ` * import { guardedUpdate } from '#pruvious/server'`,
    ` *`,
    ` * export default defineEventHandler(async () => {`,
    ` *   const updatedStudent = await guardedUpdate('Students')`,
    ` *     .set({ house: 2, prefect: true })`,
    ` *     .where('firstName', '=', 'Harry')`,
    ` *     .where('lastName', '=', 'Potter')`,
    ` *     .returning(['firstName', 'lastName', 'house', 'prefect'])`,
    ` *     .run()`,
    ` *  `,
    ` *   console.log(updatedStudent)`,
    ` *   // {`,
    ` *   //   success: true,`,
    ` *   //   data: [`,
    ` *   //     { firstName: 'Harry', lastName: 'Potter', house: 2, prefect: true },`,
    ` *   //   ],`,
    ` *   //   runtimeError: undefined,`,
    ` *   //   inputErrors: undefined,`,
    ` *   // }`,
    ` *  `,
    ` *   const updatedBookCount = await guardedUpdate('Books')`,
    ` *     .set({ author: 'Newt Scamander' })`,
    ` *     .where('title', '=', 'Fantastic Beasts and Where to Find Them')`,
    ` *     .run()`,
    ` *  `,
    ` *   console.log(updatedBookCount)`,
    ` *   // {`,
    ` *   //   success: true,`,
    ` *   //   data: 1,`,
    ` *   //   runtimeError: undefined,`,
    ` *   //   inputErrors: undefined,`,
    ` *   // }`,
    ` *  `,
    ` *   const failedUpdate = await guardedUpdate('Spells')`,
    ` *     .set({ difficulty: 'Impossible' })`,
    ` *     .where('name', '=', 'Expelliarmus')`,
    ` *     .returning(['name', 'difficulty'])`,
    ` *     .run()`,
    ` *  `,
    ` *   console.log(failedUpdate)`,
    ` *   // {`,
    ` *   //   success: false,`,
    ` *   //   data: undefined,`,
    ` *   //   runtimeError: undefined,`,
    ` *   //   inputErrors: {`,
    ` *   //     'difficulty': 'Invalid difficulty level',`,
    ` *   //   },`,
    ` *   // }`,
    ` * })`,
    ` * \`\`\``,
    ` */`,
    `export function guardedUpdate<TCollectionName extends CollectionAPI['any']['update']>(collection: TCollectionName) {`,
    `  const event = useEvent()`,
    `  const update = database().queryBuilder({ contextLanguage: event.context.pruvious.language }).update(collection).prepare(collectionGuards())`,
    `  update.parseConditionalLogic = parseConditionalLogic`,
    `  return update`,
    `}`,
    ``,
    `/**`,
    ` * Creates a \`DeleteQueryBuilder\` for a specific \`collection\`.`,
    ` *`,
    ` * @see https://pruvious.com/docs/query-builder#delete-from (@todo set up this link)`,
    ` *`,
    ` * @example`,
    ` * \`\`\`ts`,
    ` * import { deleteFrom } from '#pruvious/server'`,
    ` *`,
    ` * const deletedStudent = await deleteFrom('Students')`,
    ` *   .where('firstName', '=', 'Draco')`,
    ` *   .where('lastName', '=', 'Malfoy')`,
    ` *   .returning(['firstName', 'lastName'])`,
    ` *   .run()`,
    ` *`,
    ` * console.log(deletedStudent)`,
    ` * // {`,
    ` * //   success: true,`,
    ` * //   data: [`,
    ` * //     { firstName: 'Draco', lastName: 'Malfoy' },`,
    ` * //   ],`,
    ` * //   runtimeError: undefined,`,
    ` * //   inputErrors: undefined,`,
    ` * // }`,
    ` *`,
    ` * const deletedBookCount = await deleteFrom('Books')`,
    ` *   .where('author', '=', 'Gilderoy Lockhart')`,
    ` *   .run()`,
    ` *`,
    ` * console.log(deletedBookCount) // 7`,
    ` *`,
    ` * const failedDelete = await deleteFrom('Houses')`,
    ` *   .where('name', 'Slytherin')`,
    ` *   .returning(['name'])`,
    ` *   .run()`,
    ` *`,
    ` * console.log(failedDelete)`,
    ` * // {`,
    ` * //   success: false,`,
    ` * //   data: undefined,`,
    ` * //   runtimeError: 'Cannot delete a Hogwarts house',`,
    ` * //   inputErrors: undefined,`,
    ` * // }`,
    ` * \`\`\``,
    ` */`,
    `export function deleteFrom<TCollectionName extends CollectionAPI['any']['delete']>(collection: TCollectionName) {`,
    `  const event = useEvent()`,
    `  return database().queryBuilder({ contextLanguage: event.context.pruvious.language }).deleteFrom(collection)`,
    `}`,
    ``,
    `/**`,
    ` * Creates a \`DeleteQueryBuilder\` for a specific \`collection\` that includes permission checks.`,
    ` * Applies collection and field guards to ensure that only authorized users can delete data from the database.`,
    ` *`,
    ` * @see https://pruvious.com/docs/query-builder#guarded-delete-from (@todo set up this link)`,
    ` *`,
    ` * @example`,
    ` * \`\`\`ts`,
    ` * import { guardedDeleteFrom } from '#pruvious/server'`,
    ` *`,
    ` * export default defineEventHandler(async () => {`,
    ` *   const deletedStudent = await guardedDeleteFrom('Students')`,
    ` *     .where('firstName', '=', 'Draco')`,
    ` *     .where('lastName', '=', 'Malfoy')`,
    ` *     .returning(['firstName', 'lastName'])`,
    ` *     .run()`,
    ` *  `,
    ` *   console.log(deletedStudent)`,
    ` *   // {`,
    ` *   //   success: true,`,
    ` *   //   data: [`,
    ` *   //     { firstName: 'Draco', lastName: 'Malfoy' },`,
    ` *   //   ],`,
    ` *   //   runtimeError: undefined,`,
    ` *   //   inputErrors: undefined,`,
    ` *   // }`,
    ` *  `,
    ` *   const deletedBookCount = await guardedDeleteFrom('Books')`,
    ` *     .where('author', '=', 'Gilderoy Lockhart')`,
    ` *     .run()`,
    ` *  `,
    ` *   console.log(deletedBookCount) // 7`,
    ` *  `,
    ` *   const failedDelete = await guardedDeleteFrom('Houses')`,
    ` *     .where('name', 'Slytherin')`,
    ` *     .returning(['name'])`,
    ` *     .run()`,
    ` *  `,
    ` *   console.log(failedDelete)`,
    ` *   // {`,
    ` *   //   success: false,`,
    ` *   //   data: undefined,`,
    ` *   //   runtimeError: 'Cannot delete a Hogwarts house',`,
    ` *   //   inputErrors: undefined,`,
    ` *   // }`,
    ` * })`,
    ` * \`\`\``,
    ` */`,
    `export function guardedDeleteFrom<TCollectionName extends CollectionAPI['any']['delete']>(collection: TCollectionName) {`,
    `  const event = useEvent()`,
    `  return database().queryBuilder({ contextLanguage: event.context.pruvious.language }).deleteFrom(collection).prepare(collectionGuards())`,
    `}`,
    ``,
    `/**`,
    ` * Retrieves the database connection dedicated for caching data.`,
    ` */`,
    `export function getCacheDatabase(): CacheDatabase { return _cacheDatabase }`,
    ``,
    `/**`,
    ` * Retrieves the database connection dedicated for internal queue management.`,
    ` */`,
    `export function getQueueDatabase(): QueueDatabase { return _queueDatabase }`,
    ``,
    `/**`,
    ` * Retrieves the database connection dedicated to logging queries from the main database.`,
    ` */`,
    `export function getLogsDatabase(): LogsDatabase { return _logsDatabase }`,
    ``,
    `/**`,
    ` * Initializes all databases for the CMS.`,
    ` */`,
    `export async function initAllDatabases() {`,
    `  const runtimeConfig = useRuntimeConfig()`,
    ``,
    `  await loadCollections()`,
    `  await loadSingletons()`,
    `  await initMainDatabase()`,
    `  await initCacheDatabase()`,
    `  await initQueueDatabase()`,
    ``,
    `  if (runtimeConfig.pruvious.debug.logs.enabled) {`,
    `    await initLogsDatabase()`,
    `  }`,
    `}`,
    ``,
    `/**`,
    ` * Retrieves all collections and singletons that can be referenced in routes.`,
    ` */`,
    `export async function getRouteReferences(): Promise<RouteReferences> {`,
    `  const { numberField } = await import('./fields')`,
    `  const routedCollections = Object.fromEntries(Object.entries(collections).filter(([_, collection]) => collection.meta.routing.enabled).map(([name, collection]) => [name, { fields: { id: numberField({}), ...collection.fields }, routing: collection.meta.routing, dataContainerType: 'collection', dataContainerName: name }]))`,
    `  const routedSingletons = Object.fromEntries(Object.entries(singletons).filter(([_, singleton]) => singleton.routing.enabled).map(([name, singleton]) => [name, { fields: singleton.routing, routing: singleton.routing, dataContainerType: 'singleton', dataContainerName: name }]))`,
    `  const routedContainers: Record<string, any> = { ...routedCollections }`,
    ``,
    `  for (const [name, singleton] of Object.entries(routedSingletons)) {`,
    `    const ref = routedContainers[name] ? \`\${name}:Singleton\` : name`,
    `    routedContainers[ref] = singleton`,
    `  }`,
    ``,
    `  return remap(routedContainers, (ref, { fields, routing, dataContainerType, dataContainerName }) => [`,
    `    ref,`,
    `    {`,
    `      publicFields: pick(fields, routing.publicFields),`,
    `      dataContainerType,`,
    `      dataContainerName,`,
    `      layout: routing.layout,`,
    `    },`,
    `  ]) as any`,
    `}`,
    ``,
    `/**`,
    ` * Initializes the main database connection for the CMS.`,
    ` */`,
    `export async function initMainDatabase() {`,
    `  if (!_mainDatabase) {`,
    `    debug('Initializing main database')`,
    `    const runtimeConfig = useRuntimeConfig()`,
    `    _mainDatabase = new Database({`,
    `      ...runtimeConfig.pruvious.database,`,
    ...(nuxt.options.nitro.preset?.startsWith('cloudflare') ? [] : [`      PGPool: pg.Pool,`]),
    `      collections: {`,
    `        ...collections,`,
    `        ...(runtimeConfig.pruvious.cache.driver === 'mainDatabase' ? { Cache: cacheCollection } : {}),`,
    `        ...(runtimeConfig.pruvious.queue.driver === 'mainDatabase' ? { Queue: queueCollection } : {}),`,
    `      },`,
    `      verbose: runtimeConfig.pruvious.debug.verbose ? 'sync' : false,`,
    `      logger: log,`,
    `      i18n,`,
    `      sync: runtimeConfig.pruvious.database.sync === false ? false : {`,
    `        dropNonCollectionTables: isObject(runtimeConfig.pruvious.database.sync) ? !!runtimeConfig.pruvious.database.sync.dropNonCollectionTables : false,`,
    `        dropNonFieldColumns: isObject(runtimeConfig.pruvious.database.sync) ? !!runtimeConfig.pruvious.database.sync.dropNonFieldColumns : false,`,
    `      },`,
    `    }) as any`,
    ``,
    `    if (_mainDatabase.connectionStatus === 'disconnected') {`,
    `      await _mainDatabase.connect()`,
    `    } else {`,
    `      await retry(async (resolve) => {`,
    `        if (_mainDatabase.connectionStatus === 'connected') {`,
    `          resolve()`,
    `        }`,
    `      })`,
    `    }`,
    `  }`,
    `}`,
    ``,
    `/**`,
    ` * Initializes a database connection for storing cache data.`,
    ` */`,
    `export async function initCacheDatabase() {`,
    `  if (!_cacheDatabase) {`,
    `    const runtimeConfig = useRuntimeConfig()`,
    `    const type = runtimeConfig.pruvious.cache.driver.split('://')[0]!`,
    ``,
    `    if (['sqlite', 'postgres', 'd1'].includes(type)) {`,
    `      _cacheDatabase = new Database({`,
    `        driver: runtimeConfig.pruvious.debug.logs.driver,`,
    ...(nuxt.options.nitro.preset?.startsWith('cloudflare') ? [] : [`      PGPool: pg.Pool,`]),
    `        collections: { Cache: cacheCollection },`,
    `        logger: log,`,
    `        i18n,`,
    `      })`,
    ``,
    `      if ((_cacheDatabase as Database).connectionStatus === 'disconnected') {`,
    `        await (_cacheDatabase as Database).connect()`,
    `      } else {`,
    `        await retry(async (resolve) => {`,
    `          if ((_cacheDatabase as Database).connectionStatus === 'connected') {`,
    `            resolve()`,
    `          }`,
    `        })`,
    `      }`,
    `    } else if (['redis', 'rediss'].includes(type)) {`,
    `      // @todo`,
    `    } else if (type === 'mainDatabase') {`,
    `      _cacheDatabase = _mainDatabase as any`,
    `    } else {`,
    `      throw new Error('Invalid driver provided in \`pruvious.cache.driver\`')`,
    `    }`,
    `  }`,
    `}`,
    ``,
    `/**`,
    ` * Initializes a database connection for internal queue management.`,
    ` */`,
    `export async function initQueueDatabase() {`,
    `  if (!_queueDatabase) {`,
    `    const runtimeConfig = useRuntimeConfig()`,
    `    const type = runtimeConfig.pruvious.queue.driver.split('://')[0]!`,
    ``,
    `    if (['sqlite', 'postgres', 'd1'].includes(type)) {`,
    `      _queueDatabase = new Database({`,
    `        driver: runtimeConfig.pruvious.debug.logs.driver,`,
    ...(nuxt.options.nitro.preset?.startsWith('cloudflare') ? [] : [`      PGPool: pg.Pool,`]),
    `        collections: { Queue: queueCollection },`,
    `        logger: log,`,
    `        i18n,`,
    `      })`,
    ``,
    `      if (_queueDatabase.connectionStatus === 'disconnected') {`,
    `        await _queueDatabase.connect()`,
    `      } else {`,
    `        await retry(async (resolve) => {`,
    `          if (_queueDatabase.connectionStatus === 'connected') {`,
    `            resolve()`,
    `          }`,
    `        })`,
    `      }`,
    `    } else if (type === 'mainDatabase') {`,
    `      _queueDatabase = _mainDatabase as any`,
    `    } else {`,
    `      throw new Error('Invalid driver provided in \`pruvious.queue.driver\`')`,
    `    }`,
    ``,
    `    await loadJobs()`,
    `  }`,
    `}`,
    ``,
    `/**`,
    ` * Initializes a database connection for logging queries from the main database.`,
    ` * These logs are accessible in the Pruvious dashboard for admins and developers.`,
    ` */`,
    `export async function initLogsDatabase() {`,
    `  if (!_logsDatabase) {`,
    `    const runtimeConfig = useRuntimeConfig()`,
    ``,
    `    if (runtimeConfig.pruvious.debug.logs.enabled) {`,
    `      _logsDatabase = new Database({`,
    `        driver: runtimeConfig.pruvious.debug.logs.driver,`,
    ...(nuxt.options.nitro.preset?.startsWith('cloudflare') ? [] : [`      PGPool: pg.Pool,`]),
    `        collections: logsCollections,`,
    `        i18n,`,
    `      })`,
    ``,
    `      if (_logsDatabase.connectionStatus === 'disconnected') {`,
    `        await _logsDatabase.connect()`,
    `      } else {`,
    `        await retry(async (resolve) => {`,
    `          if (_logsDatabase.connectionStatus === 'connected') {`,
    `            resolve()`,
    `          }`,
    `        })`,
    `      }`,
    `    }`,
    `  }`,
    `}`,
    ``,
    `/**`,
    ` * Loads all collections for the main database.`,
    ` */`,
    `async function loadCollections() {`,
    `  if (!_collectionsLoaded) {`,
    `    _collectionsLoaded = new Promise<void>(async (resolve) => {`,
    `      Object.assign(collections, {`,
    ...collectionEntries.map(
      ([name, location]) =>
        `          ${name}: await import('${location.file.import}').then(async (m) => applyCollectionDebugHooks((await m.default)({ collectionName: '${name}', location: ${JSON.stringify({ file: { absolute: location.file.absolute, relative: location.file.relative }, srcDir: location.layer.config.srcDir })} }) as any)),`,
    ),
    `          Routes: await import('./dynamic-routes-collection').then(async (m) => applyCollectionDebugHooks((await m.default)({ collectionName: 'Routes', location: ${JSON.stringify({ file: { absolute: `${pruviousOptions.dir.build}/server/dynamic-routes-collection.ts`, relative: `${relative(nuxt.options.workspaceDir, `${pruviousOptions.dir.build}/server/dynamic-routes-collection.ts`)}` }, srcDir: nuxt.options.srcDir })} }) as any)),`,
    `      })`,
    `      resolve()`,
    `    })`,
    `  }`,
    `  await _collectionsLoaded`,
    `}`,
    ``,
    `/**`,
    ` * Loads all singletons for the main database.`,
    ` */`,
    `async function loadSingletons() {`,
    `  if (!_singletonsLoaded) {`,
    `    _singletonsLoaded = new Promise<void>(async (resolve) => {`,
    `      Object.assign(singletons, {`,
    ...singletonEntries.map(
      ([name, location]) =>
        `          ${name}: await import('${location.file.import}').then(async (m) => applySingletonDebugHooks(m.default({ singletonName: '${name}', location: ${JSON.stringify({ file: { absolute: location.file.absolute, relative: location.file.relative }, srcDir: location.layer.config.srcDir })} }) as any)),`,
    ),
    `      })`,
    `      resolve()`,
    `    })`,
    `  }`,
    `  await _singletonsLoaded`,
    `}`,
    ``,
    `/**`,
    ` * Loads all job definitions.`,
    ` */`,
    `export async function loadJobs() {`,
    `  if (!_jobsLoaded) {`,
    `    _jobsLoaded = new Promise<void>(async (resolve) => {`,
    `      Object.assign(jobs, {`,
    ...jobEntries.map(
      ([name, { file }]) => `          '${name}': await import('${file.import}').then(async (m) => m.default),`,
    ),
    `      })`,
    `      resolve()`,
    `    })`,
    `  }`,
    `  await _jobsLoaded`,
    `}`,
    ``,
    `/**`,
    ` * Retrieves the storage manager.`,
    ` */`,
    `export function storage() { return _storage }`,
    ``,
    `/**`,
    ` * Stores a \`file\` at a specified \`path\` in the storage system.`,
    ` *`,
    ` * Returns a \`Result\` object with a \`success\` property indicating whether the operation was successful.`,
    ` *`,
    ` * - If successful, the \`data\` property contains the normalized file location and metadata.`,
    ` * - If unsuccessful, the \`error\` property contains the error message.`,
    ` *`,
    ` * @example`,
    ` * \`\`\`ts`,
    ` * await putFile(file, '/path/to/MyImage.webp')`,
    ` * // {`,
    ` * //   success: true,`,
    ` * //   data: {`,
    ` * //     path: '/path/to/my-image.webp',`,
    ` * //     dir: '/path/to',`,
    ` * //     name: 'my-image.webp',`,
    ` * //     ext: 'webp',`,
    ` * //     size: 1024,`,
    ` * //     etag: '...',`,
    ` * //   },`,
    ` * // }`,
    ` * \`\`\``,
    ` */`,
    `export async function putFile(file: StorageFile, path: string): Promise<PutResult> {`,
    `  return _storage.put(file, path)`,
    `}`,
    ``,
    `/**`,
    ` * Retrieves a file from the storage system.`,
    ` *`,
    ` * Returns a \`Result\` object with a \`success\` property indicating whether the operation was successful.`,
    ` *`,
    ` * - If successful, the \`data\` property contains the normalized file buffer, location, and metadata.`,
    ` * - If unsuccessful, the \`error\` property contains the error message.`,
    ` *`,
    ` * @example`,
    ` * \`\`\`ts`,
    ` * const file = await getFile('/path/to/MyImage.webp')`,
    ` * // {`,
    ` * //   success: true,`,
    ` * //   data: {`,
    ` * //    file: '...', // file data`,
    ` * //    path: '/path/to/my-image.webp',`,
    ` * //    dir: '/path/to',`,
    ` * //    name: 'my-image.webp',`,
    ` * //    ext: 'webp',`,
    ` * //    size: 1024,`,
    ` * //    etag: '...',`,
    ` * //   },`,
    ` * // }`,
    ` * \`\`\``,
    ` */`,
    `export async function getFile(path: string): Promise<GetResult> {`,
    `  return _storage.get(path)`,
    `}`,
    ``,
    `/**`,
    ` * Streams a file from the storage system.`,
    ` * You can specify the \`start\` and \`end\` byte offsets (zero-indexed & inclusive) to read a range of bytes.`,
    ` *`,
    ` * Returns a \`Result\` object with a \`success\` property indicating whether the operation was successful.`,
    ` *`,
    ` * - If successful, the \`data\` property contains the \`ReadStream\` or \`ReadableStream\`, normalized file location, and metadata.`,
    ` * - If unsuccessful, the \`error\` property contains the error message.`,
    ` *`,
    ` * @example`,
    ` * \`\`\`ts`,
    ` * const stream = await streamFile('/path/to/image.webp')`,
    ` * // {`,
    ` * //   success: true,`,
    ` * //   data: {`,
    ` * //     stream: '...', // ReadStream or ReadableStream`,
    ` * //     path: '/path/to/image.webp',`,
    ` * //     dir: '/path/to',`,
    ` * //     name: 'image.webp',`,
    ` * //     ext: 'webp',`,
    ` * //     size: 1024,`,
    ` * //     etag: '...',`,
    ` * //   },`,
    ` * // }`,
    ` * \`\`\``,
    ` */`,
    `export async function streamFile(path: string, start?: number, end?: number): Promise<StreamResult> {`,
    `  return _storage.stream(path, start, end)`,
    `}`,
    ``,
    `/**`,
    ` * Moves a file \`from\` one location \`to\` another in the storage system.`,
    ` *`,
    ` * Returns a \`Result\` object with a \`success\` property indicating whether the operation was successful.`,
    ` *`,
    ` * - If successful, the \`data\` property contains the new normalized file location and metadata.`,
    ` * - If unsuccessful, the \`error\` property contains the error message.`,
    ` *`,
    ` * @example`,
    ` * \`\`\`ts`,
    ` * await storage.move('/path/to/image.webp', '/path/to/images/image.webp')`,
    ` * // {`,
    ` * //   success: true,`,
    ` * //   data: {`,
    ` * //     path: '/path/to/images/image.webp',`,
    ` * //     dir: '/path/to/images',`,
    ` * //     name: 'image.webp',`,
    ` * //     ext: 'webp',`,
    ` * //     size: 1024,`,
    ` * //     etag: '...',`,
    ` * //   },`,
    ` * // }`,
    ` * \`\`\``,
    ` */`,
    `export async function moveFile(from: string, to: string): Promise<MoveResult> {`,
    `  return _storage.move(from, to)`,
    `}`,
    ``,
    `/**`,
    ` * Deletes a file from the storage system.`,
    ` *`,
    ` * Returns an object with a \`success\` property indicating whether the operation was successful.`,
    ` *`,
    ` * @example`,
    ` * \`\`\`ts`,
    ` * await deleteFile('/path/to/image.webp')`,
    ` * // { success: true }`,
    ` * \`\`\``,
    ` */`,
    `export async function deleteFile(path: string): Promise<DeleteResult> {`,
    `  return _storage.delete(path)`,
    `}`,
    ``,
    `/**`,
    ` * Retrieves metadata about a file from the storage system.`,
    ` *`,
    ` * Returns a \`Result\` object with a \`success\` property indicating whether the operation was successful.`,
    ` *`,
    ` * - If successful, the \`data\` property contains the metadata.`,
    ` * - If unsuccessful, the \`error\` property contains the error message.`,
    ` *`,
    ` * @example`,
    ` * \`\`\`ts`,
    ` * const meta = await getFileMeta('/path/to/image.webp')`,
    ` * // {`,
    ` * //   success: true,`,
    ` * //   data: {`,
    ` * //     size: 1024,`,
    ` * //     etag: '...',`,
    ` * //   },`,
    ` * // }`,
    ` * \`\`\``,
    ` */`,
    `export async function getFileMeta(path: string): Promise<MetaResult> {`,
    `  return _storage.meta(path)`,
    `}`,
    ``,
    `/**`,
    ` * Initializes the storage manager.`,
    ` */`,
    `export function initStorage() {`,
    `  if (!_storage) {`,
    `    const runtimeConfig = useRuntimeConfig()`,
    `    _storage = new Storage({ driver: runtimeConfig.pruvious.uploads.driver })`,
    `  }`,
    `}`,
    ``,
    `/**`,
    ` * The \`I18n\` instance containing all translatable strings in the CMS.`,
    ` */`,
    `export const i18n = new I18n()`,
    ...Object.entries(translationFiles).flatMap(([domain, languages]) =>
      Object.entries(languages).flatMap(([language, paths]) => [
        `  .defineTranslatableStrings({`,
        `    domain: '${domain}',`,
        `    language: '${language}',`,
        `    strings: { ${paths.map((_, i) => `..._${camelCase(domain)}${pascalCase(language)}Translation${i || ''}`).join(', ')} },`,
        `  })`,
      ]),
    ),
    `  .setFallbackLanguages([${pruviousOptions.i18n.fallbackLanguages.map((lang) => `'${lang}'`).join(', ')}])`,
    ``,
    `/**`,
    ` * Retrieves a translated string for a given \`domain\` and \`handle\`, with optional \`input\` parameters.`,
    ` * The language is automatically resolved from the current event context.`,
    ` *`,
    ` * @example`,
    ` * \`\`\`ts`,
    ` * import { __ } from '#pruvious/server'`,
    ` *`,
    ` * export default defineEventHandler((event) => {`,
    ` *   return __('default', 'Hello, $name!', { name: getQuery(event).name || 'Stranger' })`,
    ` * })`,
    ` * \`\`\``,
    ` */`,
    `export function __<TDomain extends ExtractDomains<ExtractTranslatableStringsDefinitions<typeof i18n>>, THandle extends ExtractHandlesByDomainAndLanguage<TDomain, string, ExtractTranslatableStringsDefinitions<typeof i18n>>, TInput extends ExtractInput<TDomain, string, THandle & string, ExtractTranslatableStringsDefinitions<typeof i18n>>>(domain: TDomain, handle: THandle, input?: TInput): string { return i18n.__$(domain, useEvent().context.pruvious.language, handle as any, input) }`,
    ``,
    `/**`,
    ` * A shorthand method for retrieving translated strings from the \`default\` domain.`,
    ` * This method is equivalent to calling \`__\` with \`default\` as the domain.`,
    ` * The language is automatically resolved from the current event context.`,
    ` *`,
    ` * @example`,
    ` * \`\`\`ts`,
    ` * import { _ } from '#pruvious/server'`,
    ` *`,
    ` * export default defineEventHandler((event) => {`,
    ` *   return _('Hello, $name!', { name: getQuery(event).name || 'Stranger' })`,
    ` * })`,
    ` * \`\`\``,
    ` */`,
    `export function _<THandle extends ExtractHandlesByDomainAndLanguage<'default', string, ExtractTranslatableStringsDefinitions<typeof i18n>>, TInput extends ExtractInput<'default', string, THandle & string, ExtractTranslatableStringsDefinitions<typeof i18n>>>(handle: THandle, input?: TInput): string { return i18n.__$('default', useEvent().context.pruvious.language, handle as any, input) }`,
    ...simpleValidatorsMeta.flatMap(({ name, comment, exampleField }) => [
      ``,
      `import { ${name}Validator as _${name}Validator } from '@pruvious/orm'`,
      ``,
      `/**`,
      ...comment.map((line) => ` * ${line}`),
      ` *`,
      ` * @example`,
      ` * \`\`\`ts`,
      ` * import { defineCollection, ${exampleField}, ${name}Validator } from '#pruvious/server'`,
      ` *`,
      ` * export default defineCollection({`,
      ` *   fields: {`,
      ` *     foo: ${exampleField}({`,
      ` *       validators: [${name}Validator()],`,
      ` *     }),`,
      ` *   },`,
      ` * })`,
      ` * \`\`\``,
      ` */`,
      `export const ${name}Validator = _${name}Validator<GenericDatabase>`,
    ]),
    ``,
    `import { uniqueValidator as _uniqueValidator, type UniqueValidatorOptions } from '@pruvious/orm'`,
    ``,
    `/**`,
    ...validatorsMeta.find(({ name }) => name === 'unique')!.comment.map((line) => ` * ${line}`),
    ` *`,
    ` * @example`,
    ` * \`\`\`ts`,
    ` * import { defineCollection, textField, repeaterField, uniqueValidator } from '#pruvious/server'`,
    ` *`,
    ` * export default defineCollection({`,
    ` *   fields: {`,
    ` *     sku: textField({`,
    ` *       required: true,`,
    ` *       validators: [uniqueValidator()],`,
    ` *     }),`,
    ` *     variants: repeaterField({`,
    ` *       subfields: {`,
    ` *         name: textField({`,
    ` *           required: true,`,
    ` *           validators: [uniqueValidator()],`,
    ` *         }),`,
    ` *       },`,
    ` *     }),`,
    ` *   },`,
    ` * })`,
    ` * \`\`\``,
    ` */`,
    `export function uniqueValidator<TCollection extends GenericCollection, TField extends string = TCollection['TColumnNames']>(options?: UniqueValidatorOptions<TField, GenericDatabase> & {`,
    `  /**`,
    `   * Controls if uniqueness is enforced per language (translation set).`,
    `   * This option only applies to translatable collections.`,
    `   *`,
    `   * - When \`true\`: Value only needs to be unique within each language.`,
    `   * - When \`false\`: Value must be unique across all languages in the collection.`,
    `   *`,
    `   * @default false`,
    `   */`,
    `  perLanguage?: boolean,`,
    `}): GenericValidator {`,
    `  return (value, sanitizedContextField, errors) => options?.perLanguage && sanitizedContextField.context.collection?.meta.translatable && !sanitizedContextField.isSubfield ? _uniqueValidator({ ...options, fields: [sanitizedContextField.path, 'language'] })(value, sanitizedContextField, errors) : _uniqueValidator(options)(value, sanitizedContextField, errors)`,
    `}`,
    ``,
    getReExports(),
  ].join('\n')
}

/**
 * Generates the `#pruvious/server` type file content.
 */
function getServerTypeFileContent() {
  const nuxt = useNuxt()
  const pruviousOptions = nuxt.options.runtimeConfig.pruvious

  debug(`Generating <${relative(nuxt.options.workspaceDir, pruviousOptions.dir.build)}/server/index.d.ts>`)

  const fieldDefinitionFiles = resolveFieldDefinitionFiles()
  const fieldDefinitionEntries = Object.entries(fieldDefinitionFiles)

  return [
    `export type PruviousContext = any`,
    `export type Permission = any`,
    `export type LanguageCode = any`,
    `export type PrimaryLanguageCode = any`,
    `export type DashboardLanguageCode = any`,
    `export type GenericDatabase = any`,
    `export type MainDatabase = any`,
    `export type CacheDatabase = any`,
    `export type QueueDatabase = any`,
    `export type LogsDatabase = any`,
    `export type Collections = any`,
    `export type Templates = any`,
    `export type Singletons = any`,
    `export type Jobs = any`,
    `export type IconName = any`,
    `export const permissions: any`,
    `export const languages: any`,
    `export const primaryLanguage: any`,
    `export const dashboardLanguages: any`,
    `export const collections: any`,
    `export const singletons: any`,
    `export const jobs: any`,
    `export const iconNames: any`,
    `export function getTemplate(): any`,
    `export function database(): any`,
    `export function queryBuilder(): any`,
    `export function guardedQueryBuilder(): any`,
    `export function insertInto(): any`,
    `export function guardedInsertInto(): any`,
    `export function selectFrom(): any`,
    `export function guardedSelectFrom(): any`,
    `export function update(): any`,
    `export function guardedUpdate(): any`,
    `export function deleteFrom(): any`,
    `export function guardedDeleteFrom(): any`,
    `export function getCacheDatabase(): any`,
    `export function getQueueDatabase(): any`,
    `export function getLogsDatabase(): any`,
    `export function initAllDatabases(): any`,
    `export function initMainDatabase(): any`,
    `export function initCacheDatabase(): any`,
    `export function initQueueDatabase(): any`,
    `export function initLogsDatabase(): any`,
    `export function getRouteReferences(): any`,
    `export function loadJobs(): any`,
    `export function storage(): any`,
    `export function putFile(): any`,
    `export function getFile(): any`,
    `export function streamFile(): any`,
    `export function deleteFile(): any`,
    `export function getFileMeta(): any`,
    `export function initStorage(): any`,
    `export const i18n: any`,
    `export function __(): any`,
    `export function _(): any`,
    ...validatorsMeta.map(({ name }) => `export function ${name}Validator(): any`),
    getReExports(),
  ].join('\n')
}

function getReExports() {
  const { resolve } = createResolver(import.meta.url)
  const fieldDefinitionFiles = resolveFieldDefinitionFiles()
  const fieldDefinitionEntries = Object.entries(fieldDefinitionFiles)

  return [
    `export { defineCollection, defineCollectionFromTemplate, type DefineCollectionOptions, type CollectionMetaOptions, type CollectionGuard, type CollectionRoutingOptions, type CollectionUIOptions, type CollectionMeta, type GenericMetaCollection, type MetaContext } from '${resolve('../collections/define')}'`,
    `export { collectionGuards } from '${resolve('../collections/guards')}'`,
    `export { removeWhere, denyWhere, removeOrderBy, denyOrderBy, removeGroupBy, denyGroupBy, excludeFields, maskFields, resetFields } from '${resolve('../collections/hooks')}'`,
    `export { getCollectionBySlug, getCollectionFromEvent, getSanitizedInput, patchSanitizedInput } from '${resolve('../collections/utils.server')}'`,
    `export { type GenericRouteReference, type GenericRouteData, type ResolvedRouteSEO, type ResolvedRoute, type RouteRedirect, resolveRoute, normalizeRoutePath } from '${resolve('../routes/utils.server')}'`,
    `export { resolvePath } from '${resolve('../routes/utils.shared')}'`,
    `export type { SerializableCollection } from '${resolve('../collections/utils.client')}'`,
    `export { defineSingleton, type SingletonUIOptions, type Singleton, type GenericSingleton, type DefineSingletonOptions, type SingletonContext, type SingletonHooks, type SingletonGuard, type SingletonRoutingOptions } from '${resolve('../singletons/define')}'`,
    `export { singletonGuards } from '${resolve('../singletons/guards')}'`,
    `export { selectSingleton, guardedSelectSingleton, updateSingleton, guardedUpdateSingleton, getSingletonBySlug, getSingletonFromEvent } from '${resolve('../singletons/utils.server')}'`,
    `export type { SerializableSingleton } from '${resolve('../singletons/utils.client')}'`,
    `export { SingletonSelectQueryBuilder } from '${resolve('../singletons/SingletonSelectQueryBuilder')}'`,
    `export { SingletonUpdateQueryBuilder } from '${resolve('../singletons/SingletonUpdateQueryBuilder')}'`,
    `export { defineField, type DefineFieldOptions, type PickFieldUIOptions, type FieldUIOptions, type GenericFieldUIOptions, type ResolveFieldUIOptions, type CombinedFieldOptions, type FieldGuard } from '${resolve('../fields/define')}'`,
    `export { transformFieldGuardsToValidators } from '${resolve('../fields/guards')}'`,
    `export { type LanguageFieldPresetOptions, type TranslationsFieldPresetOptions, type CreatedAtFieldPresetOptions, type UpdatedAtFieldPresetOptions, type AuthorFieldPresetOptions, type EditorsFieldPresetOptions, type SubpathFieldPresetOptions, type IsPublicFieldPresetOptions, type ScheduledAtFieldPresetOptions, type SEOFieldPresetOptions, languageFieldPreset, translationsFieldPreset, createdAtFieldPreset, updatedAtFieldPreset, authorFieldPreset, editorsFieldPreset, subpathFieldPreset, isPublicFieldPreset, scheduledAtFieldPreset, seoFieldPreset } from '${resolve('../fields/presets')}'`,
    `export { type FieldsLayout, type FieldsLayoutRow, type FieldsLayoutCard, type FieldsLayoutTabs, type FieldsLayoutTab, type FieldsLayoutItem, type FieldsLayoutFieldItem, type FieldsLayoutComponentItem, type FieldsLayoutHR, walkFieldLayoutItems } from '${resolve('../fields/layout')}'`,
    `export { type GenericFieldDefinition, type SerializableFieldOptions, type GenericSerializableFieldOptions, limitPopulation, parseConditionalLogic, parseFields } from '${resolve('../fields/utils.server')}'`,
    `export type { ButtonGroupChoice } from '${resolve('../../../server/fields/buttonGroup.ts')}'`,
    `export type { SelectChoice, SelectChoiceGroup } from '${resolve('../../../server/fields/select.ts')}'`,
    `export { defineTemplate } from '${resolve('../templates/define')}'`,
    `export { defineTranslation } from '${resolve('../translations/define')}'`,
    `export { type TranslatableStringCallbackContext, type TranslatableStringCallback, createPattern, resolveContextLanguage, isValidLanguageCode } from '${resolve('../translations/utils.server')}'`,
    `export { serializeTranslatableStringCallbacks } from '${resolve('../translations/utils.shared')}'`,
    `export { type ImageTransformOptions, stringifyImageTransformOptions, parseImageTransformOptions, normalizeImageTransformOptions, validateImageTransformOptions, optimizeImage, generateOptimizedImagePath } from '${resolve('../uploads/images')}'`,
    `export { type MediaCategory, type PutUploadOptions, type MoveUploadOptions, type UpdateUploadOptions, type DeleteUploadOptions, type CreateMultipartUploadOptions, type ResumeMultipartUploadOptions, type GetMultipartUploadOptions, type CompleteMultipartUploadOptions, type AbortMultipartUploadOptions, type PutUploadResult, type MoveUploadResult, type DeleteUploadResult, type CreateMultipartUploadResult, type ResumeMultipartUploadResult, type GetMultipartUploadResult, type CompleteMultipartUploadResult, type AbortMultipartUploadResult, mediaCategories, prepareUploadsInput, resolveMediaCategory, putUpload, moveUpload, updateUpload, deleteUpload, createMultipartUpload, getMultipartUpload, resumeMultipartUpload, completeMultipartUpload, abortMultipartUpload, registerOptimizedImage, deregisterOptimizedImage, queueImageOptimization } from '${resolve('../uploads/utils.server')}'`,
    `export { type InputValidator, httpStatusCodeMessages, crudToDatabaseOperation, databaseOperationToCrud, pruviousError, parseBody, assertInput, assertParams, assertQuery, assertUser, assertUserPermissions, parseRangeHeader } from '${resolve('../api/utils.server')}'`,
    `export { signToken, verifyToken, invalidateToken, isInvalidatedToken, setTokenCookies, removeTokenCookies, getToken, getTokenFromCookies, getTokenFromAuthorizationHeader, hashPassword, verifyPassword, resolveCurrentUser, isLoggedIn, getUser, hasPermission, hasCollectionPermission, hasSingletonPermission } from '${resolve('../auth/utils.server')}'`,
    `export { setCache, appendCache, getCache, getCacheKeys, hasCache, deleteCache, clearCache, removeExpiredCacheEntries } from '${resolve('../cache/utils.server')}'`,
    `export { type QueuedJob } from '${resolve('../queue/collection')}'`,
    `export { type DefineJobOptions, type Job, defineJob, defineJobHandler } from '${resolve('../queue/define')}'`,
    `export { type JobResult, queueJob, queueUniqueJob, getQueue, getJob, processQueue, triggerQueueProcessing, processJob, processNextJob, clearQueue, deleteJob } from '${resolve('../queue/utils.server')}'`,
    `export { defineAction, defineFilter } from '${resolve('../hooks/define.server')}'`,
    `export { addAction, doActions, addFilter, applyFilters } from '${resolve('../hooks/utils.server')}'`,
    `export type { PruviousState, PruviousDashboardState } from '${resolve('../pruvious/utils.client')}'`,
    `export { type CustomLogOptions, insertCustomLog } from '${resolve('../debug/utils.server')}'`,
    `export { type ResolveCustomComponentPathOptions, resolvePruviousComponent, resolveNamedPruviousComponent, resolveCustomComponentPath } from '${resolve('../components/utils.server')}'`,
    `export { type Block, type GenericBlock, type DefineBlockOptions } from '${resolve('../blocks/define.server')}'`,
    `export type { SerializableBlock } from '${resolve('../blocks/utils.client')}'`,
    `export type { BlockGroupDefinition, BlockTagDefinition } from '${resolve('../blocks/utils.server')}'`,
    `export { type Actions, type Filters, actions, filters, loadActions, loadFilters } from './hooks'`,
    `export { type BlockName, type Blocks, blocks, getBlockGroups, getBlockTags } from './blocks'`,
    `export { type Fields, type FieldOptions${fieldDefinitionEntries.map(([name]) => `, ${camelCase(name)}Field`).join('')} } from './fields'`,
  ].join('\n')
}

function getIconNames() {
  const nuxt = useNuxt()
  const iconNames: string[] = []

  for (const layer of nuxt.options._layers) {
    if (isArray(layer.config.icon?.customCollections)) {
      for (const { dir, prefix } of layer.config.icon.customCollections) {
        try {
          const files = fs.readdirSync(resolve(layer.config.rootDir, dir))
          iconNames.push(...files.map((file) => `${prefix}:${basename(file, extname(file))}`))
        } catch {}
      }
    }
  }

  return iconNames
}

/**
 * Generates additional content to append to the `#pruvious/server` file.
 */
function getServerFileContentPatch() {
  const nuxt = useNuxt()
  const pruviousOptions = nuxt.options.runtimeConfig.pruvious
  const dynamicContainerTypesPath = `${pruviousOptions.dir.build}/server/dynamic-container-types.ts`
  const dynamicBlockTypesPath = `${pruviousOptions.dir.build}/server/dynamic-block-types.ts`
  const dynamicRouteTypesPath = `${pruviousOptions.dir.build}/server/dynamic-route-types.ts`
  const content: string[] = []
  const { resolve } = createResolver(import.meta.url)

  fs.writeFileSync(
    dynamicContainerTypesPath,
    [
      `import type { Collections, Singletons } from '.'`,
      ``,
      `type CollectionName = keyof Collections & string`,
      `type SingletonName = keyof Singletons & string`,
      ``,
      `export type CollectionAPI = {`,
      `  any: { create: CollectionName, read: CollectionName, update: CollectionName, delete: CollectionName }`,
      `  public: { create: CollectionName, read: CollectionName, update: CollectionName, delete: CollectionName }`,
      `  private: { create: CollectionName, read: CollectionName, update: CollectionName, delete: CollectionName }`,
      `}`,
      `export type SingletonAPI = {`,
      `  any: { read: SingletonName, update: SingletonName }`,
      `  public: { read: SingletonName, update: SingletonName }`,
      `  private: { read: SingletonName, update: SingletonName }`,
      `}`,
      `export type DynamicCollectionFieldTypes = any`,
    ].join('\n'),
  )
  fs.writeFileSync(
    dynamicBlockTypesPath,
    [
      `export type DynamicBlockFieldTypes = any`,
      `export type BlockGroupName = any`,
      `export type BlockTagName = any`,
    ].join('\n'),
  )
  fs.writeFileSync(
    dynamicRouteTypesPath,
    [
      `import type { GenericRouteReference } from '.'`,
      ``,
      `export type RouteReferences = Record<string, GenericRouteReference>`,
      `export type RouteCollectionReferenceName = any`,
      `export type RouteSingletonReferenceName = any`,
      `export type RouteReferenceName = keyof RouteReferences`,
      `export type RouteCastedData = any`,
      `export type RoutePopulatedData = any`,
    ].join('\n'),
  )

  if (process.env.NODE_ENV === 'dev' || process.env.NODE_ENV === 'development') {
    content.push(
      ``,
      `import fs from 'node:fs'`,
      `import { filters, loadFilters } from './hooks'`,
      `import { blocks } from './blocks'`,
      `import type { BlockGroupDefinition, BlockTagDefinition } from '${resolve('../blocks/utils.server')}'`,
      ``,
      `async function generateDynamicCollectionFieldTypes() {`,
      `  await loadCollections()`,
      `  await loadSingletons()`,
      ``,
      `  const content = [`,
      "    `import type { BlockName } from './blocks'`,",
      "    `import type { DynamicBlockFieldTypes } from './dynamic-block-types'`,",
      '    ``,',
      '    `export interface CollectionAPI {`,',
      '    `  any: {`,',
      "    '    create: ' + (Object.entries(collections).filter(([_, { meta }]) => meta.api.create).map(([name]) => `'${name}'`).join(' | ') || 'never'),",
      "    '    read: ' + (Object.entries(collections).filter(([_, { meta }]) => meta.api.read).map(([name]) => `'${name}'`).join(' | ') || 'never'),",
      "    '    update: ' + (Object.entries(collections).filter(([_, { meta }]) => meta.api.update).map(([name]) => `'${name}'`).join(' | ') || 'never'),",
      "    '    delete: ' + (Object.entries(collections).filter(([_, { meta }]) => meta.api.delete).map(([name]) => `'${name}'`).join(' | ') || 'never'),",
      '    `  },`,',
      '    `  public: {`,',
      "    '    create: ' + (Object.entries(collections).filter(([_, { meta }]) => meta.api.create && !meta.authGuard.includes('create')).map(([name]) => `'${name}'`).join(' | ') || 'never'),",
      "    '    read: ' + (Object.entries(collections).filter(([_, { meta }]) => meta.api.read && !meta.authGuard.includes('read')).map(([name]) => `'${name}'`).join(' | ') || 'never'),",
      "    '    update: ' + (Object.entries(collections).filter(([_, { meta }]) => meta.api.update && !meta.authGuard.includes('update')).map(([name]) => `'${name}'`).join(' | ') || 'never'),",
      "    '    delete: ' + (Object.entries(collections).filter(([_, { meta }]) => meta.api.delete && !meta.authGuard.includes('delete')).map(([name]) => `'${name}'`).join(' | ') || 'never'),",
      '    `  },`,',
      '    `  private: {`,',
      "    '    create: ' + (Object.entries(collections).filter(([_, { meta }]) => meta.api.create && meta.authGuard.includes('create')).map(([name]) => `'${name}'`).join(' | ') || 'never'),",
      "    '    read: ' + (Object.entries(collections).filter(([_, { meta }]) => meta.api.read && meta.authGuard.includes('read')).map(([name]) => `'${name}'`).join(' | ') || 'never'),",
      "    '    update: ' + (Object.entries(collections).filter(([_, { meta }]) => meta.api.update && meta.authGuard.includes('update')).map(([name]) => `'${name}'`).join(' | ') || 'never'),",
      "    '    delete: ' + (Object.entries(collections).filter(([_, { meta }]) => meta.api.delete && meta.authGuard.includes('delete')).map(([name]) => `'${name}'`).join(' | ') || 'never'),",
      '    `  }`,',
      '    `}`,',
      '    ``,',
      '    `export interface SingletonAPI {`,',
      '    `  any: {`,',
      "    '    read: ' + (Object.entries(singletons).filter(([_, singleton]) => singleton.api.read).map(([name]) => `'${name}'`).join(' | ') || 'never'),",
      "    '    update: ' + (Object.entries(singletons).filter(([_, singleton]) => singleton.api.update).map(([name]) => `'${name}'`).join(' | ') || 'never'),",
      '    `  },`,',
      '    `  public: {`,',
      "    '    read: ' + (Object.entries(singletons).filter(([_, singleton]) => singleton.api.read && !singleton.authGuard.includes('read')).map(([name]) => `'${name}'`).join(' | ') || 'never'),",
      "    '    update: ' + (Object.entries(singletons).filter(([_, singleton]) => singleton.api.update && !singleton.authGuard.includes('update')).map(([name]) => `'${name}'`).join(' | ') || 'never'),",
      '    `  },`,',
      '    `  private: {`,',
      "    '    read: ' + (Object.entries(singletons).filter(([_, singleton]) => singleton.api.read && singleton.authGuard.includes('read')).map(([name]) => `'${name}'`).join(' | ') || 'never'),",
      "    '    update: ' + (Object.entries(singletons).filter(([_, singleton]) => singleton.api.update && singleton.authGuard.includes('update')).map(([name]) => `'${name}'`).join(' | ') || 'never'),",
      '    `  }`,',
      '    `}`,',
      '    ``,',
      '    `export interface DynamicCollectionFieldTypes {`,',
      '    `  Serialized: {`,',
      '    ...Object.entries(collections).map(([name, collection]) => [',
      '    `    ${name}: {`,',
      '    `      id: number`,',
      '    ...Object.entries(collection.fields).map(([fieldName, field]) => [',
      "    `      ${fieldName}: ${field.model.dataType === 'text' ? 'string' : field.model.dataType === 'boolean' ? 'boolean' : 'number'},`,",
      '    ]).flat(),',
      '    `    },`',
      '    ]).flat(),',
      '    `  },`,',
      '    `  Casted: {`,',
      '    ...Object.entries(collections).map(([name, collection]) => [',
      '    `    ${name}: {`,',
      '    `      id: number`,',
      '    ...Object.entries(collection.fields).map(([fieldName, field]) => [',
      '    `      ${fieldName}: ${field.castedTypeFn({ field, collections, blocks })},`,',
      '    ]).flat(),',
      '    `    },`',
      '    ]).flat(),',
      '    `  },`,',
      '    `  Populated: {`,',
      '    ...Object.entries(collections).map(([name, collection]) => [',
      '    `    ${name}: {`,',
      '    `      id: number`,',
      '    ...Object.entries(collection.fields).map(([fieldName, field]) => [',
      '    `      ${fieldName}: ${field.populatedTypeFn({ field, collections, blocks })},`,',
      '    ]).flat(),',
      '    `    },`',
      '    ]).flat(),',
      '    `  },`,',
      '    `}`,',
      '    ``,',
      `  ]`,
      ``,
      `  fs.writeFileSync('${dynamicContainerTypesPath}', content.join('\\n'))`,
      `}`,
      ``,
      `generateDynamicCollectionFieldTypes()`,
      ``,
      `export type { CollectionAPI, SingletonAPI, DynamicCollectionFieldTypes } from './dynamic-container-types'`,
      ``,
      `async function generateDynamicBlockTypes() {`,
      `  await loadFilters()`,
      ``,
      `  const blockGroupNames: BlockGroupDefinition[] = (await filters['blocks:groups']?.reduce(async (acc, { callback }) => callback(await acc, {}), Promise.resolve([]))) ?? []`,
      `  const blockTagNames: BlockTagDefinition[] = (await filters['blocks:tags']?.reduce(async (acc, { callback }) => callback(await acc, {}), Promise.resolve([]))) ?? []`,
      ``,
      `  const content = [`,
      "    `import type { Booleanish } from '@pruvious/utils'`,",
      "    `import type { BlockName } from './blocks'`,",
      "    `import type { DynamicCollectionFieldTypes } from './dynamic-container-types'`,",
      '    ``,',
      '    `export interface DynamicBlockFieldTypes {`,',
      '    `  Casted: {`,',
      '    ...Object.entries(blocks).map(([name, block]) => [',
      '    `    ${name}: {`,',
      "    `      $key: '${name}'`,",
      '    ...Object.entries(block.fields).map(([fieldName, field]) => [',
      '    `      ${fieldName}: ${field.castedTypeFn({ field, collections, blocks })},`,',
      '    ]).flat(),',
      '    `    },`',
      '    ]).flat(),',
      '    `  },`,',
      '    `  Populated: {`,',
      '    ...Object.entries(blocks).map(([name, block]) => [',
      '    `    ${name}: {`,',
      "    `      $key: '${name}'`,",
      '    ...Object.entries(block.fields).map(([fieldName, field]) => [',
      '    `      ${fieldName}: ${field.populatedTypeFn({ field, collections, blocks })},`,',
      '    ]).flat(),',
      '    `    },`',
      '    ]).flat(),',
      '    `  },`,',
      '    `  Input: {`,',
      '    ...Object.entries(blocks).map(([name, block]) => [',
      '    `    ${name}: {`,',
      "    `      $key: '${name}'`,",
      '    ...Object.entries(block.fields).filter(([_, field]) => !field.autoGenerated).map(([fieldName, field]) => [',
      "    `      ${fieldName}${!field.required || field.conditionalLogic ? '?' : ''}: ${field.inputTypeFn({ field, collections, blocks })},`,",
      '    ]).flat(),',
      '    `    },`',
      '    ]).flat(),',
      '    `  },`,',
      '    `}`,',
      '    ``,',
      '    `/**`,',
      '    ` * Type representing all registered block group names.`,',
      '    ` */`,',
      "    `export type BlockGroupName = ${blockGroupNames.map(({ name }) => `'${name}'`).join(' | ') || 'never'}`,",
      '    ``,',
      '    `/**`,',
      '    ` * Type representing all registered block tag names.`,',
      '    ` */`,',
      "    `export type BlockTagName = ${blockTagNames.map(({ name }) => `'${name}'`).join(' | ') || 'never'}`,",
      '    ``,',
      `  ]`,
      ``,
      `  fs.writeFileSync('${dynamicBlockTypesPath}', content.join('\\n'))`,
      `}`,
      ``,
      `generateDynamicBlockTypes()`,
      ``,
      `export type { DynamicBlockFieldTypes, BlockGroupName, BlockTagName } from './dynamic-block-types'`,
      ``,
      `async function generateDynamicRouteTypes() {`,
      `  await loadCollections()`,
      ``,
      `  const routeReferences = await getRouteReferences()`,
      `  const routeCollectionReferenceNames = Object.entries(routeReferences).filter(([_, { dataContainerType }]) => dataContainerType === 'collection').map(([name]) => name)`,
      `  const routeSingletonReferenceNames = Object.entries(routeReferences).filter(([_, { dataContainerType }]) => dataContainerType === 'singleton').map(([name]) => name)`,
      `  const routeReferenceNames = Object.entries(routeReferences).map(([name]) => name)`,
      ``,
      `  const content = [`,
      "    `import type { Collections, GenericRouteData, GenericRouteReference, Singletons } from '.'`,",
      "    `import type { DynamicCollectionFieldTypes } from './dynamic-container-types'`,",
      "    `import type { ExtractCastedTypes, ExtractPopulatedTypes, GenericField } from '@pruvious/orm'`,",
      '    ``,',
      '    `/**`,',
      '    ` * Type representing all route references in the CMS.`,',
      '    ` */`,',
      '    `export interface RouteReferences extends Record<string, GenericRouteReference> {`,',
      '    ...Object.entries(routeReferences).flatMap(([name, { publicFields, dataContainerType, dataContainerName }]) => [',
      "    `  '${name}': {`,",
      "    `    dataContainerType: '${dataContainerType}'`,",
      "    `    dataContainerName: '${dataContainerName}'`,",
      '    `    publicFields: {`,',
      '    ...Object.entries(publicFields).flatMap(([fieldName]) => [',
      "    `      ${fieldName}: ` + (dataContainerType === 'collection' && fieldName === 'id' ? 'GenericField' : `${capitalize(dataContainerType)}s['${dataContainerName}']['fields']['${fieldName}']`),",
      '    ]),',
      '    `    }`,',
      '    `  }`,',
      '    ]),',
      '    `}`,',
      '    ``,',
      '    `/**`,',
      '    ` * Type representing collection names that can be referenced in routes.`,',
      '    ` */`,',
      "    `export type RouteCollectionReferenceName = ${routeCollectionReferenceNames.length ? routeCollectionReferenceNames.map(name => `'${name}'`).join(' | ') : 'never'}`,",
      '    ``,',
      '    `/**`,',
      '    ` * Type representing singleton names that can be referenced in routes.`,',
      '    ` */`,',
      "    `export type RouteSingletonReferenceName = ${routeSingletonReferenceNames.length ? routeSingletonReferenceNames.map(name => `'${name}'`).join(' | ') : 'never'}`,",
      '    ``,',
      '    `/**`,',
      '    ` * Type representing all route reference names.`,',
      '    ` */`,',
      "    `export type RouteReferenceName = ${routeReferenceNames.length ? routeReferenceNames.map(name => `'${name}'`).join(' | ') : 'never'}`,",
      '    ...Object.entries(routeReferences).flatMap(([name, { dataContainerType, dataContainerName, publicFields }], i) => [',
      '    ``,',
      "    `interface RouteCastedData_${name.replace(':Singleton', '_Singleton')} extends GenericRouteData {`,",
      "    `  $ref: '${name}'`,",
      "    `  $data: Pick<ExtractCastedTypes<${dataContainerType === 'collection' ? 'Collections' : 'Singletons'}['${dataContainerName}']['fields']>, ${Object.entries(publicFields).filter(([fieldName]) => fieldName !== 'id').map(([fieldName]) => \`'${fieldName}'\`).join(' | ') || (isEmpty(publicFields) ? 'never' : '{}')}>` + (dataContainerType === 'collection' && publicFields.id ? ` & { id: number }` : ``),",
      '    `}`,',
      '    ]),',
      '    ...Object.entries(routeReferences).flatMap(([name, { dataContainerType, dataContainerName, publicFields }], i) => [',
      '    ``,',
      "    `interface RoutePopulatedData_${name.replace(':Singleton', '_Singleton')} extends GenericRouteData {`,",
      "    `  $ref: '${name}'`,",
      "    `  $data: Pick<ExtractPopulatedTypes<${dataContainerType === 'collection' ? 'Collections' : 'Singletons'}['${dataContainerName}']['fields']>, ${Object.entries(publicFields).filter(([fieldName]) => fieldName !== 'id').map(([fieldName]) => \`'${fieldName}'\`).join(' | ') || (isEmpty(publicFields) ? 'never' : '{}')}>` + (dataContainerType === 'collection' && publicFields.id ? ` & { id: number }` : ``),",
      '    `}`,',
      '    ]),',
      '    ``,',
      '    `/**`,',
      '    ` * Type representing the casted public field types of all route references in the CMS.`,',
      '    ` */`,',
      "    `export type RouteCastedData = ${Object.keys(routeReferences).length ? Object.entries(routeReferences).map(([name]) => \`RouteCastedData_${name.replace(':Singleton', '_Singleton')}\`).join(' | ') : 'never'}`,",
      '    ``,',
      '    `/**`,',
      '    ` * Type representing the populated public field types of all route references in the CMS.`,',
      '    ` */`,',
      "    `export type RoutePopulatedData = ${Object.keys(routeReferences).length ? Object.entries(routeReferences).map(([name]) => \`RoutePopulatedData_${name.replace(':Singleton', '_Singleton')}\`).join(' | ') : 'never'}`,",
      '    ``,',
      `  ]`,
      ``,
      `  fs.writeFileSync('${dynamicRouteTypesPath}', content.join('\\n'))`,
      `}`,
      ``,
      `generateDynamicRouteTypes()`,
      ``,
      `import type { RouteReferences } from './dynamic-route-types'`,
      `export type { RouteReferences, RouteCollectionReferenceName, RouteSingletonReferenceName, RouteReferenceName, RouteCastedData, RoutePopulatedData } from './dynamic-route-types'`,
    )
  } else {
    content.push(
      ``,
      `export type { CollectionAPI, SingletonAPI, DynamicCollectionFieldTypes } from './dynamic-container-types'`,
      `export type { DynamicBlockFieldTypes, BlockGroupName, BlockTagName } from './dynamic-block-types'`,
      `import type { RouteReferences } from './dynamic-route-types'`,
      `export type { RouteReferences, RouteCollectionReferenceName, RouteSingletonReferenceName, RouteReferenceName, RouteCastedData, RoutePopulatedData } from './dynamic-route-types'`,
    )
  }

  return content.join('\n')
}

/**
 * Generates additional content to append to the `#pruvious/server` type file.
 */
function getServerTypeFileContentPatch() {
  return [
    `export type DynamicCollectionFieldTypes = any`,
    `export type DynamicBlockTypes = any`,
    `export type RouteReferences = any`,
    `export type RouteCollectionReferenceName = any`,
    `export type RouteSingletonReferenceName = any`,
    `export type RouteReferenceName = any`,
    `export type RouteCastedData = any`,
    `export type RoutePopulatedData = any`,
  ].join('\n')
}

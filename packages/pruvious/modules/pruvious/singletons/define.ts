import {
  languages,
  walkFieldLayoutItems,
  type FieldsLayout,
  type GenericDatabase,
  type LanguageCode,
  type Singletons,
  type TranslatableStringCallbackContext,
} from '#pruvious/server'
import type { icons } from '@iconify-json/tabler/icons.json'
import type {
  ExtractAutoGeneratedFieldNames,
  ExtractCastedTypes,
  ExtractConditionalFieldNames,
  ExtractDataTypes,
  ExtractInputTypes,
  ExtractNullableFieldNames,
  ExtractPopulatedTypes,
  GenericField,
  QueryDetails,
  SanitizedUpdateContext,
  SelectContext,
  UpdateInput,
} from '@pruvious/orm'
import {
  camelCase,
  deepClone,
  defu,
  isDefined,
  isObject,
  isString,
  isUndefined,
  omit,
  setProperty,
  type DefaultFalse,
  type DefaultTrue,
  type PartialMax2Levels,
} from '@pruvious/utils'
import { colorize } from 'consola/utils'
import { hash } from 'ohash'
import { resolveCustomComponentPath } from '../components/utils.server'
import { warnWithContext } from '../debug/console'
import { updatedAtFieldPreset, type UpdatedAtFieldPresetOptions } from '../fields/presets'
import type { ResolveFromLayersResultContextBinding } from '../utils/resolve'
import { singletonPermissionGuard } from './guards'

interface ISingleton {
  /**
   * A key-value object of `Field` instances representing the structure of the singleton.
   *
   * - Object keys represent the field names.
   * - Object values are instances of the `Field` class.
   */
  fields: any

  /**
   * Specifies whether the singleton is translatable.
   *
   * If `true`, field values are stored separately in the database for each language specified
   * in the `pruvious.i18n.languages` option in `nuxt.config.ts`.
   */
  translatable: any

  /**
   * Specifies which fields should stay in sync across all translations of this singleton.
   * When you change a synced field in one translation, the same change happens automatically in all other translations.
   * This feature only works if the singleton is `translatable`.
   *
   * Important: Ensure that synced fields do not contain `conditionalLogic` or `dependencies` that require other fields in the input data.
   * Having such dependencies may cause the sync operation to fail.
   */
  syncedFields: any

  /**
   * Hooks are functions that execute at specific points in the query lifecycle for this singleton.
   *
   * Available hooks:
   *
   * - `beforeQueryPreparation` - Runs before the SQL query is generated from the current query builder context.
   * - `beforeQueryExecution` - Runs before the query is sent to the database.
   * - `afterQueryExecution` - Runs after the query is executed and before the result is returned from the singleton query builder.
   */
  hooks: any

  /**
   * API endpoint configuration for this singleton.
   * All endpoints are enabled by default and use guarded query builder functions.
   *
   * Standard REST API endpoints:
   *
   * - GET `/<pruvious.api.basePath>/singletons/{slug}`
   *   - Retrieves a singleton by its slugified name.
   * - GET `/<pruvious.api.basePath>/singletons/{slug}/copy-translation?targetLanguage`
   *   - Generates and retrieves a translated copy of the singleton for a specified target language.
   *   - Only available when the singleton is `translatable` and `copyTranslation` is enabled.
   * - PATCH `/<pruvious.api.basePath>/singletons/{slug}`
   *   - Updates a singleton by its slugified name.
   *
   * Additional POST endpoints:
   *
   * - POST `/<pruvious.api.basePath>/singletons/{slug}/validate`
   *   - Validates update data for a specific singleton without saving it to the database.
   *
   * The created endpoints are only accessible to users with `singleton:{slug}:{operation}` permissions.
   *
   * The dashboard will automatically enable/disable the corresponding UI elements based on these settings.
   *
   * You can provide a boolean value to enable/disable all endpoints.
   */
  api: any

  /**
   * An array of functions that control access to database records in this singleton.
   * These functions are only executed during CRUD operations when using the following utility functions from `#pruvious/server`:
   *
   * - `guardedSelectSingleton()`
   * - `guardedUpdateSingleton()`
   *
   * Every singleton guard function receives the parameter:
   *
   * - `context` - A `SingletonContext` instance related to the current query builder operation.
   *
   * The guard function does not require to return a value.
   * When it throws an error, the current query builder execution stops immediately.
   * It also sets the HTTP response status code to `401` or `403` by default.
   * The status code prefix will be stripped from the final error `message` in the response.
   *
   * ---
   *
   * A built-in authentication guard is enabled by default to manage user access through permissions for all singleton operations:
   *
   * - `singleton:{slug}:read` - Allows reading a singleton by its slugified name.
   * - `singleton:{slug}:update` - Allows updating a singleton by its slugified name.
   *
   * This guard only takes effect when the `authGuard` option is enabled.
   *
   * @see https://pruvious.com/docs/singletons/guards (@todo set up this link)
   */
  guards: any

  /**
   * Specifies which CRUD operations are protected by default.
   * When enabled, users must be authenticated and have the required permissions to perform operations on singletons:
   *
   * - `singleton:{slug}:read` - Permission to read a singleton by its slugified name.
   * - `singleton:{slug}:update` - Permission to modify a singleton by its slugified name.
   *
   * Accepts either:
   *
   * - `boolean` - Enable/disable guard for all operations.
   * - `('read' | 'update')[]` - Array of operation names to protect specifically.
   *
   * This protection is implemented as a singleton guard that automatically applies to all defined singletons.
   * It takes effect only when using these utility functions from `#pruvious/server`:
   *
   * - `guardedSelectSingleton()`
   * - `guardedUpdateSingleton()`
   */
  authGuard: any

  /**
   * A function that generates a copy of singleton data, enabling translation mapping between different language versions.
   * When specified, the API endpoint GET `<pruvious.api.basePath>/singletons/{slug}/copy-translation?targetLanguage`
   * is available to generate and retrieve a translated copy of the singleton for a specified target language.
   * The source language is determined by the standard `language` query parameter, which falls back to the default language if not provided.
   *
   * The function receives a single `context` parameter with the following properties:
   *
   * - `source` - Object containing field names and their casted values from the source translation.
   * - `sourceLanguage` - The language code of the source translation.
   * - `targetLanguage` - The language code of the target translation returned by this function.
   *
   * The function must return an object containing the input data used for updating the target translation.
   * Any fields marked as `autoGenerated` or `immutable` will be automatically excluded from the returned object.
   *
   * Set to `null` to disable translation copying (default behavior).
   *
   * Note: The singleton must be `translatable` for this function to have any effect.
   *
   * @default null
   */
  copyTranslation: any

  /**
   * Query logging configuration for this singleton.
   * Logged queries can be viewed in the Pruvious dashboard by admins and users with the `read-logs` permission.
   * Requires `pruvious.debug.logs.queries` to be enabled in `nuxt.config.ts`.
   */
  logs: any

  /**
   * Controls if the singleton includes an `updatedAt` timestamp field.
   * When the singleton is modified, this field automatically gets updated with the current timestamp.
   *
   * Available options:
   *
   * - `true` - Uses default field name and settings.
   * - `{...}` - Configures custom options for the field.
   * - `false` - Disables the field completely.
   */
  updatedAt: any

  /**
   * Controls how the singleton is displayed in the dashboard user interface.
   */
  ui: any
}

interface SingletonAPIOptions {
  /**
   * Enables/disables singleton retrieval via GET endpoint.
   * When enabled, the following endpoints are available:
   *
   * - GET `/<pruvious.api.basePath>/singletons/{slug}` - retrieves a singleton by its slugified name.
   * - GET `/<pruvious.api.basePath>/singletons/{slug}/copy-translation?targetLanguage` - generates and retrieves
   *   a translated copy of the singleton for a specified target language.
   *   - Only available when the singleton is `translatable` and `copyTranslation` is enabled.
   *
   * Available query parameters:
   *
   * - `select` - Fields to retrieve (e.g. `?select=logo,copyrightText`).
   * - `language` - The language code to retrieve the singleton content in (e.g. `?language=de`).
   *   - Only works if the singleton is `translatable`.
   * - `populate` - Determines if the query should run field populators and return populated field values (e.g. `?populate=true`).
   * - `targetLanguage` - The language code of the generated translation copy (e.g., `?targetLanguage=fr`).
   *   - Only available for the `copy-translation` endpoint.
   *
   * Only users with `singleton:{slug}:read` permission can access this endpoint.
   *
   * @see https://pruvious.com/docs/singletons/api#read (@todo set up this link)
   */
  read: boolean

  /**
   * Enables/disables singleton updates via PATCH endpoint.
   * When enabled, the following endpoints are available:
   *
   * - PATCH `/<pruvious.api.basePath>/singletons/{slug}` - updates a singleton by its slugified name.
   *   - The request body must be an object with the new field values.
   * - POST `/<pruvious.api.basePath>/singletons/{slug}/validate` - validates update data for a specific singleton without saving it to the database.
   *   - The request body must be an object with the new field values.
   *
   * Common query parameters:
   *
   * - `language` - The language code to update the singleton content in (e.g. `?language=de`).
   *   - Only works if the singleton is `translatable`.
   * - `returning` - Fields to return after the UPDATE operation (e.g. `?returning=logo,copyrightText`).
   * - `populate` - Determines if the query should run field populators and return populated field values (e.g. `?populate=true`).
   *
   * Only users with `singleton:{slug}:update` permission can access this endpoints.
   *
   * @see https://pruvious.com/docs/singletons/api#update (@todo set up this link)
   */
  update: boolean
}

type SingletonCopyTranslationFunction<
  TFields extends Record<string, GenericField>,
  TUpdateInput extends Record<string, any> = UpdateInput<{ fields: TFields }>,
> = (context: {
  /**
   * Object containing field names and their casted values from the source translation.
   */
  source: ExtractCastedTypes<TFields>

  /**
   * The language code of the source translation.
   */
  sourceLanguage: LanguageCode

  /**
   * The language code of the target translation returned by this function.
   */
  targetLanguage: LanguageCode
}) => TUpdateInput | Promise<TUpdateInput>

interface SingletonLogsOptions {
  /**
   * Controls whether to log queries executed on this singleton.
   */
  enabled: boolean

  /**
   * Determines whether sensitive query data should be visible in logs.
   *
   * - `true` - Log entries contain the actual query parameters and result values.
   * - `false` - Log entries only show data types instead of the real values for privacy.
   */
  exposeData: boolean

  /**
   * Specifies which database operations should be logged.
   *
   * Note: When updating a singleton, an "UPSERT" operation is performed internally.
   *       As a result, the `insert` operation will be logged during singleton updates.
   */
  operations: { insert: boolean; select: boolean }
}

export interface SingletonUIOptions<TFieldNames extends string = string> {
  /**
   * Controls if the singleton should be hidden in the admin dashboard.
   * When `true`, the singleton will not be visible in the navigation menu and its dashboard page becomes inaccessible.
   *
   * @default false
   */
  hidden?: boolean

  /**
   * Sets the visible label text for the singleton in the dashboard.
   *
   * If not specified, the singleton name will be automatically transformed to Title case and used as the label.
   * The resulting label is wrapped in the translation function `__('pruvious-dashboard', label)`.
   * This transformation happens in the Vue component.
   *
   * You can either provide a string or a function that returns a string.
   * The function receives an object with `_` and `__` properties to access the translation functions.
   *
   * Important: When using a function, only use simple anonymous functions without context binding,
   * since the option needs to be serialized for client-side use.
   *
   * @example
   * ```ts
   * // String (non-translatable)
   * label: 'Theme options'
   *
   * // Function (translatable)
   * label: ({ __ }) => __('pruvious-dashboard', 'Theme options')
   *
   * // Singleton name transformation (default)
   * // Example: the singleton name `ThemeOptions` is transformed into `__('pruvious-dashboard', 'Theme options')`
   * label: undefined
   * ```
   */
  label: string | ((context: TranslatableStringCallbackContext) => string) | undefined

  /**
   * The icon used to represent the singleton in the dashboard.
   * Must be a valid Tabler icon name.
   *
   * @see https://tabler-icons.io for available icons
   *
   * @default 'settings'
   */
  icon: keyof typeof icons

  /**
   * Options to customize how the singleton appears in the dashboard's navigation menu.
   *
   * For more advanced menu customization, use the client-side filters:
   *
   * - `dashboard:menu:general`
   * - `dashboard:menu:collections`
   * - `dashboard:menu:management`
   * - `dashboard:menu:utilities`
   *
   * @default
   * {
   *   hidden: false,
   *   group: 'general',
   *   order: 10,
   * }
   */
  menu: {
    /**
     * Controls whether the singleton should be hidden in the dashboard navigation menu.
     * Set to `true` to hide it, `false` to show it.
     *
     * @default false
     */
    hidden: boolean

    /**
     * Defines the menu category where the singleton will be displayed in the dashboard sidebar.
     *
     * @default 'general'
     */
    group: 'general' | 'collections' | 'management' | 'utilities'

    /**
     * Controls the singleton's position in the dashboard navigation menu.
     * Items with lower numbers appear at the top.
     * When items have the same order number, they are sorted by their label alphabetically.
     *
     * @default 10
     */
    order: number
  }

  /**
   * The dashboard layout configuration for this singleton.
   * Controls how the singleton content is displayed in the admin interface.
   *
   * When set to 'auto', the layout is determined based on block support:
   *
   * - With `blocksField({})`: Uses 'live-preview' layout
   * - Without `blocksField({})`: Uses 'standard' layout
   *
   * Available options:
   *
   * - `'auto'` - Automatic layout selection based on block support.
   * - `'standard'` - Standard dashboard layout with header and sidebar (`PruviousDashboardPage.vue`).
   * - `'live-preview'` - Split view with live preview (`PruviousDashboardLivePreview.vue`).
   * - `resolvePruviousComponent('>/components/MyComponent.vue')` - Custom Vue component.
   *   - The component must be resolved using `resolvePruviousComponent()` or `resolveNamedPruviousComponent()`.
   *   - The import path must be a literal string, not a variable.
   *   - The import path can be an absolute or relative to the definition file.
   *
   * The custom component receives the following props:
   *
   * - @todo
   *
   * The custom component can emit the following events:
   *
   * - @todo
   *
   * @default 'auto'
   */
  dashboardLayout: 'auto' | 'standard' | 'live-preview' | (string & {})

  /**
   * Customizes the layout of the collection's fields in the dashboard.
   *
   * If not specified, the fields are stacked vertically in the order they are defined.
   *
   * @default undefined
   *
   * @example
   * ```ts
   * [
   *   // Single field
   *   'email',
   *
   *   // Half-width field (max-width: 50%)
   *   'firstName | 50%',
   *
   *   // Auto-width field { width: 'auto', flexShrink: 0 }
   *   'middleName | auto',
   *
   *   // Field with custom component styles
   *   {
   *     field: {
   *       name: 'lastName',
   *       style: { maxWidth: '50%' },
   *     },
   *   },
   *
   *   // Field group (row)
   *   {
   *     row: [
   *       // Has maximum width of 8rem
   *       'countryCode | 8rem',
   *
   *       // Takes up the remaining space
   *       'phone',
   *     ],
   *   },
   *
   *   // Horizontal rule
   *   '---',
   *
   *   // Field group (tabs)
   *   {
   *     tabs: [
   *       {
   *         label: ({ __ }) => __('pruvious-dashboard', 'Address'),
   *         fields: ['street | 40%', 'city | 40%', 'zipCode'],
   *       },
   *       {
   *         label: ({ __ }) => __('pruvious-dashboard', 'Contact'),
   *         fields: [
   *           {
   *             // Custom Vue component
   *             // - The component must be resolved using `resolvePruviousComponent()`
   *             //   or `resolveNamedPruviousComponent()`.
   *             // - The import path must be a literal string, not a variable.
   *             // - The import path can be an absolute or relative to the definition file.
   *             component: resolvePruviousComponent('>/components/Dashboard/ContactForm.vue'),
   *           },
   *         ],
   *       },
   *     ],
   *   },
   *
   *   // Card group
   *   {
   *     card: ['comments', 'assignedTo'],
   *   },
   * ]
   * ```
   */
  fieldsLayout: FieldsLayout<TFieldNames> | undefined
}

export interface Singleton<
  TFields extends Record<string, GenericField>,
  TTranslatable extends boolean,
  TUpdatedAt extends boolean | UpdatedAtFieldPresetOptions | undefined,
> extends Readonly<ISingleton> {
  readonly fields: TFields
  readonly translatable: TTranslatable
  readonly syncedFields: (keyof MergeSingletonFields<TFields, TUpdatedAt> & string)[]
  readonly hooks: Required<SingletonHooks>
  readonly api: SingletonAPIOptions
  readonly guards: SingletonGuard[]
  readonly authGuard: ('read' | 'update')[]
  readonly copyTranslation: SingletonCopyTranslationFunction<MergeSingletonFields<TFields, TUpdatedAt>> | null
  readonly logs: SingletonLogsOptions
  readonly updatedAt: AutoFieldEnabled & UpdatedAtFieldPresetOptions
  readonly ui: SingletonUIOptions<keyof MergeSingletonFields<TFields, TUpdatedAt> & string>

  /**
   * Type with all field names.
   *
   * Note: This is a TypeScript type assertion and does not involve any runtime logic or data.
   */
  readonly TFieldNames: keyof MergeSingletonFields<TFields, TUpdatedAt>

  /**
   * Type with all field names and their respective data types.
   *
   * Note: This is a TypeScript type assertion and does not involve any runtime logic or data.
   */
  readonly TDataTypes: ExtractDataTypes<MergeSingletonFields<TFields, TUpdatedAt>>

  /**
   * Type with all field names and their respective TypeScript types after casting the values from the database.
   *
   * Note: This is a TypeScript type assertion and does not involve any runtime logic or data.
   */
  readonly TCastedTypes: ExtractCastedTypes<MergeSingletonFields<TFields, TUpdatedAt>>

  /**
   * Type with all field names and their respective TypeScript types after populating the values.
   *
   * Note: This is a TypeScript type assertion and does not involve any runtime logic or data.
   */
  readonly TPopulatedTypes: ExtractPopulatedTypes<MergeSingletonFields<TFields, TUpdatedAt>>

  /**
   * Type with all field names and their respective TypeScript types that can be used as input values.
   *
   * Note: This is a TypeScript type assertion and does not involve any runtime logic or data.
   */
  readonly TInputTypes: ExtractInputTypes<MergeSingletonFields<TFields, TUpdatedAt>>

  /**
   * Type with all field names where values are nullable (accept `null` values).
   *
   * Note: This is a TypeScript type assertion and does not involve any runtime logic or data.
   */
  readonly TNullableFields: ExtractNullableFieldNames<MergeSingletonFields<TFields, TUpdatedAt>>

  /**
   * Type with all field names that are auto-generated by the singleton.
   *
   * Note: This is a TypeScript type assertion and does not involve any runtime logic or data.
   */
  readonly TAutoGeneratedFields: ExtractAutoGeneratedFieldNames<MergeSingletonFields<TFields, TUpdatedAt>>

  /**
   * Type with all field names that use conditional logic.
   *
   * Note: This is a TypeScript type assertion and does not involve any runtime logic or data.
   */
  readonly TConditionalFields: ExtractConditionalFieldNames<MergeSingletonFields<TFields, TUpdatedAt>>
}

export type GenericSingleton = Singleton<Record<string, GenericField>, boolean, boolean>

type BaseDefineSingletonOptions = Pick<ISingleton, 'fields'> & Partial<Omit<ISingleton, 'fields' | 'logs'>>

export interface DefineSingletonOptions<
  TFields extends Record<string, GenericField>,
  TTranslatable extends boolean | undefined,
  TUpdatedAt extends boolean | UpdatedAtFieldPresetOptions | undefined,
> extends BaseDefineSingletonOptions {
  /**
   * @example
   * ```ts
   * {
   *   logo: imageField({}),
   *   copyrightText: textField({}),
   * }
   * ```
   */
  fields: TFields

  /**
   * @default true
   */
  translatable?: TTranslatable

  /**
   * @default []
   */
  syncedFields?: (keyof MergeSingletonFields<TFields, TUpdatedAt> & string)[]

  /**
   * @example
   * ```ts
   * {
   *   beforeQueryPreparation: [
   *     ({ operation }) => {
   *       if (operation === 'update') {
   *         // ...
   *       }
   *     },
   *   ],
   * }
   * ```
   */
  hooks?: SingletonHooks

  /**
   * @default
   * { read: true, update: true }
   */
  api?:
    | boolean
    | (SingletonAPIOptions & {
        /**
         * @default true
         */
        read?: boolean

        /**
         * @default true
         */
        update?: boolean
      })

  /**
   * @example
   * ```ts
   * import { defineSingleton } from '#pruvious/server'
   *
   * export default defineSingleton({
   *   fields: {
   *     // ...
   *   },
   *   guards: [
   *     ({ _ }) => {
   *       if (!useEvent().context.pruvious.auth.isLoggedIn) {
   *         throw new Error(_('You must be logged in'))
   *       }
   *     },
   *   ],
   * })
   * ```
   */
  guards?: SingletonGuard[]

  /**
   * @default true
   */
  authGuard?: boolean | ('read' | 'update')[]

  /**
   * @default null
   *
   * @example
   * ```ts
   * ({ source }) => ({ ...source, foo: 'New value' })
   * ```
   */
  copyTranslation?: SingletonCopyTranslationFunction<MergeSingletonFields<TFields, TUpdatedAt>> | null

  /**
   * Controls whether to log queries executed on this singleton.
   * Logged queries can be viewed in the Pruvious dashboard by admins and users with the `read-logs` permission.
   * Requires `pruvious.debug.logs.queries` to be enabled in `nuxt.config.ts`.
   *
   * Use `true` or `false` to enable/disable query logging with default settings.
   * For advanced configuration, provide an object with these options:
   *
   * - `exposeData` - Store actual query parameters and results instead of type placeholders (default: `true`).
   * - `operations` - Specify which database operations should be logged (logs all by default).
   *
   * @default true
   */
  logs?:
    | boolean
    | {
        /**
         * Controls the visibility of query parameters and results in log entries.
         * When set to `false`, it stores their data types instead of actual values.
         *
         * Warning: Enabling this will include potentially sensitive information in logs.
         *
         * @default true
         */
        exposeData?: boolean

        /**
         * Specifies which database operations should be logged.
         * Logs all operations by default.
         *
         * @default
         * { insert: true, select: true }
         */
        operations?: {
          /**
           * Log `INSERT` operations.
           *
           * Note: When updating a singleton, an "UPSERT" operation is performed internally.
           *       As a result, the `insert` operation will be logged during singleton updates.
           *
           * @default true
           */
          insert?: boolean

          /**
           * Log `SELECT` operations.
           *
           * @default true
           */
          select?: boolean
        }
      }

  /**
   * @default
   * {
   *   hidden: true,
   *   label: ({ __ }) => __('pruvious-dashboard', 'Updated'),
   *   description: ({ __ }) => __('pruvious-dashboard', 'The date and time when the record was last updated.'),
   * }
   */
  updatedAt?: TUpdatedAt

  /**
   * @default
   * {
   *   hidden: false,           // Visible in the dashboard
   *   label: undefined,        // Automatically generated from the singleton name
   *   dashboardLayout: 'auto', // Automatic layout selection based on block support
   *   fieldsLayout: undefined, // Stacked vertically in the order they are defined
   *   icon: 'folder',
   *   menu: {
   *     hidden: false,
   *     group: 'collections',
   *     order: 10,
   *   },
   * }
   */
  ui?: PartialMax2Levels<SingletonUIOptions<keyof MergeSingletonFields<TFields, TUpdatedAt> & string>>
}

interface SingletonBaseContext {
  /**
   * The current `Singleton` instance being queried.
   */
  readonly singleton: GenericSingleton

  /**
   * The name of the singleton being queried.
   */
  readonly singletonName: keyof Singletons

  /**
   * The language code that determines which translation of the singleton content should be returned.
   * If the singleton is not translatable, this value is `null`.
   */
  readonly singletonLanguage: LanguageCode | null
}

export type SingletonContext = (
  | Omit<SelectContext<GenericDatabase>, 'collection' | 'collectionName' | 'queryBuilder' | 'whereCondition'>
  | Omit<SanitizedUpdateContext<GenericDatabase>, 'collection' | 'collectionName' | 'queryBuilder' | 'whereCondition'>
) &
  SingletonBaseContext

export interface SingletonHooks {
  /**
   * Functions to execute before the SQL query is generated from the current query builder context.
   *
   * Each function receives a `context` instance related to the current operation as a parameter.
   *
   * Note: It's safe to throw errors in these functions to halt query execution.
   * Any thrown error will be caught and returned as a `QueryBuilderRuntimeError`.
   */
  beforeQueryPreparation?: ((context: SingletonContext) => any)[]

  /**
   * Functions to execute before the query is sent to the database.
   *
   * Each function receives the following arguments in order:
   *
   * - `context` - The context instance related to the current operation.
   * - `queryDetails` - The query details object with the following properties:
   *   - `query` - Object with `sql` string and `params` object.
   *
   * Note: It's safe to throw errors in these functions to halt query execution.
   * Any thrown error will be caught and returned as a `QueryBuilderRuntimeError`.
   */
  beforeQueryExecution?: ((context: SingletonContext, queryDetails: Pick<QueryDetails, 'query'>) => any)[]

  /**
   * Functions to execute after the query is executed and before the result is returned from a singleton query builder.
   *
   * Each function receives the following arguments in order:
   *
   * - `context` - The context instance related to the current operation.
   * - `queryDetails` - The query details object with the following properties:
   *   - `query` - Object with `sql` string and `params` object.
   *   - `queryExecutionTime` - The time taken for the database query to execute (in milliseconds).
   *   - `rawResult` - The raw query execution result or error message.
   *   - `result` - The formatted result of type `QueryBuilderResult`.
   *
   * Note: Avoid throwing errors in these functions as they may not be caught.
   */
  afterQueryExecution?: ((context: SingletonContext, queryDetails: QueryDetails) => any)[]
}

export type SingletonGuard = (
  /**
   * A `SingletonContext` instance related to the current query builder operation.
   */
  context: SingletonContext,
) => any

interface AutoFieldEnabled {
  /**
   * Specifies whether this singleton has the field activated.
   */
  enabled: boolean
}

interface ResolveContext {
  /**
   * The name of the singleton being resolved.
   */
  singletonName: string

  /**
   * The `ResolveFromLayersResultContextBinding` object containing the file location.
   */
  location: ResolveFromLayersResultContextBinding
}

type MergeSingletonFields<
  TFields extends Record<string, GenericField>,
  TUpdatedAt extends boolean | UpdatedAtFieldPresetOptions | undefined,
> = TFields & (DefaultTrue<TUpdatedAt> extends false ? {} : { updatedAt: ReturnType<typeof updatedAtFieldPreset> })

/**
 * Creates a new Pruvious singleton.
 *
 * Use this as the default export in a file within the `server/singletons/` directory.
 * The filename determines the singleton name, which should be in PascalCase (e.g. 'Tools.ts', 'ThemeOptions.ts', etc.).
 *
 * @see https://pruvious.com/docs/singletons
 *
 * @example
 * ```ts
 * // server/singletons/ThemeOptions.ts
 * import { defineSingleton, imageField, textField } from '#pruvious/server'
 *
 * export default defineSingleton({
 *   fields: {
 *     logo: imageField({}),
 *     copyrightText: textField({}),
 *   },
 * })
 * ```
 */
export function defineSingleton<
  const TFields extends Record<string, GenericField>,
  const TTranslatable extends boolean | undefined,
  const TUpdatedAt extends boolean | UpdatedAtFieldPresetOptions | undefined,
>(
  options: DefineSingletonOptions<TFields, TTranslatable, TUpdatedAt>,
): (
  resolveContext: ResolveContext,
) => Singleton<MergeSingletonFields<TFields, TUpdatedAt>, DefaultFalse<TTranslatable>, DefaultTrue<TUpdatedAt>> {
  return function (resolveContext: ResolveContext) {
    const fields: Record<string, GenericField> = { ...options.fields }
    const hooks: Required<SingletonHooks> = {
      beforeQueryPreparation: options.hooks?.beforeQueryPreparation ?? [],
      beforeQueryExecution: options.hooks?.beforeQueryExecution ?? [],
      afterQueryExecution: options.hooks?.afterQueryExecution ?? [],
    }
    const translatable = options.translatable ?? true
    const syncedFields = options.syncedFields ?? []
    const updatedAt: AutoFieldEnabled & UpdatedAtFieldPresetOptions = defu(
      { enabled: options.updatedAt !== false },
      isObject(options.updatedAt) ? options.updatedAt : {},
    )
    const ui = deepClone(options.ui)

    for (const fieldName of Object.keys(fields)) {
      if (updatedAt.enabled && fieldName === 'updatedAt') {
        warnWithContext(`The field name ${colorize('yellow', fieldName)} is reserved.`, [
          `This field is automatically generated by the singleton.`,
          `You can disable this behavior by setting the \`updatedAt\` option to \`false\` in your singleton definition.`,
          `Source: ${colorize('dim', resolveContext.location.file.relative)}`,
        ])
        delete fields[fieldName]
      } else if (camelCase(fieldName) !== fieldName) {
        warnWithContext(`The field name ${colorize('yellow', fieldName)} is invalid.`, [
          `Field names must be in camelCase format.`,
          `Suggested name: ${colorize('greenBright', camelCase(fieldName) || 'fieldName')}`,
          `Source: ${colorize('dim', resolveContext.location.file.relative)}`,
        ])
        delete fields[fieldName]
      }
    }

    if (updatedAt.enabled) {
      fields.updatedAt = updatedAtFieldPreset(omit(updatedAt, ['enabled']))
    }

    if (translatable && syncedFields.length) {
      hooks.afterQueryExecution.push(async (context, { result }) => {
        if (
          !context.customData._syncingFields &&
          context.operation === 'update' &&
          result.success &&
          syncedFields.some((syncedField: any) => isDefined(context.sanitizedInput[syncedField]))
        ) {
          const { updateSingleton, languages } = await import('#pruvious/server')
          const fieldsToSync = syncedFields.filter((syncedField: any) => isDefined(context.sanitizedInput[syncedField]))
          const syncInput = Object.fromEntries(
            fieldsToSync.map((syncedField: any) => [syncedField, context.sanitizedInput[syncedField]]),
          )
          await Promise.allSettled(
            languages
              .filter(({ code }) => code !== context.singletonLanguage)
              .map(({ code }) =>
                updateSingleton(context.singletonName)
                  .set(syncInput)
                  .language(code as never)
                  .withCustomContextData({ _syncingFields: true })
                  .run(),
              ),
          )
        }
      })
    }

    if (isString(ui?.dashboardLayout) && !['auto', 'standard', 'live-preview'].includes(ui.dashboardLayout)) {
      ui.dashboardLayout = ui.dashboardLayout.includes('/')
        ? hash(
            resolveCustomComponentPath({
              component: ui.dashboardLayout,
              file: resolveContext.location.file.absolute,
              srcDir: resolveContext.location.srcDir,
            }),
          )
        : ui.dashboardLayout
    }

    if (ui?.fieldsLayout) {
      for (const { item, path } of walkFieldLayoutItems(ui.fieldsLayout)) {
        if (isObject(item) && 'component' in item) {
          setProperty(
            ui.fieldsLayout,
            `${path}.component`,
            item.component.includes('/')
              ? hash(
                  resolveCustomComponentPath({
                    component: item.component,
                    file: resolveContext.location.file.absolute,
                    srcDir: resolveContext.location.srcDir,
                  }),
                )
              : item.component,
          )
        }
      }
    }

    return {
      fields: fields as any,
      translatable: translatable as any,
      syncedFields: syncedFields,
      hooks,
      api: defu(
        isUndefined(options.api) || options.api === true
          ? {}
          : options.api === false
            ? { read: false, update: false }
            : options.api,
        { read: true, update: true },
      ),
      guards: [singletonPermissionGuard, ...(options.guards ?? [])],
      authGuard:
        isUndefined(options.authGuard) || options.authGuard === true
          ? ['read', 'update']
          : options.authGuard === false
            ? []
            : options.authGuard,
      copyTranslation: options.copyTranslation ?? (null as any),
      logs: {
        enabled: options.logs !== false,
        exposeData: isObject(options.logs) ? !!options.logs.exposeData : true,
        operations: defu(isObject(options.logs) && isObject(options.logs.operations) ? options.logs.operations : {}, {
          insert: true,
          select: true,
        }),
      },
      updatedAt,
      ui: defu(ui ?? {}, {
        hidden: false,
        label: undefined,
        icon: 'settings',
        menu: { hidden: false, group: 'general', order: 10 },
        dashboardLayout: 'auto' as any,
        fieldsLayout: undefined as any,
      } satisfies Required<SingletonUIOptions>),
      TFieldNames: undefined as any,
      TDataTypes: undefined as any,
      TCastedTypes: undefined as any,
      TPopulatedTypes: undefined as any,
      TInputTypes: undefined as any,
      TNullableFields: undefined as any,
      TAutoGeneratedFields: undefined as any,
      TConditionalFields: undefined as any,
    }
  }
}

import type { GenericSerializableFieldOptions } from '#pruvious/server'
import type { ConditionalLogic } from '@pruvious/orm'
import { ConditionalLogicResolver } from '@pruvious/orm/conditional-logic-resolver'
import {
  deepClone,
  deepCompare,
  deleteProperty,
  getProperty,
  isArray,
  isDefined,
  isObject,
  isUndefined,
  resolveRelativeDotNotation,
  setProperty,
} from '@pruvious/utils'

/**
 * Fills any `undefined` values in the `data` object by using the default values specified in the `fields` configuration.
 * Creates a new object without modifying the original `data`.
 */
export function fillFieldData<T extends Record<string, any>>(
  data: T,
  fields: Record<string, GenericSerializableFieldOptions>,
): T {
  const filledData: Record<string, any> = { ...data }

  for (const [fieldName, field] of Object.entries(fields)) {
    if (isUndefined(filledData[fieldName])) {
      filledData[fieldName] = deepClone(field.default)
    }
  }

  return filledData as T
}

/**
 * Prepares the field `data` for API submission to collection or singleton endpoints.
 * Creates a new object without modifying the original `data`.
 *
 * When `prevData` is provided, the function performs a diff comparison and only includes
 * fields that have changed compared to their previous state.
 * It also removes immutable fields from the output object and handles the operation as an update.
 *
 * @todo test with subfields (conditional logic and dependencies)
 */
export function prepareFieldData<T extends Record<string, any>>(
  data: T,
  fields: Record<string, GenericSerializableFieldOptions>,
  prevData?: Partial<T>,
): Partial<T> {
  const preparedData: Record<string, any> = deepClone(data)
  const conditionalLogic = new ConditionalLogicResolver()
    .setInput(data)
    .setConditionalLogic(parseConditionalLogic(fields, data))
    .resolve()

  for (const [fieldName, field] of Object.entries(fields)) {
    if (field.autoGenerated || (prevData && field.immutable)) {
      delete preparedData[fieldName]
    }
  }

  for (const [fieldPath, include] of Object.entries(conditionalLogic)) {
    if (!include || (prevData && deepCompare(getProperty(prevData, fieldPath), getProperty(data, fieldPath)))) {
      deleteProperty(preparedData, fieldPath)
    }
  }

  let includedDependencies: boolean

  do {
    includedDependencies = false

    for (const [fieldName, field] of Object.entries(fields)) {
      if (isDefined(preparedData[fieldName])) {
        for (const dependency of field.dependencies) {
          const referencedFieldPath = resolveRelativeDotNotation(fieldName, dependency)

          if (isUndefined(getProperty(preparedData, referencedFieldPath))) {
            const referencedFieldValue = deepClone(getProperty(data, referencedFieldPath))

            if (isDefined(referencedFieldValue)) {
              setProperty(preparedData, referencedFieldPath, referencedFieldValue)
              includedDependencies = true
            }
          }

          if (field.subfields) {
            const subfieldMap = resolveSubfieldsFromData(field.subfields, preparedData[fieldName])

            for (const [subfieldPath, subfield] of Object.entries(subfieldMap)) {
              for (const subfieldDependency of subfield.dependencies) {
                const subfieldReferencedFieldPath = resolveRelativeDotNotation(
                  `${fieldName}.${subfieldPath}`,
                  subfieldDependency,
                )

                if (isUndefined(getProperty(preparedData, subfieldReferencedFieldPath))) {
                  const subfieldReferencedFieldValue = deepClone(getProperty(data, subfieldReferencedFieldPath))

                  if (isDefined(subfieldReferencedFieldValue)) {
                    setProperty(preparedData, subfieldReferencedFieldPath, subfieldReferencedFieldValue)
                    includedDependencies = true
                  }
                }
              }
            }
          }
        }
      }
    }
  } while (includedDependencies)

  return preparedData as Partial<T>
}

/**
 * Maps `subfields` based on user `data`.
 *
 * The method returns a map with:
 *
 * - Keys as subfield paths in dot notation (e.g., '0.firstName', '0.lastName', '1.firstName', etc.).
 * - Values as the corresponding `GenericSerializableFieldOptions` instances.
 */
export function resolveSubfieldsFromData(
  subfields: Record<string, GenericSerializableFieldOptions> | undefined,
  data: any,
): Record<string, GenericSerializableFieldOptions> {
  const map: Record<string, GenericSerializableFieldOptions> = {}

  if (isDefined(subfields) && isArray(data)) {
    for (const [index, item] of data.entries()) {
      for (const [subfieldName, subfield] of Object.entries(subfields)) {
        const key = `${index}.${subfieldName}`
        map[key] = subfield

        if (subfield.subfields && isObject(item)) {
          const nestedMap = resolveSubfieldsFromData(subfield.subfields, item[subfieldName])

          for (const [nestedKey, nestedField] of Object.entries(nestedMap)) {
            map[`${key}.${nestedKey}`] = nestedField
          }
        }
      }
    }
  }

  return map
}

/**
 * Parses conditional logic for a list of serializable `fields` and their `data`.
 *
 * Returns an object where:
 *
 * - Keys are field paths (using dot notation for nested fields).
 * - Values are the corresponding conditional logic objects to evaluate (if present).
 */
export function parseConditionalLogic(
  fields: Record<string, GenericSerializableFieldOptions>,
  data: Record<string, any>,
): Record<string, ConditionalLogic | undefined> {
  const parsedConditionalLogic: Record<string, ConditionalLogic | undefined> = {}

  for (const [fieldName, field] of Object.entries(fields)) {
    parsedConditionalLogic[fieldName] = field.conditionalLogic

    if (field.subfields) {
      const subfieldMap = resolveSubfieldsFromData(field.subfields, data[fieldName])

      for (const [subfieldPath, subfield] of Object.entries(subfieldMap)) {
        parsedConditionalLogic[`${fieldName}.${subfieldPath}`] = subfield.conditionalLogic
      }
    }
  }

  return parsedConditionalLogic
}

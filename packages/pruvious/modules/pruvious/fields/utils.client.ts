import type { GenericSerializableFieldOptions } from '#pruvious/server'
import type { ConditionalLogic } from '@pruvious/orm'
import { ConditionalLogicResolver } from '@pruvious/orm/conditional-logic-resolver'
import {
  deepClone,
  deepCompare,
  isArray,
  isDefined,
  isObject,
  isUndefined,
  resolveRelativeDotNotation,
  uniqueArray,
} from '@pruvious/utils'

/**
 * Fills any `undefined` values in the `data` object by using the default values specified in the `fields` configuration.
 * Creates a new object without modifying the original `data`.
 */
export function fillFieldData<T extends Record<string, any>>(
  data: T,
  fields: Record<string, GenericSerializableFieldOptions>,
): T {
  const filledData: Record<string, any> = { ...data }

  for (const [fieldName, field] of Object.entries(fields)) {
    if (isUndefined(filledData[fieldName])) {
      filledData[fieldName] = deepClone(field.default)
    }
  }

  return filledData as T
}

/**
 * Prepares the field `data` for API submission to collection or singleton endpoints.
 * Creates a new object without modifying the original `data`.
 *
 * When `prevData` is provided, the function performs a diff comparison and only includes
 * fields that have changed compared to their previous state.
 * It also removes immutable fields from the output object and handles the operation as an update.
 */
export function prepareFieldData<T extends Record<string, any>>(
  data: T,
  fields: Record<string, GenericSerializableFieldOptions>,
  prevData?: Partial<T>,
): Partial<T> {
  const preparedData: Record<string, any> = deepClone(data)
  const conditionalLogic = new ConditionalLogicResolver()
    .setInput(data)
    .setConditionalLogic(parseConditionalLogic(fields, data))
    .resolve()

  for (const [fieldName, field] of Object.entries(fields)) {
    if (
      field.autoGenerated ||
      !conditionalLogic[fieldName] ||
      (prevData && (field.immutable || deepCompare(prevData[fieldName], data[fieldName])))
    ) {
      delete preparedData[fieldName]
    }
  }

  for (const fieldName of Object.keys(preparedData)) {
    for (const dependency of getTopLevelFieldDependencies(fieldName, fields[fieldName]!)) {
      preparedData[dependency] = data[dependency]
    }
  }

  return preparedData as Partial<T>
}

/**
 * Retrieves top-level dependencies for a given field and its subfields.
 *
 * @returns an array of top-level field names.
 */
export function getTopLevelFieldDependencies(
  fieldPath: string,
  fieldOptions: GenericSerializableFieldOptions,
): string[] {
  const dependencies: string[] = []
  const _subfields = (fieldOptions.subfields ?? {}) as Record<string, GenericSerializableFieldOptions>
  const _structure = (fieldOptions.structure ?? {}) as {
    [$key: string]: Record<string, GenericSerializableFieldOptions>
  }
  const subfields = { ..._subfields, ...Object.values(_structure).reduce((acc, sf) => ({ ...acc, ...sf }), {}) }

  if (fieldOptions.conditionalLogic) {
    for (const path of new ConditionalLogicResolver().getReferencedFieldPaths(
      fieldPath,
      fieldOptions.conditionalLogic,
    )) {
      dependencies.push(path.split('.')[0]!)
    }
  }

  if (fieldOptions.dependencies.length) {
    dependencies.push(...fieldOptions.dependencies.map((d) => resolveRelativeDotNotation(fieldPath, d)))
  }

  for (const [sn, so] of Object.entries(subfields)) {
    dependencies.push(
      ...getTopLevelFieldDependencies(
        fieldOptions._fieldType === 'repeater' || fieldOptions._fieldType === 'structure'
          ? `${fieldPath}.0.${sn}`
          : `${fieldPath}.${sn}`,
        so,
      ),
    )
  }

  return uniqueArray(dependencies)
}

/**
 * Maps `subfields` based on user `data`.
 *
 * The method returns a map with:
 *
 * - Keys as subfield paths in dot notation (e.g., '0.firstName', '0.lastName', 'foo.bar', etc.).
 * - Values as the corresponding `GenericSerializableFieldOptions` instances.
 */
export function resolveSubfieldsFromData(
  subfields: Record<string, GenericSerializableFieldOptions> | undefined,
  data: any,
): Record<string, GenericSerializableFieldOptions> {
  const map: Record<string, GenericSerializableFieldOptions> = {}

  if (isDefined(subfields)) {
    if (isArray(data)) {
      for (const [index, item] of data.entries()) {
        for (const [subfieldName, subfield] of Object.entries(subfields)) {
          const key = `${index}.${subfieldName}`
          map[key] = subfield

          if (subfield.subfields && isObject(item)) {
            const nestedMap = resolveSubfieldsFromData(subfield.subfields, item[subfieldName])

            for (const [nestedKey, nestedField] of Object.entries(nestedMap)) {
              map[`${key}.${nestedKey}`] = nestedField
            }
          } else if (subfield.structure && isObject(item) && isArray(item[subfieldName])) {
            for (const [$key, structureSubfields] of Object.entries(subfield.structure)) {
              const nestedMap = resolveSubfieldsFromData(
                structureSubfields as any,
                item[subfieldName].map((item: any) => (item.$key === $key ? item : undefined)),
              )

              for (const [nestedKey, nestedField] of Object.entries(nestedMap)) {
                map[`${key}.${nestedKey}`] = nestedField
              }
            }
          }
        }
      }
    } else if (isObject(data)) {
      for (const [subfieldName, subfield] of Object.entries(subfields)) {
        const key = subfieldName
        map[key] = subfield

        if (subfield.subfields) {
          const nestedMap = resolveSubfieldsFromData(subfield.subfields, data[subfieldName])

          for (const [nestedKey, nestedField] of Object.entries(nestedMap)) {
            map[`${key}.${nestedKey}`] = nestedField
          }
        }
      }
    }
  }

  return map
}

/**
 * Parses conditional logic for a list of serializable `fields` and their `data`.
 *
 * Returns an object where:
 *
 * - Keys are field paths (using dot notation for nested fields).
 * - Values are the corresponding conditional logic objects to evaluate (if present).
 */
export function parseConditionalLogic(
  fields: Record<string, GenericSerializableFieldOptions>,
  data: Record<string, any>,
): Record<string, ConditionalLogic | undefined> {
  const parsedConditionalLogic: Record<string, ConditionalLogic | undefined> = {}

  for (const [fieldName, field] of Object.entries(fields)) {
    parsedConditionalLogic[fieldName] = field.conditionalLogic

    if (field.subfields) {
      const subfieldMap = resolveSubfieldsFromData(field.subfields, data[fieldName])

      for (const [subfieldPath, subfield] of Object.entries(subfieldMap)) {
        parsedConditionalLogic[`${fieldName}.${subfieldPath}`] = subfield.conditionalLogic
      }
    } else if (field.structure) {
      if (isObject(data) && isArray(data[fieldName])) {
        for (const [$key, subfields] of Object.entries(field.structure)) {
          const subfieldMap = resolveSubfieldsFromData(
            subfields as any,
            data[fieldName].map((item: any) => (item.$key === $key ? item : undefined)),
          )

          for (const [subfieldPath, subfield] of Object.entries(subfieldMap)) {
            parsedConditionalLogic[`${fieldName}.${subfieldPath}`] = subfield.conditionalLogic
          }
        }
      }
    }
  }

  return parsedConditionalLogic
}

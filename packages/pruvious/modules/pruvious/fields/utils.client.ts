import type { GenericSerializableFieldOptions } from '#pruvious/server'
import type { ConditionalLogic } from '@pruvious/orm'
import { ConditionalLogicResolver } from '@pruvious/orm/conditional-logic-resolver'
import {
  deepClone,
  deepCompare,
  deleteProperty,
  getProperty,
  isArray,
  isDefined,
  isObject,
  isUndefined,
  resolveRelativeDotNotation,
} from '@pruvious/utils'

/**
 * Fills any `undefined` values in the `data` object by using the default values specified in the `fields` configuration.
 * Creates a new object without modifying the original `data`.
 */
export function fillFieldData<T extends Record<string, any>>(
  data: T,
  fields: Record<string, GenericSerializableFieldOptions>,
): T {
  const filledData: Record<string, any> = { ...data }

  for (const [fieldName, field] of Object.entries(fields)) {
    if (isUndefined(filledData[fieldName])) {
      filledData[fieldName] = deepClone(field.default)
    }
  }

  return filledData as T
}

/**
 * Prepares the field `data` for API submission to collection or singleton endpoints.
 * Creates a new object without modifying the original `data`.
 *
 * When `prevData` is provided, the function performs a diff comparison and only includes
 * fields that have changed compared to their previous state.
 * It also removes immutable fields from the output object and handles the operation as an update.
 *
 * @todo test with subfields and structures (conditional logic and dependencies)
 */
export function prepareFieldData<T extends Record<string, any>>(
  data: T,
  fields: Record<string, GenericSerializableFieldOptions>,
  prevData?: Partial<T>,
): Partial<T> {
  const preparedData: Record<string, any> = deepClone(data)
  const conditionalLogic = new ConditionalLogicResolver()
    .setInput(data)
    .setConditionalLogic(parseConditionalLogic(fields, data))
    .resolve()

  for (const [fieldName, field] of Object.entries(fields)) {
    if (field.autoGenerated || (prevData && field.immutable)) {
      delete preparedData[fieldName]
    }
  }

  for (const [fieldPath, include] of Object.entries(conditionalLogic)) {
    if (
      !fieldPath.includes('.') &&
      (!include || (prevData && deepCompare(getProperty(prevData, fieldPath), getProperty(data, fieldPath))))
    ) {
      deleteProperty(preparedData, fieldPath)
    }
  }

  let includedDependencies: boolean

  do {
    includedDependencies = false

    for (const [fieldName, field] of Object.entries(fields)) {
      if (isDefined(preparedData[fieldName])) {
        for (const dependency of field.dependencies) {
          const referencedFieldPath = resolveRelativeDotNotation(fieldName, dependency)

          if (isUndefined(getProperty(preparedData, referencedFieldPath))) {
            const parentPath = referencedFieldPath.split('.')[0]!
            const referencedFieldValue = deepClone(data[parentPath])

            if (isDefined(referencedFieldValue)) {
              preparedData[parentPath] = referencedFieldValue
              includedDependencies = true
            }
          }

          if (field.subfields) {
            const subfieldMap = resolveSubfieldsFromData(field.subfields, preparedData[fieldName])

            for (const [subfieldPath, subfield] of Object.entries(subfieldMap)) {
              for (const subfieldDependency of subfield.dependencies) {
                const subfieldReferencedFieldPath = resolveRelativeDotNotation(
                  `${fieldName}.${subfieldPath}`,
                  subfieldDependency,
                )

                if (isUndefined(getProperty(preparedData, subfieldReferencedFieldPath))) {
                  const parentPath = subfieldReferencedFieldPath.split('.')[0]!
                  const subfieldReferencedFieldValue = deepClone(data[parentPath])

                  if (isDefined(subfieldReferencedFieldValue)) {
                    preparedData[parentPath] = subfieldReferencedFieldValue
                    includedDependencies = true
                  }
                }
              }
            }
          } else if (field.structure) {
            const subfieldMap = resolveSubfieldsFromData(field.structure, preparedData[fieldName])

            for (const [subfieldPath, subfield] of Object.entries(subfieldMap)) {
              for (const subfieldDependency of subfield.dependencies) {
                const subfieldReferencedFieldPath = resolveRelativeDotNotation(
                  `${fieldName}.${subfieldPath}`,
                  subfieldDependency,
                )

                if (isUndefined(getProperty(preparedData, subfieldReferencedFieldPath))) {
                  const parentPath = subfieldReferencedFieldPath.split('.')[0]!
                  const subfieldReferencedFieldValue = deepClone(getProperty(data, subfieldReferencedFieldPath))

                  if (isDefined(subfieldReferencedFieldValue)) {
                    preparedData[parentPath] = subfieldReferencedFieldValue
                    includedDependencies = true
                  }
                }
              }
            }
          }
        }
      }
    }
  } while (includedDependencies)

  return preparedData as Partial<T>
}

/**
 * Maps `subfields` based on user `data`.
 *
 * The method returns a map with:
 *
 * - Keys as subfield paths in dot notation (e.g., '0.firstName', '0.lastName', 'foo.bar', etc.).
 * - Values as the corresponding `GenericSerializableFieldOptions` instances.
 */
export function resolveSubfieldsFromData(
  subfields: Record<string, GenericSerializableFieldOptions> | undefined,
  data: any,
): Record<string, GenericSerializableFieldOptions> {
  const map: Record<string, GenericSerializableFieldOptions> = {}

  if (isDefined(subfields)) {
    if (isArray(data)) {
      for (const [index, item] of data.entries()) {
        for (const [subfieldName, subfield] of Object.entries(subfields)) {
          const key = `${index}.${subfieldName}`
          map[key] = subfield

          if (subfield.subfields && isObject(item)) {
            const nestedMap = resolveSubfieldsFromData(subfield.subfields, item[subfieldName])

            for (const [nestedKey, nestedField] of Object.entries(nestedMap)) {
              map[`${key}.${nestedKey}`] = nestedField
            }
          } else if (subfield.structure && isObject(item) && isArray(item[subfieldName])) {
            for (const [$key, structureSubfields] of Object.entries(subfield.structure)) {
              const nestedMap = resolveSubfieldsFromData(
                structureSubfields as any,
                item[subfieldName].map((item: any) => (item.$key === $key ? item : undefined)),
              )

              for (const [nestedKey, nestedField] of Object.entries(nestedMap)) {
                map[`${key}.${nestedKey}`] = nestedField
              }
            }
          }
        }
      }
    } else if (isObject(data)) {
      for (const [subfieldName, subfield] of Object.entries(subfields)) {
        const key = subfieldName
        map[key] = subfield

        if (subfield.subfields) {
          const nestedMap = resolveSubfieldsFromData(subfield.subfields, data[subfieldName])

          for (const [nestedKey, nestedField] of Object.entries(nestedMap)) {
            map[`${key}.${nestedKey}`] = nestedField
          }
        }
      }
    }
  }

  return map
}

/**
 * Parses conditional logic for a list of serializable `fields` and their `data`.
 *
 * Returns an object where:
 *
 * - Keys are field paths (using dot notation for nested fields).
 * - Values are the corresponding conditional logic objects to evaluate (if present).
 */
export function parseConditionalLogic(
  fields: Record<string, GenericSerializableFieldOptions>,
  data: Record<string, any>,
): Record<string, ConditionalLogic | undefined> {
  const parsedConditionalLogic: Record<string, ConditionalLogic | undefined> = {}

  for (const [fieldName, field] of Object.entries(fields)) {
    parsedConditionalLogic[fieldName] = field.conditionalLogic

    if (field.subfields) {
      const subfieldMap = resolveSubfieldsFromData(field.subfields, data[fieldName])

      for (const [subfieldPath, subfield] of Object.entries(subfieldMap)) {
        parsedConditionalLogic[`${fieldName}.${subfieldPath}`] = subfield.conditionalLogic
      }
    } else if (field.structure) {
      if (isObject(data) && isArray(data[fieldName])) {
        for (const [$key, subfields] of Object.entries(field.structure)) {
          const subfieldMap = resolveSubfieldsFromData(
            subfields as any,
            data[fieldName].map((item: any) => (item.$key === $key ? item : undefined)),
          )

          for (const [subfieldPath, subfield] of Object.entries(subfieldMap)) {
            parsedConditionalLogic[`${fieldName}.${subfieldPath}`] = subfield.conditionalLogic
          }
        }
      }
    }
  }

  return parsedConditionalLogic
}

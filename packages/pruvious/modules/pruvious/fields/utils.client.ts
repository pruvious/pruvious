import type { BlockName, GenericSerializableFieldOptions } from '#pruvious/server'
import type { ConditionalLogic } from '@pruvious/orm'
import { ConditionalLogicResolver } from '@pruvious/orm/conditional-logic-resolver'
import {
  deepClone,
  deepCompare,
  isArray,
  isObject,
  isString,
  isUndefined,
  resolveRelativeDotNotation,
  uniqueArray,
} from '@pruvious/utils'
import { usePruviousDashboard } from '../pruvious/utils.client'

/**
 * Fills any `undefined` values in the `data` object by using the default values specified in the `fields` configuration.
 * Creates a new object without modifying the original `data`.
 */
export function fillFieldData<T extends Record<string, any>>(
  data: T,
  fields: Record<string, GenericSerializableFieldOptions>,
): T {
  const filledData: Record<string, any> = { ...data }

  for (const [fieldName, field] of Object.entries(fields)) {
    if (isUndefined(filledData[fieldName])) {
      filledData[fieldName] = deepClone(field.default)
    }
  }

  return filledData as T
}

/**
 * Prepares the field `data` for API submission to collection or singleton endpoints.
 * Creates a new object without modifying the original `data`.
 *
 * When `prevData` is provided, the function performs a diff comparison and only includes
 * fields that have changed compared to their previous state.
 * It also removes immutable fields from the output object and handles the operation as an update.
 */
export function prepareFieldData<T extends Record<string, any>>(
  data: T,
  fields: Record<string, GenericSerializableFieldOptions>,
  prevData?: Partial<T>,
): Partial<T> {
  const preparedData: Record<string, any> = deepClone(data)
  const conditionalLogic = new ConditionalLogicResolver()
    .setInput(data)
    .setConditionalLogic(parseConditionalLogic(fields, data))
    .resolve()

  for (const [fieldName, field] of Object.entries(fields)) {
    if (
      field.autoGenerated ||
      !conditionalLogic[fieldName] ||
      (prevData && (field.immutable || deepCompare(prevData[fieldName], data[fieldName])))
    ) {
      delete preparedData[fieldName]
    }
  }

  for (const fieldName of Object.keys(preparedData)) {
    for (const dependency of getTopLevelFieldDependencies(fieldName, fields[fieldName]!)) {
      preparedData[dependency] = data[dependency]
    }
  }

  return preparedData as Partial<T>
}

/**
 * Retrieves top-level dependencies for a given field and its subfields.
 *
 * @returns an array of top-level field names.
 */
export function getTopLevelFieldDependencies(
  fieldPath: string,
  fieldOptions: GenericSerializableFieldOptions,
): string[] {
  const dependencies: string[] = []
  const _subfields = (fieldOptions.subfields ?? {}) as Record<string, GenericSerializableFieldOptions>
  const _structure = (fieldOptions.structure ?? {}) as {
    [$key: string]: Record<string, GenericSerializableFieldOptions>
  }
  const _blockFields = fieldOptions._fieldType === 'blocks' ? (usePruviousDashboard().value?.blocks ?? {}) : {}
  const subfields: Record<string, GenericSerializableFieldOptions> = {
    ..._subfields,
    ...Object.values(_structure).reduce((acc, sf) => ({ ...acc, ...sf }), {}),
    ...Object.values(_blockFields).reduce((acc, block) => ({ ...acc, ...block.fields }), {}),
  }

  if (fieldOptions.conditionalLogic) {
    for (const path of new ConditionalLogicResolver().getReferencedFieldPaths(
      fieldPath,
      fieldOptions.conditionalLogic,
    )) {
      dependencies.push(path.split('.')[0]!)
    }
  }

  if (fieldOptions.dependencies.length) {
    dependencies.push(...fieldOptions.dependencies.map((d) => resolveRelativeDotNotation(fieldPath, d)))
  }

  for (const [sn, so] of Object.entries(subfields)) {
    if (so._fieldType === 'blocks' && fieldOptions._fieldType === 'blocks') {
      continue
    }

    dependencies.push(
      ...getTopLevelFieldDependencies(
        isArray(fieldOptions.default) ? `${fieldPath}.0.${sn}` : `${fieldPath}.${sn}`,
        so,
      ),
    )
  }

  return uniqueArray(dependencies)
}

/**
 * Parses conditional logic for a list of serializable `fields` and their `data`.
 *
 * Returns an object where:
 *
 * - Keys are field paths (using dot notation for nested fields).
 * - Values are the corresponding conditional logic objects to evaluate (if present).
 */
export function parseConditionalLogic(
  fields: Record<string, GenericSerializableFieldOptions>,
  data: Record<string, unknown>,
): Record<string, ConditionalLogic | undefined> {
  const parsedConditionalLogic: Record<string, ConditionalLogic | undefined> = {}

  for (const [fieldName, field] of Object.entries(fields)) {
    const item = data[fieldName]
    parsedConditionalLogic[fieldName] = field.conditionalLogic

    if (field.subfields) {
      if (isObject(item)) {
        for (const [sfp, sfpcl] of Object.entries(parseConditionalLogic(field.subfields, item))) {
          parsedConditionalLogic[`${fieldName}.${sfp}`] = sfpcl
        }
      } else if (isArray(item)) {
        for (const [index, arrayItem] of item.entries()) {
          if (isObject(arrayItem)) {
            for (const [sfp, sfpcl] of Object.entries(parseConditionalLogic(field.subfields, arrayItem))) {
              parsedConditionalLogic[`${fieldName}.${index}.${sfp}`] = sfpcl
            }
          }
        }
      }
    } else if (field.structure) {
      if (isArray(item)) {
        for (const [index, arrayItem] of item.entries()) {
          if (isObject(arrayItem)) {
            const subfields = isString(arrayItem.$key) ? field.structure[arrayItem.$key] : undefined
            if (subfields) {
              for (const [sfp, sfpcl] of Object.entries(parseConditionalLogic(subfields, arrayItem))) {
                parsedConditionalLogic[`${fieldName}.${index}.${sfp}`] = sfpcl
              }
            }
          }
        }
      }
    } else if (field._fieldType === 'blocks') {
      if (isArray(item)) {
        for (const [index, arrayItem] of item.entries()) {
          if (isObject(arrayItem)) {
            const blocks = usePruviousDashboard().value?.blocks ?? {}
            const block = isString(arrayItem.$key) ? blocks[arrayItem.$key as BlockName] : undefined
            if (block) {
              for (const [sfp, sfpcl] of Object.entries(parseConditionalLogic(block.fields, arrayItem))) {
                parsedConditionalLogic[`${fieldName}.${index}.${sfp}`] = sfpcl
              }
            }
          }
        }
      }
    }
  }

  return parsedConditionalLogic
}

/**
 * Parses fields from a list of serializable `fields` and some collection or singleton `data`.
 *
 * Returns an object where:
 *
 * - Keys are field paths (using dot notation for nested fields).
 * - Values are the corresponding field options.
 */
export function parseFields(
  fields: Record<string, GenericSerializableFieldOptions>,
  data: Record<string, unknown>,
): Record<string, GenericSerializableFieldOptions> {
  const parsedFields: Record<string, GenericSerializableFieldOptions> = {}

  for (const [fieldName, field] of Object.entries(fields)) {
    const item = data[fieldName]
    parsedFields[fieldName] = field

    if (field.subfields) {
      if (isObject(item)) {
        for (const [sfp, sfpcl] of Object.entries(parseFields(field.subfields, item))) {
          parsedFields[`${fieldName}.${sfp}`] = sfpcl
        }
      } else if (isArray(item)) {
        for (const [index, arrayItem] of item.entries()) {
          if (isObject(arrayItem)) {
            for (const [sfp, sfpcl] of Object.entries(parseFields(field.subfields, arrayItem))) {
              parsedFields[`${fieldName}.${index}.${sfp}`] = sfpcl
            }
          }
        }
      }
    } else if (field.structure) {
      if (isArray(item)) {
        for (const [index, arrayItem] of item.entries()) {
          if (isObject(arrayItem)) {
            const subfields = isString(arrayItem.$key) ? field.structure[arrayItem.$key] : undefined
            if (subfields) {
              for (const [sfp, sfpcl] of Object.entries(parseFields(subfields, arrayItem))) {
                parsedFields[`${fieldName}.${index}.${sfp}`] = sfpcl
              }
            }
          }
        }
      }
    } else if (field._fieldType === 'blocks') {
      if (isArray(item)) {
        for (const [index, arrayItem] of item.entries()) {
          if (isObject(arrayItem)) {
            const blocks = usePruviousDashboard().value?.blocks ?? {}
            const block = isString(arrayItem.$key) ? blocks[arrayItem.$key as BlockName] : undefined
            if (block) {
              for (const [sfp, sfpcl] of Object.entries(parseFields(block.fields, arrayItem))) {
                parsedFields[`${fieldName}.${index}.${sfp}`] = sfpcl
              }
            }
          }
        }
      }
    }
  }

  return parsedFields
}

import type { Fields, GenericDatabase } from '#pruvious/server'
import type { ConditionalLogic, Context, DataType, FieldDefinition, GenericField } from '@pruvious/orm'
import { isObject } from '@pruvious/utils'
import { hash } from 'ohash'

export type GenericFieldDefinition = FieldDefinition<
  any,
  any,
  boolean,
  boolean,
  boolean,
  boolean,
  ConditionalLogic | undefined,
  any
>

type BaseSerializableFieldOptions = Required<
  Pick<GenericFieldDefinition, 'nullable' | 'required' | 'immutable' | 'autoGenerated' | 'default' | 'dependencies'>
> &
  Pick<GenericFieldDefinition, 'conditionalLogic'> & {
    /**
     * The registered field type.
     */
    _fieldType: keyof Fields

    /**
     * The primitive data type of the field.
     * For top-level fields, this determines the database column type.
     *
     * Supported data types:
     *
     * - `bigint`
     * - `boolean`
     * - `numeric`
     * - `text`
     */
    _dataType: DataType
  }

export type SerializableFieldOptions<TField extends keyof Fields> = Readonly<
  BaseSerializableFieldOptions &
    Omit<Fields[TField]['options'], 'populator' | 'structure' | 'subfields'> &
    (Fields[TField]['options'] extends { structure: any }
      ? { structure: { [$key: string]: Record<string, GenericField> } }
      : {}) &
    (Fields[TField]['options'] extends { subfields: any }
      ? { subfields: Record<string, GenericSerializableFieldOptions> }
      : {})
>

export type GenericSerializableFieldOptions = Readonly<BaseSerializableFieldOptions & Record<string, any>>

/**
 * Limits the population of a field to a maximum number of occurrences in a single query.
 * This function is useful to prevent infinite loops when populating fields that reference each other.
 *
 * @throws an error if the population limit is exceeded.
 */
export function limitPopulation(
  value: any,
  { definition, context, path }: { definition: GenericField; context: Context<GenericDatabase>; path: string },
  limit = 32,
) {
  if (!isObject(context.cache['_tmp'])) {
    context.cache['_tmp'] = {}
  }

  if (!(context.cache['_tmp']['_populationLimit'] instanceof Map)) {
    context.cache['_tmp']['_populationLimit'] = new Map()
  }

  const map = context.cache['_tmp']['_populationLimit'] as Map<any, number>
  const entry = hash({ value, definition, path })

  if (!map.has(entry)) {
    map.set(entry, 0)
  }

  map.set(entry, map.get(entry)! + 1)

  if (map.get(entry)! > limit) {
    throw new Error(`Field \`${path}\` has exceeded the maximum population limit (${limit}) in a single query`)
  }
}

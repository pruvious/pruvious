import type { BlockName, Fields, GenericDatabase } from '#pruvious/server'
import { blocks } from '#pruvious/server/blocks'
import {
  type ConditionalLogic,
  type Context,
  type DataType,
  type FieldDefinition,
  type GenericField,
} from '@pruvious/orm'
import { isArray, isObject, isString } from '@pruvious/utils'
import { hash } from 'ohash'

export type GenericFieldDefinition = FieldDefinition<
  any,
  any,
  boolean,
  boolean,
  boolean,
  boolean,
  ConditionalLogic | undefined,
  any
>

type BaseSerializableFieldOptions = Required<
  Pick<GenericFieldDefinition, 'nullable' | 'required' | 'immutable' | 'autoGenerated' | 'default' | 'dependencies'>
> &
  Pick<GenericFieldDefinition, 'conditionalLogic'> & {
    /**
     * The registered field type.
     */
    _fieldType: keyof Fields

    /**
     * The primitive data type of the field.
     * For top-level fields, this determines the database column type.
     *
     * Supported data types:
     *
     * - `bigint`
     * - `boolean`
     * - `numeric`
     * - `text`
     */
    _dataType: DataType

    /**
     * Indicates if the field has a populator function.
     */
    _hasPopulator: boolean
  }

export type SerializableFieldOptions<TField extends keyof Fields> = Readonly<
  BaseSerializableFieldOptions &
    Omit<Fields[TField]['options'], 'populator' | 'structure' | 'subfields'> &
    (Fields[TField]['options'] extends { structure: any }
      ? { structure: { [$key: string]: Record<string, GenericSerializableFieldOptions> } }
      : {}) &
    (Fields[TField]['options'] extends { subfields: any }
      ? { subfields: Record<string, GenericSerializableFieldOptions> }
      : {})
>

export type GenericSerializableFieldOptions = Readonly<BaseSerializableFieldOptions & Record<string, any>>

/**
 * Limits the population of a field to a maximum number of occurrences in a single query.
 * This function is useful to prevent infinite loops when populating fields that reference each other.
 *
 * @throws an error if the population limit is exceeded.
 */
export function limitPopulation(
  value: any,
  { definition, context, path }: { definition: GenericField; context: Context<GenericDatabase>; path: string },
  limit = 32,
) {
  if (!isObject(context.cache['_tmp'])) {
    context.cache['_tmp'] = {}
  }

  if (!(context.cache['_tmp']['_populationLimit'] instanceof Map)) {
    context.cache['_tmp']['_populationLimit'] = new Map()
  }

  const map = context.cache['_tmp']['_populationLimit'] as Map<any, number>
  const entry = hash({ value, definition, path })

  if (!map.has(entry)) {
    map.set(entry, 0)
  }

  map.set(entry, map.get(entry)! + 1)

  if (map.get(entry)! > limit) {
    throw new Error(`Field \`${path}\` has exceeded the maximum population limit (${limit}) in a single query`)
  }
}

/**
 * A function that returns a conditional logic parser for a list of `fields` (including block fields) and their `input` data.
 *
 * Returns an object where:
 *
 * - Keys are field paths (using dot notation for nested fields).
 * - Values are the corresponding conditional logic objects to evaluate (if present).
 */
export function parseConditionalLogic(
  fields: Record<string, Pick<GenericField, 'conditionalLogic' | 'model' | 'options'>>,
  input: Record<string, any>,
): Record<string, ConditionalLogic | undefined> {
  const parsedConditionalLogic: Record<string, ConditionalLogic | undefined> = {}

  for (const [fieldName, field] of Object.entries(fields)) {
    const item = input[fieldName]
    parsedConditionalLogic[fieldName] = field.conditionalLogic

    if (field.model.subfields) {
      if (isObject(item)) {
        for (const [sfp, sfpcl] of Object.entries(parseConditionalLogic(field.model.subfields, item))) {
          parsedConditionalLogic[`${fieldName}.${sfp}`] = sfpcl
        }
      } else if (isArray(item)) {
        for (const [index, arrayItem] of item.entries()) {
          if (isObject(arrayItem)) {
            for (const [sfp, sfpcl] of Object.entries(parseConditionalLogic(field.model.subfields, arrayItem))) {
              parsedConditionalLogic[`${fieldName}.${index}.${sfp}`] = sfpcl
            }
          }
        }
      }
    } else if (field.model.structure) {
      if (isArray(item)) {
        for (const [index, arrayItem] of item.entries()) {
          if (isObject(arrayItem)) {
            const subfields = isString(arrayItem.$key) ? field.model.structure[arrayItem.$key] : undefined
            if (subfields) {
              for (const [sfp, sfpcl] of Object.entries(parseConditionalLogic(subfields, arrayItem))) {
                parsedConditionalLogic[`${fieldName}.${index}.${sfp}`] = sfpcl
              }
            }
          }
        }
      }
    } else if (field.options._fieldType === 'blocks') {
      if (isArray(item)) {
        for (const [index, arrayItem] of item.entries()) {
          if (isObject(arrayItem)) {
            const block = isString(arrayItem.$key) ? blocks[arrayItem.$key as BlockName] : undefined
            if (block) {
              for (const [sfp, sfpcl] of Object.entries(parseConditionalLogic(block.fields, arrayItem))) {
                parsedConditionalLogic[`${fieldName}.${index}.${sfp}`] = sfpcl
              }
            }
          }
        }
      }
    }
  }

  return parsedConditionalLogic
}

/**
 * Parses fields from a list of serializable `fields` and some collection or singleton `data`.
 *
 * Returns an object where:
 *
 * - Keys are field paths (using dot notation for nested fields).
 * - Values are the corresponding field options.
 */
export function parseFields(
  fields: Record<string, GenericField>,
  input: Record<string, any>,
): Record<string, GenericField> {
  const parsedFields: Record<string, GenericField> = {}

  for (const [fieldName, field] of Object.entries(fields)) {
    const item = input[fieldName]
    parsedFields[fieldName] = field

    if (field.model.subfields) {
      if (isObject(item)) {
        for (const [sfp, sfpcl] of Object.entries(parseFields(field.model.subfields, item))) {
          parsedFields[`${fieldName}.${sfp}`] = sfpcl
        }
      } else if (isArray(item)) {
        for (const [index, arrayItem] of item.entries()) {
          if (isObject(arrayItem)) {
            for (const [sfp, sfpcl] of Object.entries(parseFields(field.model.subfields, arrayItem))) {
              parsedFields[`${fieldName}.${index}.${sfp}`] = sfpcl
            }
          }
        }
      }
    } else if (field.model.structure) {
      if (isArray(item)) {
        for (const [index, arrayItem] of item.entries()) {
          if (isObject(arrayItem)) {
            const subfields = isString(arrayItem.$key) ? field.model.structure[arrayItem.$key] : undefined
            if (subfields) {
              for (const [sfp, sfpcl] of Object.entries(parseFields(subfields, arrayItem))) {
                parsedFields[`${fieldName}.${index}.${sfp}`] = sfpcl
              }
            }
          }
        }
      }
    } else if (field.options._fieldType === 'blocks') {
      if (isArray(item)) {
        for (const [index, arrayItem] of item.entries()) {
          if (isObject(arrayItem)) {
            const block = isString(arrayItem.$key) ? blocks[arrayItem.$key as BlockName] : undefined
            if (block) {
              for (const [sfp, sfpcl] of Object.entries(parseFields(block.fields, arrayItem))) {
                parsedFields[`${fieldName}.${index}.${sfp}`] = sfpcl
              }
            }
          }
        }
      }
    }
  }

  return parsedFields
}

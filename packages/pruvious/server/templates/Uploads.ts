import {
  buttonGroupField,
  chipsField,
  defineTemplate,
  insertInto,
  numberField,
  resolveMediaCategory,
  selectField,
  selectFrom,
  switchField,
  textField,
  uniqueValidator,
  uploadPathValidator,
} from '#pruvious/server'
import { Field, objectFieldModel } from '@pruvious/orm'
import { isArray, isDefined, isNull, isObject, isPositiveInteger, isString, toArray } from '@pruvious/utils'
import mime from 'mime'
import { extname } from 'pathe'

function multipartField() {
  const field = new Field({
    model: objectFieldModel<{ key: string; parts: { partNumber: number; etag: string }[] }>(),
    options: {},
    validators: [
      (value, { context }) => {
        if (
          !isNull(value) &&
          (!isString(value.key) ||
            !isArray(value.parts) ||
            value.parts.some((part) => !isObject(part) || !isPositiveInteger(part.partNumber) || !isString(part.etag)))
        ) {
          return context.__('pruvious-orm', 'Invalid value')
        }
      },
    ],
  })

  ;(field as any).castedTypeFn = () => '{ key: string; parts: { partNumber: number, etag: string }[] }'
  ;(field as any).populatedTypeFn = () => '{ key: string; parts: { partNumber: number, etag: string }[] }'
  ;(field as any).inputTypeFn = () => '{ key: string; parts: { partNumber: number, etag: string }[] }'

  return field
}

export default defineTemplate(() => ({
  fields: {
    path: textField({
      required: true,
      validators: [
        uploadPathValidator(),
        (value, { context }) => {
          if (
            context.operation === 'insert' &&
            context.getSanitizedInputValue('type') === 'directory' &&
            value.includes('.')
          ) {
            throw new Error(context.__('pruvious-api', 'Invalid path'))
          }
          return 'The path must start with a slash'
        },
        uniqueValidator({ errorMessage: ({ __ }) => __('pruvious-api', 'The path must be unique') }),
      ],
      inputFilters: {
        beforeInputValidation: async (value, { context }) => {
          if (context.operation === 'insert' && isString(value) && context.getSanitizedInputValue('type') === 'file') {
            const ext = extname(value)
            let path = value
            let index = 0

            if (!isObject(context.cache['_tmp'])) {
              context.cache['_tmp'] = {}
            }

            if (!isArray(context.cache['_tmp']['_resolvedUploadsPaths'])) {
              context.cache['_tmp']['_resolvedUploadsPaths'] = []
            }

            while (true) {
              const uploadsCountQuery = await selectFrom('Uploads').where('path', '=', path).count()
              const existsInCache = context.cache['_tmp']['_resolvedUploadsPaths'].includes(path)
              if ((!uploadsCountQuery.success || uploadsCountQuery.data === 0) && !existsInCache) break
              path = (ext ? value.slice(0, -ext.length) : value) + `-${++index}` + ext
            }

            context.cache['_tmp']['_resolvedUploadsPaths'].push(path)

            return path
          }

          return value
        },
      },
    }),
    type: buttonGroupField({
      choices: [
        { value: 'directory', label: ({ __ }) => __('pruvious-api', 'Directory') },
        { value: 'file', label: ({ __ }) => __('pruvious-api', 'File') },
      ],
      required: true,
      immutable: true,
    }),
    level: numberField({
      autoGenerated: true,
      inputFilters: {
        beforeQueryExecution: (_, { context }) => {
          const path = context.getSanitizedInputValue('path')
          if (isDefined(path)) {
            return path.slice(1).split('/').length - 1
          }
        },
      },
    }),
    category: selectField({
      choices: [
        { value: 'documents', label: ({ __ }) => __('pruvious-dashboard', 'cat:documents') },
        { value: 'images', label: ({ __ }) => __('pruvious-dashboard', 'cat:images') },
        { value: 'audio', label: ({ __ }) => __('pruvious-dashboard', 'cat:audio') },
        { value: 'video', label: ({ __ }) => __('pruvious-dashboard', 'cat:video') },
        { value: 'archives', label: ({ __ }) => __('pruvious-dashboard', 'cat:archives') },
        { value: 'code', label: ({ __ }) => __('pruvious-dashboard', 'cat:code') },
        { value: 'fonts', label: ({ __ }) => __('pruvious-dashboard', 'cat:fonts') },
        { value: '3d', label: ({ __ }) => __('pruvious-dashboard', 'cat:3d') },
        { value: 'data', label: ({ __ }) => __('pruvious-dashboard', 'cat:data') },
        { value: 'system', label: ({ __ }) => __('pruvious-dashboard', 'cat:system') },
        { value: 'text', label: ({ __ }) => __('pruvious-dashboard', 'cat:text') },
        { value: 'other', label: ({ __ }) => __('pruvious-dashboard', 'cat:other') },
        { value: '', label: ({ __ }) => __('pruvious-dashboard', 'None') },
      ],
      autoGenerated: true,
      immutable: true,
      inputFilters: {
        beforeQueryExecution: {
          order: 11,
          callback: (_, { context }) => {
            if (context.operation === 'insert') {
              const mime = context.getSanitizedInputValue('mime')
              return mime ? resolveMediaCategory(mime) : ''
            }
          },
        },
      },
    }),
    mime: textField({
      autoGenerated: true,
      immutable: true,
      inputFilters: {
        beforeQueryExecution: (_, { context }) => {
          if (context.operation === 'insert') {
            const path = context.getSanitizedInputValue('path')
            const type = context.getSanitizedInputValue('type')
            if (type === 'file') {
              const ext = extname(path)
              return mime.getType(ext) || 'application/octet-stream'
            } else {
              return ''
            }
          }
        },
      },
    }),
    size: numberField({
      min: 0,
    }),
    etag: textField({}),
    images: chipsField({
      enforceUniqueItems: true,
    }),
    multipart: multipartField(),
    isLocked: switchField({}),
  },
  api: {
    create: false,
    update: false,
    delete: false,
  },
  author: true,
  editors: true,
  indexes: [{ fields: ['path'], unique: true }, { fields: ['type'] }, { fields: ['level'] }, { fields: ['category'] }],
  translatable: false,
  hooks: {
    beforeQueryExecution: [
      async ({ operation, customData }) => {
        if (operation !== 'select' && !customData._allowUploadsQueries) {
          throw new Error(
            'The `Uploads` collection should not be modified directly. Instead, use these functions to handle uploads: `putUpload`, `moveUpload`, `updateUpload`, `deleteUpload`',
          )
        }
      },
    ],
    afterQueryExecution: [
      async (context) => {
        if (context.operation === 'insert' || context.operation === 'update') {
          for (const item of toArray(context.sanitizedInput).values()) {
            const path = item.path as string

            if (path) {
              const parts = path.slice(1).split('/')

              while (parts.pop() && parts.length) {
                await insertInto('Uploads')
                  .values({ path: `/${parts.join('/')}`, type: 'directory' })
                  .withCustomContextData({ _allowUploadsQueries: true })
                  .run()
              }
            }
          }
        }
      },
    ],
  },
  ui: { hidden: true },
}))

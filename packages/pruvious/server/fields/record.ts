import {
  defineField,
  limitPopulation,
  type CombinedFieldOptions,
  type DynamicCollectionFieldTypes,
  type GenericDatabase,
  type ResolveFieldUIOptions,
} from '#pruvious/server'
import {
  numberFieldModel,
  type ConditionalLogic,
  type Field,
  type FieldModel,
  type NumberFieldModelOptions,
} from '@pruvious/orm'
import { isNull, type DefaultFalse, type NonEmptyArray } from '@pruvious/utils'
import type { PropType } from 'vue'

interface CustomOptions<
  TCollection extends keyof DynamicCollectionFieldTypes['Casted' | 'Populated'],
  TFields extends keyof DynamicCollectionFieldTypes['Casted' | 'Populated'][TCollection],
  TPopulate extends boolean | undefined,
> {
  /**
   * The collection name to fetch the record from.
   */
  collection: TCollection & string

  /**
   * Fields to return from the selected `collection` when populating this field.
   *
   * By default, only the 'id' field is returned.
   *
   * @default
   * ['id']
   */
  fields?: NonEmptyArray<TFields & string>

  /**
   * Controls whether to populate the selected `fields` from the related `collection`.
   *
   * Use this option with care to avoid infinite population loops that can occur when related fields require additional population chains.
   *
   * @default false
   */
  populate?: TPopulate
}

const customOptions: CustomOptions<any, string, boolean> = {
  collection: '',
  fields: ['id'],
  populate: false,
}

export default {
  /**
   * Creates a new `Field` instance.
   *
   * This function is intended for server-side use in collection definitions.
   * For client-side usage, import the equivalent function from `#pruvious/client`.
   */
  serverFn: function <
    const TRequired extends boolean | undefined,
    const TImmutable extends boolean | undefined,
    const TAutoGenerated extends boolean | undefined,
    TConditionalLogic extends ConditionalLogic | undefined,
    TCollection extends keyof DynamicCollectionFieldTypes['Casted' | 'Populated'],
    TFields extends keyof DynamicCollectionFieldTypes['Casted' | 'Populated'][TCollection],
    TPopulate extends boolean | undefined,
    TPopulatedType = Pick<
      DynamicCollectionFieldTypes[DefaultFalse<TPopulate> extends true ? 'Populated' : 'Casted'][TCollection],
      TFields
    >,
  >(
    options: Omit<
      CombinedFieldOptions<
        FieldModel<
          NumberFieldModelOptions<number, TPopulatedType>,
          'text',
          number,
          TPopulatedType,
          number | string,
          undefined
        >,
        NumberFieldModelOptions<number, TPopulatedType> &
          CustomOptions<TCollection, TFields, TPopulate> &
          ResolveFieldUIOptions<undefined>,
        true,
        TRequired,
        TImmutable,
        TAutoGenerated,
        TConditionalLogic,
        GenericDatabase
      >,
      'decimalPlaces' | 'min' | 'max'
    >,
  ): Field<
    FieldModel<
      NumberFieldModelOptions<number, TPopulatedType>,
      'text',
      number,
      TPopulatedType,
      number | string,
      undefined
    >,
    NumberFieldModelOptions<number, TPopulatedType> &
      CustomOptions<TCollection, TFields, TPopulate> &
      ResolveFieldUIOptions<undefined>,
    true,
    TRequired,
    TImmutable,
    TAutoGenerated,
    TConditionalLogic,
    GenericDatabase
  > {
    const bound = defineField({
      model: numberFieldModel<number, TPopulatedType>(),
      nullable: true,
      default: null,
      customOptions: { ...customOptions, min: 1 },
      validators: [
        async (value, { definition, context }) => {
          if (!isNull(value)) {
            const count = await context.database
              .queryBuilder()
              .selectFrom(definition.options.collection)
              .where('id', '=', value)
              .useCache(context.cache)
              .count()

            if (!count.success) {
              throw new Error(
                context.__('pruvious-api', `Failed to verify existence of ID \`$id\` in collection \`$collection\``, {
                  id: value,
                  collection: definition.options.collection,
                }),
              )
            } else if (count.data === 0) {
              throw new Error(context.__('pruvious-api', 'Record does not exist'))
            }
          }
        },
      ],
      populator: async (value, contextField) => {
        const { definition, context } = contextField
        const deepPopulate = definition.options.populate

        if (deepPopulate) {
          limitPopulation(value, contextField)
        }

        const queryBuilder = context.database
          .queryBuilder()
          .selectFrom(definition.options.collection)
          .where('id', '=', value)
          .select(definition.options.fields)
          .useCache(context.cache)

        if (deepPopulate) {
          queryBuilder.populate()
        }

        const query = await queryBuilder.first()

        return (query.success ? query.data : null) as any
      },
      omitOptions: ['decimalPlaces', 'min', 'max'],
      castedTypeFn: () => 'number',
      populatedTypeFn: ({ options }) =>
        `Pick<DynamicCollectionFieldTypes[${options.populate ? "'Populated'" : "'Casted'"}]['${options.collection}'], ${(options.fields ?? ['id']).map((field) => `'${field}'`).join(' | ')}>`,
    }).serverFn.bind(this)
    return bound(options as any) as any
  },

  /**
   * Creates a new `Field` instance.
   *
   * This function is intended for client-side use in Vue components.
   * For server-side usage, import the equivalent function from `#pruvious/server`.
   */
  clientFn: function <
    const TRequired extends boolean | undefined,
    const TImmutable extends boolean | undefined,
    const TAutoGenerated extends boolean | undefined,
    TConditionalLogic extends ConditionalLogic | undefined,
    TCollection extends keyof DynamicCollectionFieldTypes['Casted' | 'Populated'],
    TFields extends keyof DynamicCollectionFieldTypes['Casted' | 'Populated'][TCollection],
    TPopulate extends boolean | undefined,
    TPopulatedType = Pick<
      DynamicCollectionFieldTypes[DefaultFalse<TPopulate> extends true ? 'Populated' : 'Casted'][TCollection],
      TFields
    >,
  >(
    options: Omit<
      CombinedFieldOptions<
        FieldModel<
          NumberFieldModelOptions<number, TPopulatedType>,
          'text',
          number,
          TPopulatedType,
          number | string,
          undefined
        >,
        NumberFieldModelOptions<number, TPopulatedType> &
          CustomOptions<TCollection, TFields, TPopulate> &
          ResolveFieldUIOptions<undefined>,
        true,
        TRequired,
        TImmutable,
        TAutoGenerated,
        TConditionalLogic,
        GenericDatabase
      >,
      'decimalPlaces' | 'min' | 'max'
    >,
  ): { type: PropType<TPopulatedType>; required: true } & {
    field: Field<
      FieldModel<
        NumberFieldModelOptions<number, TPopulatedType>,
        'text',
        number,
        TPopulatedType,
        number | string,
        undefined
      >,
      NumberFieldModelOptions<number, TPopulatedType> &
        CustomOptions<TCollection, TFields, TPopulate> &
        ResolveFieldUIOptions<undefined>,
      true,
      TRequired,
      TImmutable,
      TAutoGenerated,
      TConditionalLogic,
      GenericDatabase
    >
  } {
    return null as any
  },

  /**
   * Represents the type structure for this field's configuration options.
   *
   * Note: This is a TypeScript type assertion and does not involve any runtime logic or data.
   */
  TOptions: undefined as unknown as Omit<
    CombinedFieldOptions<
      FieldModel<
        NumberFieldModelOptions<number, Record<string, any>>,
        'text',
        number,
        Record<string, any>,
        number | string,
        undefined
      >,
      NumberFieldModelOptions<number, Record<string, any>> &
        CustomOptions<keyof DynamicCollectionFieldTypes['Casted' | 'Populated'], any, boolean | undefined> &
        ResolveFieldUIOptions<undefined>,
      true,
      boolean,
      boolean,
      boolean,
      ConditionalLogic | undefined,
      GenericDatabase
    >,
    'decimalPlaces' | 'min' | 'max'
  >,
}

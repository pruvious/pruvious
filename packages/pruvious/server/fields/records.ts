import {
  defineField,
  limitPopulation,
  type CombinedFieldOptions,
  type DynamicCollectionFieldTypes,
  type GenericDatabase,
  type ResolveFieldUIOptions,
} from '#pruvious/server'
import {
  matrixFieldModel,
  type ConditionalLogic,
  type Field,
  type FieldModel,
  type MatrixFieldModelOptions,
} from '@pruvious/orm'
import { isEmpty, isPositiveInteger, type DefaultFalse, type NonEmptyArray } from '@pruvious/utils'
import type { PropType } from 'vue'

interface CustomOptions<
  TCollection extends keyof DynamicCollectionFieldTypes['Casted' | 'Populated'],
  TFields extends keyof DynamicCollectionFieldTypes['Casted' | 'Populated'][TCollection],
  TPopulate extends boolean | undefined,
> {
  /**
   * The collection name to fetch records from.
   */
  collection: TCollection & string

  /**
   * Fields to return from the selected `collection` when populating this field.
   *
   * By default, only the 'id' field is returned.
   *
   * @default
   * ['id']
   */
  fields?: NonEmptyArray<TFields & string>

  /**
   * Controls whether to populate the selected `fields` from the related `collection`.
   *
   * Use this option with care to avoid infinite population loops that can occur when related fields require additional population chains.
   *
   * @default false
   */
  populate?: TPopulate
}

const customOptions: CustomOptions<any, string, boolean> = {
  collection: '',
  fields: ['id'],
  populate: false,
}

export default {
  /**
   * Creates a new `Field` instance.
   *
   * This function is intended for server-side use in collection definitions.
   * For client-side usage, import the equivalent function from `#pruvious/client`.
   */
  serverFn: function <
    const TRequired extends boolean | undefined,
    const TImmutable extends boolean | undefined,
    const TAutoGenerated extends boolean | undefined,
    TConditionalLogic extends ConditionalLogic | undefined,
    TCollection extends keyof DynamicCollectionFieldTypes['Casted' | 'Populated'],
    TFields extends keyof DynamicCollectionFieldTypes['Casted' | 'Populated'][TCollection],
    TPopulate extends boolean | undefined,
    TPopulatedType = Pick<
      DynamicCollectionFieldTypes[DefaultFalse<TPopulate> extends true ? 'Populated' : 'Casted'][TCollection],
      TFields
    >[],
  >(
    options: CombinedFieldOptions<
      FieldModel<
        MatrixFieldModelOptions<number[], TPopulatedType>,
        'text',
        number[],
        TPopulatedType,
        (number | string)[],
        undefined,
        undefined
      >,
      MatrixFieldModelOptions<number[], TPopulatedType> &
        CustomOptions<TCollection, TFields, TPopulate> &
        ResolveFieldUIOptions<undefined>,
      false,
      TRequired,
      TImmutable,
      TAutoGenerated,
      TConditionalLogic,
      GenericDatabase
    >,
  ): Field<
    FieldModel<
      MatrixFieldModelOptions<number[], TPopulatedType>,
      'text',
      number[],
      TPopulatedType,
      (number | string)[],
      undefined,
      undefined
    >,
    MatrixFieldModelOptions<number[], TPopulatedType> &
      CustomOptions<TCollection, TFields, TPopulate> &
      ResolveFieldUIOptions<undefined>,
    false,
    TRequired,
    TImmutable,
    TAutoGenerated,
    TConditionalLogic,
    GenericDatabase
  > {
    const bound = defineField({
      model: matrixFieldModel<'number', number, number[], TPopulatedType>(),
      customOptions,
      validators: [
        (value, { context, path }, errors) => {
          let hasErrors = false

          for (const [i, id] of value.entries()) {
            if (!isPositiveInteger(id)) {
              errors[`${path}.${i}`] = context.__('pruvious-api', 'The ID must be a positive integer')
              hasErrors = true
            }
          }

          if (hasErrors) {
            throw new Error(context.__('pruvious-orm', 'This field contains invalid values'))
          }
        },
        async (value, { definition, context, path }, errors) => {
          let hasErrors = false

          if (!isEmpty(value)) {
            const chunks: number[][] = []

            for (let i = 0; i < value.length; i += 80) {
              chunks.push(value.slice(i, i + 80))
            }

            const queries = await Promise.all(
              chunks.map((chunk) =>
                context.database
                  .queryBuilder()
                  .selectFrom(definition.options.collection)
                  .select('id')
                  .where('id', 'in', chunk)
                  .select(definition.options.fields)
                  .useCache(context.cache)
                  .all(),
              ),
            )

            if (queries.every((query) => query.success)) {
              const ids: number[] = queries.flatMap((query) => query.data.map((record) => record.id))

              for (const [i, id] of value.entries()) {
                if (!ids.includes(id)) {
                  errors[`${path}.${i}`] = context.__('pruvious-api', 'Record does not exist')
                  hasErrors = true
                }
              }
            } else {
              const runtimeError = queries.find((query) => query.runtimeError)?.runtimeError

              if (runtimeError) {
                errors[path] = runtimeError
                hasErrors = true
              } else {
                errors[path] = context.__('pruvious-orm', 'An unknown error occurred')
                hasErrors = true
              }
            }
          }

          if (hasErrors) {
            throw new Error(
              context.__('pruvious-api', 'This field contains IDs that do not exist in the related collection'),
            )
          }
        },
      ],
      populator: async (value, contextField) => {
        if (!isEmpty(value)) {
          const { definition, context } = contextField
          const deepPopulate = definition.options.populate

          if (definition.options.fields.length === 1 && definition.options.fields[0] === 'id') {
            return value.map((id) => ({ id }))
          }

          if (deepPopulate) {
            limitPopulation(value, contextField)
          }

          const chunks: number[][] = []

          for (let i = 0; i < value.length; i += 80) {
            chunks.push(value.slice(i, i + 80))
          }

          const queries = await Promise.all(
            chunks.map((chunk) => {
              const queryBuilder = context.database
                .queryBuilder()
                .selectFrom(definition.options.collection)
                .where('id', 'in', chunk)
                .select(definition.options.fields)
                .useCache(context.cache)
              return deepPopulate ? queryBuilder.populate().all() : queryBuilder.all()
            }),
          )

          if (queries.every((query) => query.success)) {
            return queries.flatMap((query) => query.data) as any
          }
        }

        return []
      },
      castedTypeFn: () => 'number[]',
      populatedTypeFn: ({ field }) =>
        `Pick<DynamicCollectionFieldTypes[${field.options.populate ? "'Populated'" : "'Casted'"}]['${field.options.collection}'], ${(field.options.fields ?? ['id']).map((fieldName) => `'${fieldName}'`).join(' | ')}>[]`,
      inputTypeFn: () => '(number | string)[]',
    }).serverFn.bind(this)
    return bound(options as any) as any
  },

  /**
   * Creates a new `Field` instance.
   *
   * This function is intended for client-side use in Vue components.
   * For server-side usage, import the equivalent function from `#pruvious/server`.
   */
  clientFn: function <
    const TRequired extends boolean | undefined,
    const TImmutable extends boolean | undefined,
    const TAutoGenerated extends boolean | undefined,
    TConditionalLogic extends ConditionalLogic | undefined,
    TCollection extends keyof DynamicCollectionFieldTypes['Casted' | 'Populated'],
    TFields extends keyof DynamicCollectionFieldTypes['Casted' | 'Populated'][TCollection],
    TPopulate extends boolean | undefined,
    TPopulatedType = Pick<
      DynamicCollectionFieldTypes[DefaultFalse<TPopulate> extends true ? 'Populated' : 'Casted'][TCollection],
      TFields
    >[],
  >(
    options: CombinedFieldOptions<
      FieldModel<
        MatrixFieldModelOptions<number[], TPopulatedType>,
        'text',
        number[],
        TPopulatedType,
        (number | string)[],
        undefined,
        undefined
      >,
      MatrixFieldModelOptions<number[], TPopulatedType> &
        CustomOptions<TCollection, TFields, TPopulate> &
        ResolveFieldUIOptions<undefined>,
      false,
      TRequired,
      TImmutable,
      TAutoGenerated,
      TConditionalLogic,
      GenericDatabase
    >,
  ): { type: PropType<TPopulatedType>; required: true } & {
    field: Field<
      FieldModel<
        MatrixFieldModelOptions<number[], TPopulatedType>,
        'text',
        number[],
        TPopulatedType,
        (number | string)[],
        undefined,
        undefined
      >,
      MatrixFieldModelOptions<number[], TPopulatedType> &
        CustomOptions<TCollection, TFields, TPopulate> &
        ResolveFieldUIOptions<undefined>,
      false,
      TRequired,
      TImmutable,
      TAutoGenerated,
      TConditionalLogic,
      GenericDatabase
    >
  } {
    return null as any
  },

  /**
   * Represents the type structure for this field's configuration options.
   *
   * Note: This is a TypeScript type assertion and does not involve any runtime logic or data.
   */
  TOptions: undefined as unknown as CombinedFieldOptions<
    FieldModel<
      MatrixFieldModelOptions<number[], Record<string, any>[]>,
      'text',
      number[],
      Record<string, any>[],
      (number | string)[],
      undefined,
      undefined
    >,
    MatrixFieldModelOptions<number[], Record<string, any>[]> &
      CustomOptions<keyof DynamicCollectionFieldTypes['Casted' | 'Populated'], any, boolean | undefined> &
      ResolveFieldUIOptions<undefined>,
    false,
    boolean,
    boolean,
    boolean,
    ConditionalLogic | undefined,
    GenericDatabase
  >,
}

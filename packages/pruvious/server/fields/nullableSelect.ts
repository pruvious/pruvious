import {
  type CombinedFieldOptions,
  defineField,
  type GenericDatabase,
  type ResolveFieldUIOptions,
  type TranslatableStringCallbackContext,
} from '#pruvious/server'
import {
  type ConditionalLogic,
  type Field,
  type FieldModel,
  textFieldModel,
  type TextFieldModelOptions,
} from '@pruvious/orm'
import { type ExtractValues, isNotNull } from '@pruvious/utils'
import type { PropType } from 'vue'
import type { SelectChoice, SelectChoiceGroup } from './select'

interface CustomOptions<TChoices extends (SelectChoice | SelectChoiceGroup)[]> {
  /**
   * The choices available for the select field.
   * Each choice must have a unique `value`.
   *
   * @example
   * ```ts
   * choices: [
   *   { label: 'Yes', value: 'yes' },
   *   { label: 'No', value: 'no' },
   * ]
   * ```
   */
  choices: TChoices

  ui?: {
    /**
     * Defines the label for the first choice value (`null`).
     * By default, this is an empty string.
     *
     * You can either provide a string or a function that returns a string.
     * The function receives an object with `_` and `__` properties to access the translation functions.
     *
     * Important: When using a function, only use simple anonymous functions without context binding,
     * since the option needs to be serialized for client-side use.
     *
     * @example
     * ```ts
     * // String (non-translatable)
     * label: 'None'
     *
     * // Function (translatable)
     * label: ({ __ }) => __('pruvious-dashboard', 'None')
     * ```
     *
     * @default ''
     */
    nullChoiceLabel?: string | ((context: TranslatableStringCallbackContext) => string)

    /**
     * Controls whether the first choice value (`null`) appears in muted color in the UI.
     *
     * @default true
     */
    nullChoiceMuted?: boolean
  }
}

const customOptions: CustomOptions<(SelectChoice | SelectChoiceGroup)[]> = {
  choices: [],
  ui: {
    nullChoiceLabel: '',
    nullChoiceMuted: true,
  },
}

export default {
  /**
   * Creates a new `Field` instance.
   *
   * This function is intended for server-side use in collection definitions.
   * For client-side usage, import the equivalent function from `#pruvious/client`.
   */
  serverFn: function <
    const TRequired extends boolean | undefined,
    const TImmutable extends boolean | undefined,
    const TAutoGenerated extends boolean | undefined,
    TConditionalLogic extends ConditionalLogic | undefined,
    const TChoices extends (SelectChoice | SelectChoiceGroup)[],
    const TValues extends ExtractValues<TChoices> = ExtractValues<TChoices>, // @todo flatten SelectChoiceGroup (test with `default` value)
  >(
    options: Omit<
      CombinedFieldOptions<
        FieldModel<
          TextFieldModelOptions<TValues, TValues>,
          'text',
          NoInfer<TValues>,
          TValues,
          TValues,
          undefined,
          undefined
        >,
        TextFieldModelOptions<TValues, TValues> &
          CustomOptions<TChoices> &
          ResolveFieldUIOptions<{ placeholder: true }>,
        true,
        TRequired,
        TImmutable,
        TAutoGenerated,
        TConditionalLogic,
        GenericDatabase
      >,
      'allowEmptyString' | 'maxLength' | 'minLength' | 'trim'
    >,
  ): Field<
    FieldModel<TextFieldModelOptions<TValues, TValues>, 'text', TValues, TValues, TValues, undefined, undefined>,
    TextFieldModelOptions<TValues, TValues> & CustomOptions<TChoices> & ResolveFieldUIOptions<{ placeholder: true }>,
    true,
    TRequired,
    TImmutable,
    TAutoGenerated,
    TConditionalLogic,
    GenericDatabase
  > {
    const flattenedChoices = options.choices.flatMap((choice) => ('value' in choice ? [choice] : choice.choices))

    const bound = defineField({
      model: textFieldModel(),
      nullable: true,
      default: null,
      validators: [
        (value, { context }) => {
          if (isNotNull(value) && !flattenedChoices.some((choice) => choice.value === value)) {
            throw new Error(context.__('pruvious-orm', 'Invalid value'))
          }
        },
      ],
      customOptions: { ...customOptions, trim: false },
      uiOptions: { placeholder: true },
      omitOptions: ['allowEmptyString', 'maxLength', 'minLength', 'trim'],
      castedTypeFn: () =>
        flattenedChoices.map((choice) => `'${choice.value.replaceAll("'", "\\'")}'`).join(' | ') + ' | null',
      populatedTypeFn: () =>
        flattenedChoices.map((choice) => `'${choice.value.replaceAll("'", "\\'")}'`).join(' | ') + ' | null',
      inputTypeFn: () =>
        flattenedChoices.map((choice) => `'${choice.value.replaceAll("'", "\\'")}'`).join(' | ') + ' | null',
    }).serverFn.bind(this)
    return bound(options as any) as any
  },

  /**
   * Creates a new `Field` instance.
   *
   * This function is intended for client-side use in Vue components.
   * For server-side usage, import the equivalent function from `#pruvious/server`.
   */
  clientFn: function <
    const TRequired extends boolean | undefined,
    const TImmutable extends boolean | undefined,
    const TAutoGenerated extends boolean | undefined,
    TConditionalLogic extends ConditionalLogic | undefined,
    const TChoices extends (SelectChoice | SelectChoiceGroup)[],
    const TValues extends ExtractValues<TChoices> = ExtractValues<TChoices>,
  >(
    options: Omit<
      CombinedFieldOptions<
        FieldModel<
          TextFieldModelOptions<TValues, TValues>,
          'text',
          NoInfer<TValues>,
          TValues,
          TValues,
          undefined,
          undefined
        >,
        TextFieldModelOptions<TValues, TValues> &
          CustomOptions<TChoices> &
          ResolveFieldUIOptions<{ placeholder: true }>,
        true,
        TRequired,
        TImmutable,
        TAutoGenerated,
        TConditionalLogic,
        GenericDatabase
      >,
      'allowEmptyString' | 'maxLength' | 'minLength' | 'trim'
    >,
  ): { type: PropType<TValues>; required: true } & {
    field: Field<
      FieldModel<TextFieldModelOptions<TValues, TValues>, 'text', TValues, TValues, TValues, undefined, undefined>,
      TextFieldModelOptions<TValues, TValues> & CustomOptions<TChoices> & ResolveFieldUIOptions<{ placeholder: true }>,
      true,
      TRequired,
      TImmutable,
      TAutoGenerated,
      TConditionalLogic,
      GenericDatabase
    >
  } {
    return null as any
  },

  /**
   * Represents the type structure for this field's configuration options.
   *
   * Note: This is a TypeScript type assertion and does not involve any runtime logic or data.
   */
  TOptions: undefined as unknown as Omit<
    CombinedFieldOptions<
      FieldModel<TextFieldModelOptions<string, string>, 'text', string, string, string, undefined, undefined>,
      TextFieldModelOptions<string, string> &
        CustomOptions<(SelectChoice | SelectChoiceGroup)[]> &
        ResolveFieldUIOptions<{ placeholder: true }>,
      true,
      boolean,
      boolean,
      boolean,
      ConditionalLogic | undefined,
      GenericDatabase
    >,
    'allowEmptyString' | 'maxLength' | 'minLength' | 'trim'
  >,
}

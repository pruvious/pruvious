import {
  collections,
  hasCollectionPermission,
  hasPermission,
  hasSingletonPermission,
  isLoggedIn,
  serializeTranslatableStringCallbacks,
  singletons,
  type Collections,
  type GenericSerializableFieldOptions,
  type PruviousDashboardState,
  type Singletons,
} from '#pruvious/server'
import { isArray, isObject, omit, pick } from '@pruvious/utils'

export default defineEventHandler(() => {
  const runtimeConfig = useRuntimeConfig()
  const state: PruviousDashboardState = {
    collections: {},
    singletons: {},
    logs: null,
  }

  if (isLoggedIn()) {
    // Collections
    for (const [name, collection] of Object.entries(collections)) {
      if (
        collection.meta.api.read &&
        (!collection.meta.authGuard.includes('read') || hasCollectionPermission(name as keyof Collections, 'read'))
      ) {
        state.collections[name] = {
          translatable: collection.meta.translatable,
          syncedFields: collection.meta.syncedFields as string[],
          copyTranslation: !!collection.meta.copyTranslation,
          duplicate: !!collection.meta.duplicate,
          createdAtField: collection.meta.createdAt.enabled,
          updatedAtField: collection.meta.updatedAt.enabled,
          authorField: collection.meta.author.enabled,
          editorsField: collection.meta.editors.enabled,
          fields: serializeFields(collection.fields),
          api: collection.meta.api as any,
          ui: serializeTranslatableStringCallbacks(collection.meta.ui),
        }

        state.collections[name].fields.id = {
          nullable: false,
          required: false,
          immutable: true,
          autoGenerated: true,
          default: 1,
          dependencies: [],
          decimalPlaces: 0,
          max: Number.MAX_SAFE_INTEGER,
          min: 1,
          ui: { hidden: true, label: 'EVAL::({ __ }) => __("pruvious-dashboard", "ID")' },
          _fieldType: 'number',
          _dataType: 'bigint',
        }
      }
    }

    // Singletons
    for (const [name, singleton] of Object.entries(singletons)) {
      if (
        singleton.api.read &&
        (!singleton.authGuard.includes('read') || hasSingletonPermission(name as keyof Singletons, 'read'))
      ) {
        state.singletons[name] = {
          translatable: singleton.translatable,
          syncedFields: singleton.syncedFields,
          copyTranslation: !!singleton.copyTranslation,
          fields: serializeFields(singleton.fields),
          api: singleton.api as any,
          ui: serializeTranslatableStringCallbacks(singleton.ui),
        }
      }
    }

    // Logs
    if (hasPermission('read-logs')) {
      state.logs = {
        api: runtimeConfig.pruvious.debug.logs.api.enabled,
        queries: runtimeConfig.pruvious.debug.logs.queries.enabled,
        queue: runtimeConfig.pruvious.debug.logs.queue,
        custom: runtimeConfig.pruvious.debug.logs.custom,
      }
    }
  }

  return state
})

function serializeFields(fields: Record<string, any>): Record<string, GenericSerializableFieldOptions> {
  const serialized: Record<string, GenericSerializableFieldOptions> = {}

  for (const [fieldName, field] of Object.entries(fields)) {
    serialized[fieldName] = {
      ...pick(field, [
        'nullable',
        'required',
        'immutable',
        'autoGenerated',
        'default',
        'conditionalLogic',
        'dependencies',
      ]),
      ...serializeTranslatableStringCallbacks({
        ...omit(field.options, ['populator', 'structure', 'subfields']),
        structure: isObject(field.options.structure) ? serializeFields(field.options.structure) : undefined,
        subfields: isObject(field.options.subfields)
          ? serializeFields(field.options.subfields)
          : isArray(field.options.subfields)
            ? field.options.subfields.map(serializeFields)
            : undefined,
      }),
    } as any
  }

  return serialized
}

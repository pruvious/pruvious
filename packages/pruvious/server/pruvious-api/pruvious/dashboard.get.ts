import {
  collections,
  hasCollectionPermission,
  hasPermission,
  hasSingletonPermission,
  isLoggedIn,
  serializeTranslatableStringCallbacks,
  singletons,
  type Collections,
  type PruviousDashboardState,
  type Singletons,
} from '#pruvious/server'
import { omit, pick } from '@pruvious/utils'

export default defineEventHandler(() => {
  const runtimeConfig = useRuntimeConfig()
  const state: PruviousDashboardState = {
    collections: {},
    singletons: {},
    logs: null,
  }

  if (isLoggedIn()) {
    // Collections
    for (const [name, collection] of Object.entries(collections)) {
      if (
        collection.meta.api.read &&
        (!collection.meta.authGuard.includes('read') || hasCollectionPermission(name as keyof Collections, 'read'))
      ) {
        state.collections[name] = {
          translatable: collection.meta.translatable,
          syncedFields: collection.meta.syncedFields as string[],
          copyTranslation: !!collection.meta.copyTranslation,
          duplicate: !!collection.meta.duplicate,
          createdAtField: collection.meta.createdAt.enabled ? collection.meta.createdAt.fieldName : null,
          updatedAtField: collection.meta.updatedAt.enabled ? collection.meta.updatedAt.fieldName : null,
          authorField: collection.meta.author.enabled ? collection.meta.author.fieldName : null,
          editorsField: collection.meta.editors.enabled ? collection.meta.editors.fieldName : null,
          fields: {},
          api: collection.meta.api as any,
          ui: serializeTranslatableStringCallbacks(collection.meta.ui),
        }

        for (const [fieldName, field] of Object.entries(collection.fields)) {
          state.collections[name].fields[fieldName] = {
            ...pick(field, [
              'nullable',
              'required',
              'immutable',
              'autoGenerated',
              'default',
              'conditionalLogic',
              'dependencies',
            ]),
            ...serializeTranslatableStringCallbacks(omit(field.options, ['populator'])),
          } as any
        }
      }
    }

    // Singletons
    for (const [name, singleton] of Object.entries(singletons)) {
      if (
        singleton.api.read &&
        (!singleton.authGuard.includes('read') || hasSingletonPermission(name as keyof Singletons, 'read'))
      ) {
        state.singletons[name] = {
          translatable: singleton.translatable,
          syncedFields: singleton.syncedFields,
          copyTranslation: !!singleton.copyTranslation,
          fields: {},
          api: singleton.api as any,
          ui: serializeTranslatableStringCallbacks(singleton.ui),
        }

        for (const [fieldName, field] of Object.entries(singleton.fields)) {
          state.singletons[name].fields[fieldName] = {
            ...pick(field, [
              'nullable',
              'required',
              'immutable',
              'autoGenerated',
              'default',
              'conditionalLogic',
              'dependencies',
            ]),
            ...serializeTranslatableStringCallbacks(omit(field.options, ['populator'])),
          } as any
        }
      }
    }

    // Logs
    if (hasPermission('read-logs')) {
      state.logs = {
        api: runtimeConfig.pruvious.debug.logs.api.enabled,
        queries: runtimeConfig.pruvious.debug.logs.queries.enabled,
        queue: runtimeConfig.pruvious.debug.logs.queue,
        custom: runtimeConfig.pruvious.debug.logs.custom,
      }
    }
  }

  return state
})

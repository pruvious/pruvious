<template>
  <component
    :conditionalLogic="conditionalLogic"
    :conditionalLogicResolver="conditionalLogicResolver"
    :data="data"
    :dataContainerName="dataContainerName"
    :dataContainerType="dataContainerType"
    :disabled="disabled || options.autoGenerated || (options.immutable && operation === 'update')"
    :error="props.error"
    :fields="fields"
    :is="component"
    :modelValue="modelValue"
    :name="name"
    :operation="operation"
    :options="props.options"
    :path="path"
    :rootPath="rootPath"
    :synced="synced"
    :translatable="translatable"
    :type="type"
    @commit="$emit('commit', $event)"
    @queueConditionalLogicUpdate="$emit('queueConditionalLogicUpdate', $event)"
    @update:conditionalLogic="$emit('update:conditionalLogic', $event)"
    @update:modelValue="$emit('update:modelValue', $event)"
  />
</template>

<script lang="ts" setup>
import { customComponents, fieldComponents } from '#pruvious/client'
import type {
  Collections,
  Fields,
  GenericFieldUIOptions,
  GenericSerializableFieldOptions,
  Singletons,
} from '#pruvious/server'
import type { ConditionalLogicResolver } from '@pruvious/orm'
import { isDefined, isStringInteger } from '@pruvious/utils'

const props = defineProps({
  /**
   * The field value.
   */
  modelValue: {
    type: null as unknown as PropType<any>,
    required: true,
  },

  /**
   * The field name defined in a collection, singleton, or block.
   */
  name: {
    type: String,
    required: true,
  },

  /**
   * The field type (e.g. `text`, `image`, `repeater`, etc.).
   */
  type: {
    type: String as PropType<keyof Fields>,
    required: true,
  },

  /**
   * The combined field options defined in a collection, singleton, or block.
   */
  options: {
    type: Object as PropType<GenericSerializableFieldOptions>,
    required: true,
  },

  /**
   * Defines whether this data container is a `collection` (manages multiple items) or a `singleton` (manages a single item).
   */
  dataContainerType: {
    type: String as PropType<'collection' | 'singleton'>,
    required: true,
  },

  /**
   * The name of the data container in PascalCase format.
   */
  dataContainerName: {
    type: String as PropType<keyof Collections | keyof Singletons>,
    required: true,
  },

  /**
   * The current record data from a collection or singleton.
   * Contains key-value pairs representing the record's fields and their values.
   */
  data: {
    type: Object as PropType<Record<string, any>>,
  },

  /**
   * A key-value pair of (sub)field names and their combined options defined in a collection, singleton, block, or field.
   */
  fields: {
    type: Object as PropType<Record<string, GenericSerializableFieldOptions>>,
  },

  /**
   * The field path, expressed in dot notation, represents the exact location of the field within the current data structure.
   */
  path: {
    type: String,
    required: true,
  },

  /**
   * Specifies the root path in dot notation for the current `fields` that will be shown.
   * Only displays fields that are nested under this base path.
   *
   * @default ''
   */
  rootPath: {
    type: String,
    default: '',
  },

  /**
   * A resolver instance that handles conditional logic evaluation for `fields` and their associated `data`.
   * This resolver determines field visibility, validation rules, and other dynamic behaviors based on defined conditions.
   */
  conditionalLogicResolver: {
    type: Object as PropType<ConditionalLogicResolver>,
  },

  /**
   * Stores the evaluation results of conditional logic for form fields.
   * The object uses dot-notation field paths as keys (e.g. `repeater.0.field`) and boolean values indicating if the condition is met.
   */
  conditionalLogic: {
    type: Object as PropType<Record<string, boolean>>,
  },

  /**
   * Represents an error message that can be displayed to the user.
   * Accepts either a simple string message or an object containing multiple error messages.
   */
  error: {
    type: [String, Object] as PropType<string | Record<string, string>>,
  },

  /**
   * Controls whether the field is disabled.
   *
   * The field becomes disabled automatically when:
   *
   * - `options.autoGenerated` is `true`
   * - `options.immutable` is `true` and `operation` is `'update'`
   *
   * @default false
   */
  disabled: {
    type: Boolean,
    default: false,
  },

  /**
   * Specifies whether the current data record is translatable.
   *
   * @default false
   */
  translatable: {
    type: Boolean,
    default: false,
  },

  /**
   * Indicates if the field value remains synchronized between all translations of the current data record.
   *
   * @default false
   */
  synced: {
    type: Boolean,
    default: false,
  },

  /**
   * The current operation being performed.
   */
  operation: {
    type: String as PropType<'create' | 'update'>,
  },
})

defineEmits<{
  'commit': [value: any]
  'update:modelValue': [value: any]
  'update:conditionalLogic': [value: Record<string, boolean>]
  'queueConditionalLogicUpdate': [path?: (string & {}) | string[] | '$resolve' | '$reset']
}>()

const component = shallowRef<Component | string>()
let key = ''

watch(
  () => [props.dataContainerType, props.dataContainerName, props.path, props.options, props.name, props.type],
  () => {
    const primaryPath = `${props.dataContainerType}s/${props.dataContainerName}/${props.path.replaceAll('.', '/')}`
    const secondaryPath = primaryPath
      .split('/')
      .map((part) => (isStringInteger(part) ? '[n]' : part))
      .join('/')

    if (fieldComponents[primaryPath]) {
      if (key !== `fieldComponents:${primaryPath}`) {
        key = `fieldComponents:${primaryPath}`
        component.value = fieldComponents[primaryPath]()
      }
      return
    } else if (fieldComponents[`${primaryPath}.regular`]) {
      if (key !== `fieldComponents:${primaryPath}.regular`) {
        key = `fieldComponents:${primaryPath}.regular`
        component.value = fieldComponents[`${primaryPath}.regular`]!()
      }
      return
    } else if (fieldComponents[secondaryPath]) {
      if (key !== `fieldComponents:${secondaryPath}`) {
        key = `fieldComponents:${secondaryPath}`
        component.value = fieldComponents[secondaryPath]()
      }
      return
    } else if (fieldComponents[`${secondaryPath}.regular`]) {
      if (key !== `fieldComponents:${secondaryPath}.regular`) {
        key = `fieldComponents:${secondaryPath}.regular`
        component.value = fieldComponents[`${secondaryPath}.regular`]!()
      }
      return
    }

    const customComponent = ((props.options as any).ui as GenericFieldUIOptions | undefined)?.customComponent
    if (customComponent) {
      if (isDefined(customComponents[customComponent])) {
        if (key !== `customComponents:${customComponent}`) {
          key = `customComponents:${customComponent}`
          component.value = customComponents[customComponent]()
        }
      } else {
        console.warn(
          `Unable to resolve custom component \`${customComponent}\` for field \`${props.name}\` in \`${props.dataContainerName}\` ${props.dataContainerType}. Available custom components:`,
          toRaw(customComponents),
        )
      }
      return
    }

    if (isDefined(fieldComponents[props.type])) {
      if (key !== `fieldComponents:${props.type}`) {
        key = `fieldComponents:${props.type}`
        component.value = fieldComponents[props.type]!()
      }
      return
    } else {
      if (key !== 'fieldFallback') {
        key = 'fieldFallback'
        component.value = resolveComponent('PruviousFieldFallback')
      }
    }
  },
  { immediate: true },
)
</script>

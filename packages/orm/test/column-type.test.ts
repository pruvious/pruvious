import { expect, test } from 'vitest'
import { canChangeColumnType, Database } from '../src'
import { createMiniflare, pgConnection, sqliteConnectionString } from './utils'

test('bigint column type', async () => {
  // SQLite
  const sqlite = new Database({ driver: sqliteConnectionString('bigint_column_type') })
  await sqlite.connect()
  await sqlite.createTable('Foo')
  await sqlite.createColumn('Foo', 'bar', 'bigint')
  expect(await sqlite.exec(`insert into "Foo" (bar) values (1)`)).toBe(1)
  await expect(() => sqlite.exec(`insert into "Foo" (bar) values ('baz')`)).rejects.toThrow()
  await expect(() => sqlite.exec(`insert into "Foo" (bar) values (1.1)`)).rejects.toThrow()
  expect(await sqlite.exec(`select * from "Foo"`)).toMatchObject([{ bar: 1 }])
  await sqlite.close()

  // PostgreSQL
  const { pgConnectionString, PGPool, drop } = await pgConnection('bigint_column_type')
  const pg = new Database({ driver: pgConnectionString, PGPool })
  await pg.connect()
  await pg.createTable('Foo')
  await pg.createColumn('Foo', 'bar', 'bigint')
  expect(await pg.exec(`insert into "Foo" (bar) values (1)`)).toBe(1)
  await expect(() => pg.exec(`insert into "Foo" (bar) values ('baz')`)).rejects.toThrow()
  await expect(() => pg.exec(`insert into "Foo" (bar) values (true)`)).rejects.toThrow()
  expect(await pg.exec(`select * from "Foo"`)).toMatchObject([{ bar: '1' }])
  await pg.close()
  await drop()

  // D1
  const { mf, db } = await createMiniflare()
  const d1 = new Database({ driver: db })
  await d1.connect()
  await d1.createTable('Foo')
  await d1.createColumn('Foo', 'bar', 'bigint')
  expect(await d1.exec(`insert into "Foo" (bar) values (1)`)).toBe(1)
  await expect(() => d1.exec(`insert into "Foo" (bar) values ('baz')`)).rejects.toThrow()
  await expect(() => d1.exec(`insert into "Foo" (bar) values (1.1)`)).rejects.toThrow()
  expect(await d1.exec(`select * from "Foo"`)).toMatchObject([{ bar: 1 }])
  await d1.close()
  await mf.dispose()
})

test('boolean column type', async () => {
  // SQLite
  const sqlite = new Database({ driver: sqliteConnectionString('boolean_column_type') })
  await sqlite.connect()
  await sqlite.createTable('Foo')
  await sqlite.createColumn('Foo', 'bar', 'boolean')
  expect(await sqlite.exec(`insert into "Foo" (bar) values (1)`)).toBe(1)
  expect(await sqlite.exec(`insert into "Foo" (bar) values (0)`)).toBe(1)
  await expect(() => sqlite.exec(`insert into "Foo" (bar) values ('baz')`)).rejects.toThrow()
  await expect(() => sqlite.exec(`insert into "Foo" (bar) values (1.1)`)).rejects.toThrow()
  expect(await sqlite.exec(`select * from "Foo"`)).toMatchObject([{ bar: 1 }, { bar: 0 }])
  await sqlite.close()

  // PostgreSQL
  const { pgConnectionString, PGPool, drop } = await pgConnection('boolean_column_type')
  const pg = new Database({ driver: pgConnectionString, PGPool })
  await pg.connect()
  await pg.createTable('Foo')
  await pg.createColumn('Foo', 'bar', 'boolean')
  expect(await pg.exec(`insert into "Foo" (bar) values (true)`)).toBe(1)
  expect(await pg.exec(`insert into "Foo" (bar) values (false)`)).toBe(1)
  await expect(() => pg.exec(`insert into "Foo" (bar) values ('baz')`)).rejects.toThrow()
  await expect(() => pg.exec(`insert into "Foo" (bar) values (1)`)).rejects.toThrow()
  expect(await pg.exec(`select * from "Foo"`)).toMatchObject([{ bar: true }, { bar: false }])
  await pg.close()
  await drop()

  // D1
  const { mf, db } = await createMiniflare()
  const d1 = new Database({ driver: db })
  await d1.connect()
  await d1.createTable('Foo')
  await d1.createColumn('Foo', 'bar', 'boolean')
  expect(await d1.exec(`insert into "Foo" (bar) values (1)`)).toBe(1)
  expect(await d1.exec(`insert into "Foo" (bar) values (0)`)).toBe(1)
  await expect(() => d1.exec(`insert into "Foo" (bar) values ('baz')`)).rejects.toThrow()
  await expect(() => d1.exec(`insert into "Foo" (bar) values (1.1)`)).rejects.toThrow()
  expect(await d1.exec(`select * from "Foo"`)).toMatchObject([{ bar: 1 }, { bar: 0 }])
  await d1.close()
  await mf.dispose()
})

test('numeric column type', async () => {
  // SQLite
  const sqlite = new Database({ driver: sqliteConnectionString('numeric_column_type') })
  await sqlite.connect()
  await sqlite.createTable('Foo')
  await sqlite.createColumn('Foo', 'bar', 'numeric')
  expect(await sqlite.exec(`insert into "Foo" (bar) values (1)`)).toBe(1)
  expect(await sqlite.exec(`insert into "Foo" (bar) values (1.1)`)).toBe(1)
  await expect(() => sqlite.exec(`insert into "Foo" (bar) values ('baz')`)).rejects.toThrow()
  expect(await sqlite.exec(`select * from "Foo"`)).toMatchObject([{ bar: 1 }, { bar: 1.1 }])
  await sqlite.close()

  // PostgreSQL
  const { pgConnectionString, PGPool, drop } = await pgConnection('numeric_column_type')
  const pg = new Database({ driver: pgConnectionString, PGPool })
  await pg.connect()
  await pg.createTable('Foo')
  await pg.createColumn('Foo', 'bar', 'numeric')
  expect(await pg.exec(`insert into "Foo" (bar) values (1)`)).toBe(1)
  expect(await pg.exec(`insert into "Foo" (bar) values (1.1)`)).toBe(1)
  await expect(() => pg.exec(`insert into "Foo" (bar) values ('baz')`)).rejects.toThrow()
  expect(await pg.exec(`select * from "Foo"`)).toMatchObject([{ bar: '1' }, { bar: '1.1' }])
  await pg.close()
  await drop()

  // D1
  const { mf, db } = await createMiniflare()
  const d1 = new Database({ driver: db })
  await d1.connect()
  await d1.createTable('Foo')
  await d1.createColumn('Foo', 'bar', 'numeric')
  expect(await d1.exec(`insert into "Foo" (bar) values (1)`)).toBe(1)
  expect(await d1.exec(`insert into "Foo" (bar) values (1.1)`)).toBe(1)
  await expect(() => d1.exec(`insert into "Foo" (bar) values ('baz')`)).rejects.toThrow()
  expect(await d1.exec(`select * from "Foo"`)).toMatchObject([{ bar: 1 }, { bar: 1.1 }])
  await d1.close()
  await mf.dispose()
})

test('text column type', async () => {
  // SQLite
  const sqlite = new Database({ driver: sqliteConnectionString('text_column_type') })
  await sqlite.connect()
  await sqlite.createTable('Foo')
  await sqlite.createColumn('Foo', 'bar', 'text')
  expect(await sqlite.exec(`insert into "Foo" (bar) values ('baz')`)).toBe(1)
  expect(await sqlite.exec(`insert into "Foo" (bar) values (1.1)`)).toBe(1)
  expect(await sqlite.exec(`select * from "Foo"`)).toMatchObject([{ bar: 'baz' }, { bar: '1.1' }])
  await sqlite.close()

  // PostgreSQL
  const { pgConnectionString, PGPool, drop } = await pgConnection('text_column_type')
  const pg = new Database({ driver: pgConnectionString, PGPool })
  await pg.connect()
  await pg.createTable('Foo')
  await pg.createColumn('Foo', 'bar', 'text')
  expect(await pg.exec(`insert into "Foo" (bar) values ('baz')`)).toBe(1)
  expect(await pg.exec(`insert into "Foo" (bar) values (1.1)`)).toBe(1)
  expect(await pg.exec(`select * from "Foo"`)).toMatchObject([{ bar: 'baz' }, { bar: '1.1' }])
  await pg.close()
  await drop()

  // D1
  const { mf, db } = await createMiniflare()
  const d1 = new Database({ driver: db })
  await d1.connect()
  await d1.createTable('Foo')
  await d1.createColumn('Foo', 'bar', 'text')
  expect(await d1.exec(`insert into "Foo" (bar) values ('baz')`)).toBe(1)
  expect(await d1.exec(`insert into "Foo" (bar) values (1.1)`)).toBe(1)
  expect(await d1.exec(`select * from "Foo"`)).toMatchObject([{ bar: 'baz' }, { bar: '1.1' }])
  await d1.close()
  await mf.dispose()
})

test('nullable columns', async () => {
  // SQLite
  const sqlite = new Database({ driver: sqliteConnectionString('nullable_columns') })
  await sqlite.connect()
  await sqlite.createTable('Foo')
  await sqlite.createColumn('Foo', 'bar', 'text', true)
  expect(await sqlite.exec(`insert into "Foo" (bar) values (null)`)).toBe(1)
  expect(await sqlite.exec(`select * from "Foo"`)).toMatchObject([{ bar: null }])
  await sqlite.close()

  // PostgreSQL
  const { pgConnectionString, PGPool, drop } = await pgConnection('nullable_columns')
  const pg = new Database({ driver: pgConnectionString, PGPool })
  await pg.connect()
  await pg.createTable('Foo')
  await pg.createColumn('Foo', 'bar', 'text', true)
  expect(await pg.exec(`insert into "Foo" (bar) values (null)`)).toBe(1)
  expect(await pg.exec(`select * from "Foo"`)).toMatchObject([{ bar: null }])
  await pg.close()
  await drop()

  // D1
  const { mf, db } = await createMiniflare()
  const d1 = new Database({ driver: db })
  await d1.connect()
  await d1.createTable('Foo')
  await d1.createColumn('Foo', 'bar', 'text', true)
  expect(await d1.exec(`insert into "Foo" (bar) values (null)`)).toBe(1)
  expect(await d1.exec(`select * from "Foo"`)).toMatchObject([{ bar: null }])
  await d1.close()
  await mf.dispose()
})

test('not null columns', async () => {
  // SQLite
  const sqlite = new Database({ driver: sqliteConnectionString('not_null_columns') })
  await sqlite.connect()
  await sqlite.createTable('Foo')
  await sqlite.createColumn('Foo', 'bar', 'text', false)
  expect(await sqlite.exec(`insert into "Foo" (bar) values ('baz')`)).toBe(1)
  expect(await sqlite.exec(`select * from "Foo"`)).toMatchObject([{ bar: 'baz' }])
  await expect(() => sqlite.exec(`insert into "Foo" (bar) values (null)`)).rejects.toThrow()
  await sqlite.close()

  // PostgreSQL
  const { pgConnectionString, PGPool, drop } = await pgConnection('not_null_columns')
  const pg = new Database({ driver: pgConnectionString, PGPool })
  await pg.connect()
  await pg.createTable('Foo')
  await pg.createColumn('Foo', 'bar', 'text', false)
  expect(await pg.exec(`insert into "Foo" (bar) values ('baz')`)).toBe(1)
  expect(await pg.exec(`select * from "Foo"`)).toMatchObject([{ bar: 'baz' }])
  await expect(() => pg.exec(`insert into "Foo" (bar) values (null)`)).rejects.toThrow()
  await pg.close()
  await drop()

  // D1
  const { mf, db } = await createMiniflare()
  const d1 = new Database({ driver: db })
  await d1.connect()
  await d1.createTable('Foo')
  await d1.createColumn('Foo', 'bar', 'text', false)
  expect(await d1.exec(`insert into "Foo" (bar) values ('baz')`)).toBe(1)
  expect(await d1.exec(`select * from "Foo"`)).toMatchObject([{ bar: 'baz' }])
  await expect(() => d1.exec(`insert into "Foo" (bar) values (null)`)).rejects.toThrow()
  await d1.close()
  await mf.dispose()
})

test('changeable column types', async () => {
  expect(canChangeColumnType('bigint', 'bigint')).toBe(true)
  expect(canChangeColumnType('bigint', 'boolean')).toBe(false)
  expect(canChangeColumnType('bigint', 'numeric')).toBe(true)
  expect(canChangeColumnType('bigint', 'text')).toBe(true)

  expect(canChangeColumnType('boolean', 'bigint')).toBe(false)
  expect(canChangeColumnType('boolean', 'boolean')).toBe(true)
  expect(canChangeColumnType('boolean', 'numeric')).toBe(false)
  expect(canChangeColumnType('boolean', 'text')).toBe(true)

  expect(canChangeColumnType('numeric', 'bigint')).toBe(false)
  expect(canChangeColumnType('numeric', 'boolean')).toBe(false)
  expect(canChangeColumnType('numeric', 'numeric')).toBe(true)
  expect(canChangeColumnType('numeric', 'text')).toBe(true)

  expect(canChangeColumnType('text', 'bigint')).toBe(false)
  expect(canChangeColumnType('text', 'boolean')).toBe(false)
  expect(canChangeColumnType('text', 'numeric')).toBe(false)
  expect(canChangeColumnType('text', 'text')).toBe(true)
})

test('changing column type', async () => {
  // SQLite
  const sqlite = new Database({ driver: sqliteConnectionString('changing_column_type') })
  await sqlite.connect()
  await sqlite.createTable('Foo')
  await sqlite.createColumn('Foo', 'bar', 'numeric')
  expect(await sqlite.exec(`insert into "Foo" (bar) values (1)`)).toBe(1)
  await expect(() => sqlite.exec(`insert into "Foo" (bar) values ('baz')`)).rejects.toThrow()
  expect(await sqlite.exec(`select * from "Foo"`)).toMatchObject([{ bar: 1 }])
  expect(await sqlite.changeColumnType('Foo', 'bar', 'text', true)).toBeUndefined()
  expect(await sqlite.exec(`pragma table_info(Foo)`)).toMatchObject([{}, { name: 'bar', type: 'TEXT' }])
  expect(await sqlite.exec(`select * from "Foo"`)).toMatchObject([{ bar: '1' }])
  expect(await sqlite.exec("insert into Foo (bar) values ('baz')")).toBe(1)
  await expect(() => sqlite.changeColumnType('Foo', 'bar', 'bigint', true)).rejects.toThrow()
  expect(await sqlite.exec(`select * from "Foo"`)).toMatchObject([{ bar: '1' }, { bar: 'baz' }])
  expect(await sqlite.exec(`insert into "Foo" (bar) values (null)`)).toBe(1)
  expect(await sqlite.changeColumnType('Foo', 'bar', 'text', true)).toBeUndefined()
  await expect(() => sqlite.changeColumnType('Foo', 'bar', 'text', false)).rejects.toThrow()
  await sqlite.close()

  // PostgreSQL
  const { pgConnectionString, PGPool, drop } = await pgConnection('changing_column_type')
  const pg = new Database({ driver: pgConnectionString, PGPool })
  await pg.connect()
  await pg.createTable('Foo')
  await pg.createColumn('Foo', 'bar', 'numeric')
  expect(await pg.exec(`insert into "Foo" (bar) values (1)`)).toBe(1)
  await expect(() => pg.exec(`insert into "Foo" (bar) values ('baz')`)).rejects.toThrow()
  expect(await pg.exec(`select * from "Foo"`)).toMatchObject([{ bar: '1' }])
  expect(await pg.changeColumnType('Foo', 'bar', 'text', true)).toBeUndefined()
  expect(
    await pg.exec(`select data_type from information_schema.columns where table_name = 'Foo' and column_name = 'bar'`),
  ).toMatchObject([{ data_type: 'text' }])
  expect(await pg.exec(`select * from "Foo"`)).toMatchObject([{ bar: '1' }])
  expect(await pg.exec(`insert into "Foo" (bar) values ('baz')`)).toBe(1)
  await expect(() => pg.changeColumnType('Foo', 'bar', 'bigint', true)).rejects.toThrow()
  expect(await pg.exec(`select * from "Foo"`)).toMatchObject([{ bar: '1' }, { bar: 'baz' }])
  expect(await pg.exec(`insert into "Foo" (bar) values (null)`)).toBe(1)
  expect(await pg.changeColumnType('Foo', 'bar', 'text', true)).toBeUndefined()
  await expect(() => pg.changeColumnType('Foo', 'bar', 'text', false)).rejects.toThrow()
  await pg.close()
  await drop()

  // D1
  const { mf, db } = await createMiniflare()
  const d1 = new Database({ driver: db })
  await d1.connect()
  await d1.createTable('Foo')
  await d1.createColumn('Foo', 'bar', 'numeric')
  expect(await d1.exec(`insert into "Foo" (bar) values (1)`)).toBe(1)
  await expect(() => d1.exec(`insert into "Foo" (bar) values ('baz')`)).rejects.toThrow()
  expect(await d1.exec(`select * from "Foo"`)).toMatchObject([{ bar: 1 }])
  expect(await d1.changeColumnType('Foo', 'bar', 'text', true)).toBeUndefined()
  expect(await d1.exec(`pragma table_info(Foo)`)).toMatchObject([{}, { name: 'bar', type: 'TEXT' }])
  expect(await d1.exec(`select * from "Foo"`)).toMatchObject([{ bar: '1' }])
  expect(await d1.exec("insert into Foo (bar) values ('baz')")).toBe(1)
  await expect(() => d1.changeColumnType('Foo', 'bar', 'bigint', true)).rejects.toThrow()
  expect(await d1.exec(`select * from "Foo"`)).toMatchObject([{ bar: '1' }, { bar: 'baz' }])
  expect(await d1.exec(`insert into "Foo" (bar) values (null)`)).toBe(1)
  expect(await d1.changeColumnType('Foo', 'bar', 'text', true)).toBeUndefined()
  await expect(() => d1.changeColumnType('Foo', 'bar', 'text', false)).rejects.toThrow()
  await d1.close()
  await mf.dispose()
})

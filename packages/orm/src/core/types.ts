import type { GenericField } from './Field'

// Fields

export type ExtractDataTypes<TFields extends Record<string, GenericField>> = {
  [K in keyof TFields]: TFields[K]['model']['dataType']
}

export type ExtractCastedTypes<TFields extends Record<string, GenericField>> = {
  [K in keyof TFields]: TFields[K]['model']['TCastedType'] | (TFields[K]['nullable'] extends false ? never : null)
}

export type ExtractPopulatedTypes<TFields extends Record<string, GenericField>> = {
  [K in keyof TFields]: TFields[K]['model']['TPopulatedType']
}

export type ExtractInputTypes<TFields extends Record<string, GenericField>> = {
  [K in keyof TFields]: TFields[K]['model']['TInputType'] | (TFields[K]['nullable'] extends false ? never : null)
}

export type ExtractFieldNamesByType<TFields extends Record<string, GenericField>, TDataType extends DataType> = {
  [K in keyof TFields]: TFields[K]['model']['dataType'] extends TDataType ? K : never
}[keyof TFields]

export type ExtractNullableFieldNames<TFields extends Record<string, GenericField>> = {
  [K in keyof TFields]: TFields[K]['nullable'] extends false ? never : K
}[keyof TFields]

export type ExtractRequiredFieldNames<TFields extends Record<string, GenericField>> = {
  [K in keyof TFields]: TFields[K]['required'] extends true ? K : never
}[keyof TFields]

export type ExtractImmutableFieldNames<TFields extends Record<string, GenericField>> = {
  [K in keyof TFields]: TFields[K]['immutable'] extends true ? K : never
}[keyof TFields]

export type ExtractAutoGeneratedFieldNames<TFields extends Record<string, GenericField>> = {
  [K in keyof TFields]: TFields[K]['autoGenerated'] extends true ? K : never
}[keyof TFields]

export type ExtractConditionalFieldNames<TFields extends Record<string, GenericField>> = {
  [K in keyof TFields]: TFields[K]['hasConditionalLogic'] extends true ? K : never
}[keyof TFields]

// Conditional logic

export type ConditionalLogic =
  | Record<string, ConditionalRule>
  | ConditionalOrGroup
  | (Record<string, ConditionalRule> | ConditionalOrGroup)[]

export type ConditionalOperator = '=' | '!=' | '>' | '>=' | '<' | '<=' | 'regexp'

export type ConditionalOperatorValue<T extends ConditionalOperator> = T extends '=' | '!='
  ? boolean | number | string | null
  : T extends '>' | '>=' | '<' | '<='
    ? number
    : T extends 'regexp'
      ? string | { pattern: string; flags?: string }
      : never

export type ConditionalRule = { [T in ConditionalOperator]?: ConditionalOperatorValue<T> }

export type ConditionalOrGroup = {
  orGroup:
    | (Record<string, ConditionalRule> | ConditionalOrGroup)[]
    | (Record<string, ConditionalRule> | ConditionalOrGroup)[][]
}

// Misc

export type DataType = 'bigint' | 'boolean' | 'numeric' | 'text'

export interface SerializedType extends Record<DataType, any> {
  bigint: number | string
  boolean: boolean | number
  numeric: number | string
  text: string
}

export type ReferentialActions = [
  'ON UPDATE RESTRICT' | 'ON UPDATE CASCADE' | 'ON UPDATE SET NULL',
  'ON DELETE RESTRICT' | 'ON DELETE CASCADE' | 'ON DELETE SET NULL',
]

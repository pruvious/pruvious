import type { QueryBuilderResult } from '../query-builder'
import type { DeleteContext, SanitizedInsertContext, SanitizedUpdateContext, SelectContext } from './Context'
import type { GenericDatabase } from './Database'
import type { GenericField } from './Field'
import type {
  ExtractAutoGeneratedFieldNames,
  ExtractCastedTypes,
  ExtractConditionalFieldNames,
  ExtractDataTypes,
  ExtractImmutableFieldNames,
  ExtractInputTypes,
  ExtractNullableFieldNames,
  ExtractPopulatedTypes,
  ExtractRequiredFieldNames,
  ReferentialActions,
} from './types'

interface ICollection {
  /**
   * A unique identifier used for automatic schema synchronization (database migration).
   * This key must remain unchanged when modifying the collection schema.
   *
   * If not specified, it the corresponding collection/table name will be used.
   *
   * Key rules:
   *
   * - Start with a letter or underscore.
   * - Only contain letters, numbers, and underscores.
   * - Maximum length: 63 characters.
   *
   * @example
   * ```ts
   * 'fooBar'  // Valid
   * 'foo_bar' // Valid
   * 'FOO_123' // Valid
   * 'foo-bar' // Invalid
   * '$fooBar' // Invalid
   * ```
   */
  key?: string

  /**
   * A key-value object of `Field` instances representing the structure of the collection.
   *
   * - Object keys represent the field names (used as column names in the database).
   * - Object values are instances of the `Field` class.
   */
  fields: any

  /**
   * An array of database indexes to enhance query performance.
   *
   * Each index object can include:
   *
   * - `fields` - Array of field/column names to index (required).
   * - `unique` - Boolean specifying if the index enforces uniqueness (optional, default: `false`).
   *
   * Index names are automatically generated following this convention:
   *
   * - Single-column index - `IX_{table}__{column}`
   * - Multi-column index - `CX_{table}__{column1}__{column2}`
   * - Unique single-column index - `UX_{table}__{column}`
   * - Unique multi-column index - `UC_{table}__{column1}__{column2}`
   *
   * @example
   * ```ts
   * [
   *   { fields: {'email'], unique: true },
   *   { fields: {'firstName', 'lastName'] },
   * ]
   * ```
   */
  indexes?: any

  /**
   * An array of foreign key constraints for defining relationships between collections.
   *
   * Foreign key names are automatically generated using the format `FK_{table}__{column}`.
   *
   * @example
   * ```ts
   * [
   *   { field: 'categoryId', referencedCollection: 'Categories' },
   *   { field: 'userId', referencedCollection: 'Users', action: ['ON UPDATE CASCADE', 'ON DELETE CASCADE'] },
   * ]
   * ```
   */
  foreignKeys?: any

  /**
   * Hooks are functions that execute at specific points in the query lifecycle for this collection.
   *
   * Available hooks:
   *
   * - `beforeQueryPreparation` - Runs before the SQL query is generated from the current query builder context.
   * - `beforeQueryExecution` - Runs before the query is sent to the database.
   * - `afterQueryExecution` - Runs after the query is executed and before the result is returned from the `QueryBuilder`.
   *
   * @example
   * ```ts
   * {
   *   beforeQueryPreparation: [
   *     ({ operation, queryBuilder }) => {
   *       if (operation !== 'insert') {
   *         queryBuilder.where('author', '=', 1)
   *       }
   *     },
   *   ],
   * }
   * ```
   */
  hooks?: CollectionHooks

  /**
   * Additional metadata to store custom information about the collection.
   */
  meta?: Record<string, any>
}

export interface CollectionDefinition<TFields extends Record<string, GenericField>, TMeta extends Record<string, any>>
  extends ICollection {
  key?: string
  fields: TFields
  indexes?: Index<TFields>[]
  foreignKeys?: ForeignKey<TFields>[]
  hooks?: CollectionHooks
  meta?: TMeta
}

export interface Index<TFields extends Record<string, GenericField>> {
  /**
   * The field/column names to index.
   */
  fields: (keyof TFields)[]

  /**
   * Whether the index is unique.
   *
   * @default false
   */
  unique?: boolean
}

export interface ForeignKey<TFields extends Record<string, GenericField>> {
  /**
   * The field/column name in the current collection that has the foreign key constraint.
   */
  field: keyof TFields

  /**
   * The collection/table name that this foreign key refers to.
   */
  referencedCollection: string

  /**
   * The field/column name in the referenced collection that this foreign key points to.
   *
   * @default 'id'
   */
  referencedField?: string

  /**
   * Specifies how the database should handle updates or deletions in the referenced table.
   * It's a tuple of two strings, each defining an action for UPDATE and DELETE operations.
   *
   * @default
   * ['ON UPDATE RESTRICT', 'ON DELETE SET NULL']
   */
  action?: ReferentialActions
}

export interface CollectionHooks {
  /**
   * Functions to execute before the SQL query is generated from the current query builder context.
   *
   * Each function receives a `context` instance related to the current operation as a parameter.
   *
   * Note: It's safe to throw errors in these functions to halt query execution.
   * Any thrown error will be caught and returned as a `QueryBuilderRuntimeError`.
   */
  beforeQueryPreparation?: ((
    context:
      | SanitizedInsertContext<GenericDatabase>
      | SelectContext<GenericDatabase>
      | SanitizedUpdateContext<GenericDatabase>
      | DeleteContext<GenericDatabase>,
  ) => any)[]

  /**
   * Functions to execute before the query is sent to the database.
   *
   * Each function receives the following arguments in order:
   *
   * - `context` - The context instance related to the current operation.
   * - `queryDetails` - The query details object with the following properties:
   *   - `query` - Object with `sql` string and `params` object.
   *
   * Note: It's safe to throw errors in these functions to halt query execution.
   * Any thrown error will be caught and returned as a `QueryBuilderRuntimeError`.
   */
  beforeQueryExecution?: ((
    context:
      | SanitizedInsertContext<GenericDatabase>
      | SelectContext<GenericDatabase>
      | SanitizedUpdateContext<GenericDatabase>
      | DeleteContext<GenericDatabase>,
    queryDetails: Pick<QueryDetails, 'query'>,
  ) => any)[]

  /**
   * Functions to execute after the query is executed and before the result is returned from a `QueryBuilder`.
   *
   * Each function receives the following arguments in order:
   *
   * - `context` - The context instance related to the current operation.
   * - `queryDetails` - The query details object with the following properties:
   *   - `query` - Object with `sql` string and `params` object.
   *   - `queryExecutionTime` - The time taken for the database query to execute (in milliseconds).
   *   - `rawResult` - The raw query execution result or error message.
   *   - `result` - The formatted result of type `QueryBuilderResult`.
   *
   * Note: Avoid throwing errors in these functions as they may not be caught.
   */
  afterQueryExecution?: ((
    context:
      | SanitizedInsertContext<GenericDatabase>
      | SelectContext<GenericDatabase>
      | SanitizedUpdateContext<GenericDatabase>
      | DeleteContext<GenericDatabase>,
    queryDetails: QueryDetails,
  ) => any)[]
}

export interface QueryDetails {
  /**
   * Object with `operation`, `sql` string, and `params` object.
   */
  query: { operation: 'insert' | 'select' | 'update' | 'delete'; sql: string; params: Record<string, any> }

  /**
   * The time taken for the database query to execute (in milliseconds).
   */
  queryExecutionTime: number

  /**
   * The raw query execution result or error message.
   */
  rawResult: any

  /**
   * The formatted result of type `QueryBuilderResult`.
   */
  result: QueryBuilderResult<any, Record<string, string> | Record<string, string>[]>
}

export type GenericCollection = Collection<Record<string, GenericField>, Record<string, any>>

/**
 * Defines a new collection.
 *
 * @example
 * ```ts
 * new Collection({
 *   fields: {
 *     firstName: new Field({ model: textFieldModel(), options: {} }),
 *     lastName: new Field({ model: textFieldModel(), options: {} }),
 *     house: new Field({ model: bigIntFieldModel(), options: {} }),
 *     prefect: new Field({ model: booleanFieldModel(), options: {} }),
 *     // ...
 *   ],
 *   foreignKeys: [
 *     { field: 'house', referencedCollection: 'Houses' },
 *   ],
 * })
 * ```
 */
export class Collection<const TFields extends Record<string, GenericField>, const TMeta extends Record<string, any>>
  implements ICollection
{
  readonly key: string | undefined
  readonly fields: TFields
  readonly indexes: Index<Record<string, GenericField>>[]
  readonly foreignKeys: ForeignKey<Record<string, GenericField>>[]
  readonly hooks: Required<CollectionHooks>
  readonly meta: TMeta

  /**
   * Type with all column names.
   *
   * Note: This is a TypeScript type assertion and does not involve any runtime logic or data.
   */
  readonly TColumnNames!: keyof TFields

  /**
   * Type with all column names and their respective data types.
   *
   * Note: This is a TypeScript type assertion and does not involve any runtime logic or data.
   */
  readonly TDataTypes!: ExtractDataTypes<TFields>

  /**
   * Type with all column names and their respective TypeScript types after casting the values from the database.
   *
   * Note: This is a TypeScript type assertion and does not involve any runtime logic or data.
   */
  readonly TCastedTypes!: ExtractCastedTypes<TFields>

  /**
   * Type with all column names and their respective TypeScript types after populating the values.
   *
   * Note: This is a TypeScript type assertion and does not involve any runtime logic or data.
   */
  readonly TPopulatedTypes!: ExtractPopulatedTypes<TFields>

  /**
   * Type with all column names and their respective TypeScript types that can be used as input values.
   *
   * Note: This is a TypeScript type assertion and does not involve any runtime logic or data.
   */
  readonly TInputTypes!: ExtractInputTypes<TFields>

  /**
   * Type with all column names where values are nullable (accept `null` values).
   *
   * Note: This is a TypeScript type assertion and does not involve any runtime logic or data.
   */
  readonly TNullableColumns!: ExtractNullableFieldNames<TFields>

  /**
   * Type with all column names where values are required when inserting new records.
   *
   * Note: This is a TypeScript type assertion and does not involve any runtime logic or data.
   */
  readonly TRequiredColumns!: ExtractRequiredFieldNames<TFields>

  /**
   * Type with all column names that are immutable and cannot be updated after inserting a new record.
   *
   * Note: This is a TypeScript type assertion and does not involve any runtime logic or data.
   */
  readonly TImmutableColumns!: ExtractImmutableFieldNames<TFields>

  /**
   * Type with all column names that are auto-generated by the collection.
   *
   * Note: This is a TypeScript type assertion and does not involve any runtime logic or data.
   */
  readonly TAutoGeneratedColumns!: ExtractAutoGeneratedFieldNames<TFields>

  /**
   * Type with all column names that use conditional logic.
   *
   * Note: This is a TypeScript type assertion and does not involve any runtime logic or data.
   */
  readonly TConditionalColumns!: ExtractConditionalFieldNames<TFields>

  constructor(definition: CollectionDefinition<TFields, TMeta>) {
    this.key = definition.key
    this.fields = definition.fields
    this.indexes = definition.indexes ?? ([] as any)
    this.foreignKeys = definition.foreignKeys ?? ([] as any)
    this.hooks = {
      beforeQueryPreparation: definition.hooks?.beforeQueryPreparation ?? [],
      beforeQueryExecution: definition.hooks?.beforeQueryExecution ?? [],
      afterQueryExecution: definition.hooks?.afterQueryExecution ?? [],
    }
    this.meta = definition.meta ?? ({} as any)
  }
}

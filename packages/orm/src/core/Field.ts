import { cleanMerge, isDefined, type DefaultFalse, type DefaultTrue } from '@pruvious/utils'
import { InsertContext, SanitizedInsertContext, SanitizedUpdateContext, UpdateContext, type Context } from './Context'
import { ContextField, type ContextFieldData } from './ContextField'
import type { Database, GenericDatabase } from './Database'
import type { GenericFieldModel } from './FieldModel'
import { SanitizedContextField, type SanitizedContextFieldData } from './SanitizedContextField'
import type { ConditionalLogic } from './types'

interface IField {
  /**
   * A unique identifier used for automatic schema synchronization (database migration)
   * and collection references (e.g. in indexes and foreign keys).
   * When defining subfields, this can be ignored.
   *
   * If not specified, it the corresponding field/column name will be used.
   *
   * This key must remain unchanged when modifying the field schema.
   *
   * Key rules:
   *
   * - Start with a letter or underscore.
   * - Only contain letters, numbers, and underscores.
   * - Maximum length: 63 characters.
   * - Cannot be `id` (reserved for the internal ID field).
   *
   * @example
   * ```ts
   * 'fooBar'  // Valid
   * 'foo_bar' // Valid
   * 'FOO_123' // Valid
   * 'foo-bar' // Invalid
   * '$fooBar' // Invalid
   * ```
   */
  key?: string

  /**
   * The field model (instance of `FieldModel`).
   * It defines the field's core configuration, including data type, default value, serializers, sanitizers, validators, and more.
   *
   * @example
   * ```ts
   * new Field({
   *   model: textFieldModel(),
   *   // ...
   * })
   * ```
   */
  model: any

  /**
   * Options specific to this field's `model`.
   *
   * @example
   * ```ts
   * new Field({
   *   model: textFieldModel(),
   *   options: { trim: false },
   *   // ...
   * })
   * ```
   */
  options: any

  /**
   * Determines if the field can accept `null` values.
   *
   * @default true
   */
  nullable?: boolean

  /**
   * Specifies whether the field value is mandatory during creation.
   * When set to `true`, the following rules are enforced:
   *
   * - A value must be provided for the field; it cannot be `undefined`.
   * - For `text` data types, an empty string or array is not allowed.
   * - For `boolean` data types, `false` is not allowed.
   * - For arrays, an empty array is not allowed unless the field model permits it.
   * - `null` is permitted if the field is `nullable`.
   *
   * @default false
   */
  required?: boolean

  /**
   * Determines if the field value cannot be changed after initial creation.
   * This option only applies to top-level fields (columns).
   *
   * @default false
   */
  immutable?: boolean

  /**
   * Indicates if the field value is automatically generated.
   * When `true`, the field is hidden in input data types.
   * This option primarily affects TypeScript type inference and doesn't change runtime behavior.
   *
   * Tip: Use `inputFilters` to set the field values for `autoGenerated` fields.
   *
   * @default false
   */
  autoGenerated?: boolean

  /**
   * The default value for the field.
   *
   * If not specified, it's automatically derived from the `defaultValue` value in the field's `model`.
   *
   * Note: When a field is marked as `required` and meets its `conditionalLogic` rules, this option will not take effect.
   */
  default?: any

  /**
   * Defines conditional logic for this field.
   * This determines whether the input for this field stays `required`.
   *
   * Set conditions based on other fields in the same context.
   * Updating this field makes the referenced fields become required inputs.
   * If a referenced field is an array, the comparison is made against the array length.
   *
   * Condition objects use keys that are relative paths to the field being checked.
   *
   * - Use dot notation for nested fields.
   * - Use `..` to go up the hierarchy.
   * - Use `/` to reference from the root level.
   *
   * @example
   * ```ts
   * // Check sibling field
   * { size: { '=': 'sm' } }
   * // or
   * { './size': { '=': 'sm' } }
   *
   * // Check nested sibling field
   * { 'address.city': { in: ['London', 'Paris'] } }
   * // or
   * { './address.city': { in: ['London', 'Paris'] } }
   *
   * // Check parent field (e.g. array length)
   * { '..': { '>': 1 } }
   *
   * // Check field in sibling array item
   * { '../1.color': { '!=': 'red' } }
   *
   * // Check sibling of parent
   * { '../color': { regexp: '^(?:[a-z]+-)?blue$' } }
   *
   * // Check root-level field
   * { '/layout': { '!=': 'default' } }
   *
   * // Multiple conditions (AND logic)
   * {
   *   size: { '=': 'sm' },
   *   '../color': { regexp: '^(?:[a-z]+-)?blue$' },
   * }
   * // or
   * [
   *   { size: { '=': 'sm' } }
   *   { '../color': { regexp: '^(?:[a-z]+-)?blue$' } },
   * ]
   *
   * // Multiple conditions (OR logic)
   * {
   *   orGroup: [
   *     { size: { '=': 'sm' } }
   *     { '../color': { regexp: '^(?:[a-z]+-)?blue$' } },
   *   ],
   * }
   *
   * // Complex example (combining AND and OR logic)
   * [
   *   { size: { '=': 'sm' } }
   *   {
   *     orGroup: [
   *       [
   *         { '../color': { regexp: '^(?:[a-z]+-)?blue$' } },
   *         { '../color': { '!=': 'light-blue' } },
   *       ],
   *       [
   *         { '../color': { regexp: '^(?:[a-z]+-)?red$' } },
   *       ],
   *     ],
   *   },
   * ]
   * ```
   */
  conditionalLogic?: any

  /**
   * Defines which other fields become required when this field is present.
   * Reference other fields using relative paths from the current field:
   *
   * - Use dot notation for nested fields.
   * - Use `..` to go up the hierarchy.
   * - Use `/` to reference from the root level.
   *
   * @example
   * ```ts
   * // Depend on sibling field
   * ['size']
   * // or
   * ['./size']
   *
   * // Depend on sibling field of parent
   * ['../color']
   *
   * // Depend on root-level field
   * ['/layout']
   * ```
   */
  dependencies?: string[]

  /**
   * An array of callback functions that validate an input value for this field.
   * The functions receive the following arguments in order:
   *
   * - `value` - The input value to validate.
   * - `sanitizedContextField` - The current context field object.
   * - `errors` - An object for storing validation errors (keys use dot notation).
   *
   * Functions should throw an error or set an error message in `errors` if the value is invalid.
   *
   * Validators specified here run after the built-in validators for the chosen field `model`.
   *
   * @default []
   *
   * @example
   * ```ts
   * [
   *   (value, sanitizedContextField, errors) => {
   *     if (value === 'Voldemort') {
   *       throw new Error('You know who')
   *     }
   *   },
   * ]
   * ```
   */
  validators?: any

  /**
   * Input filters allow you to set or modify the field's input value at specific stages during INSERT or UPDATE queries.
   * They run regardless of whether an input value is provided in the query.
   * The following filters are available:
   *
   * - `beforeInputSanitization` - Runs before the input value is sanitized.
   * - `beforeInputValidation` - Runs before the input value is validated.
   * - `beforeQueryExecution` - Runs before the query is executed.
   *
   * Each filter receives the following arguments in order:
   *
   * - `value` - The current input value to filter (`undefined` if no value is provided).
   * - `contextField` - The current context field object.
   *
   * The filter function should return a field value or a `Promise` that resolves to a field value.
   * Returning `undefined` will remove the corresponding field from the input data.
   *
   * Filters can be defined as functions or as objects with the following properties:
   *
   * - `order` - A number that determines the order in which the filter runs (defaults to `10`).
   * - `callback` - The filter function.
   *
   * Fields with a lower input filter `order` are processed before those with a higher `order`.
   *
   * @example
   * ```ts
   * {
   *   name: 'autoGeneratedTimestamp',
   *   model: numberFieldModel(),
   *   inputFilters: {
   *     // With default order (10)
   *     beforeInputSanitization: (rawValue, contextField) => {
   *       return contextField.context.operation === 'update' ? Date.now() : rawValue
   *     },
   *
   *     // The `beforeQueryExecution` filter with order `0` will run before any other
   *     // `beforeQueryExecution` filters with higher order (including the default
   *     // order of `10`) in other fields.
   *     beforeQueryExecution: {
   *       order: 0,
   *       callback: (sanitizedValue, sanitizedContextField) => {
   *         return sanitizedContextField.context.operation === 'insert' ? Date.now() : sanitizedValue
   *       },
   *     },
   *   },
   * }
   * ```
   */
  inputFilters?: any
}

export interface FieldDefinition<
  TModel extends GenericFieldModel,
  TOptions extends TModel['TOptions'],
  TNullable extends boolean | undefined,
  TRequired extends boolean | undefined,
  TImmutable extends boolean | undefined,
  TAutoGenerated extends boolean | undefined,
  TConditionalLogic extends ConditionalLogic | undefined,
  TDatabase extends GenericDatabase,
> extends IField {
  key?: string
  model: TModel
  options: TOptions
  nullable?: TNullable
  required?: TRequired
  immutable?: TImmutable
  autoGenerated?: TAutoGenerated
  default?: DefaultTrue<TNullable> extends true ? TModel['TCastedType'] | null : TModel['TCastedType']
  conditionalLogic?: TConditionalLogic
  dependencies?: string[]
  validators?: Validator<
    TModel,
    TOptions,
    DefaultTrue<TNullable>,
    DefaultFalse<TRequired>,
    DefaultFalse<TImmutable>,
    DefaultFalse<TAutoGenerated>,
    TConditionalLogic,
    TDatabase
  >[]
  inputFilters?: InputFilters<
    TModel,
    TOptions,
    DefaultTrue<TNullable>,
    DefaultFalse<TRequired>,
    DefaultFalse<TImmutable>,
    DefaultFalse<TAutoGenerated>,
    TConditionalLogic,
    TDatabase
  >
}

export type Validator<
  TModel extends GenericFieldModel,
  TOptions extends TModel['TOptions'],
  TNullable extends boolean,
  TRequired extends boolean,
  TImmutable extends boolean,
  TAutoGenerated extends boolean,
  TConditionalLogic extends ConditionalLogic | undefined,
  TDatabase extends GenericDatabase,
> = (
  /**
   * The sanitized input value to validate.
   */
  value: TNullable extends false ? TModel['TCastedType'] : TModel['TCastedType'] | null,

  /**
   * The current context field object.
   */
  sanitizedContextField: SanitizedContextField<
    TModel,
    TOptions,
    TNullable,
    TRequired,
    TImmutable,
    TAutoGenerated,
    TConditionalLogic,
    TDatabase,
    SanitizedInsertContext<TDatabase> | SanitizedUpdateContext<TDatabase>
  >,

  /**
   * An object for storing validation errors (keys use dot notation).
   */
  errors: Record<string, string>,
) => any

export type GenericValidator = Validator<
  any,
  Record<string, any>,
  boolean,
  boolean,
  boolean,
  boolean,
  ConditionalLogic | undefined,
  Database
>

export type InputFilter<
  TModel extends GenericFieldModel,
  TOptions extends TModel['TOptions'],
  TNullable extends boolean,
  TRequired extends boolean,
  TImmutable extends boolean,
  TAutoGenerated extends boolean,
  TConditionalLogic extends ConditionalLogic | undefined,
  TDatabase extends GenericDatabase,
> = (
  /**
   * The unprocessed (non-sanitized) input value of the field.
   * If no input value is provided for this field, it will be `undefined`.
   */
  value: any,

  /**
   * The current context field object.
   */
  contextField: ContextField<
    TModel,
    TOptions,
    TNullable,
    TRequired,
    TImmutable,
    TAutoGenerated,
    TConditionalLogic,
    TDatabase,
    InsertContext<TDatabase> | UpdateContext<TDatabase>
  >,
) => any

export type GenericInputFilter = InputFilter<
  any,
  Record<string, any>,
  boolean,
  boolean,
  boolean,
  boolean,
  ConditionalLogic | undefined,
  Database
>

export type SanitizedInputFilter<
  TModel extends GenericFieldModel,
  TOptions extends TModel['TOptions'],
  TNullable extends boolean,
  TRequired extends boolean,
  TImmutable extends boolean,
  TAutoGenerated extends boolean,
  TConditionalLogic extends ConditionalLogic | undefined,
  TDatabase extends GenericDatabase,
  TReturnValue = (TNullable extends false ? TModel['TCastedType'] : TModel['TCastedType'] | null) | undefined,
> = (
  /**
   * The sanitized input value of the field.
   * If no input value is provided for this field, it will be `undefined`.
   */
  value: TReturnValue,

  /**
   * The current context field object.
   */
  sanitizedContextField: SanitizedContextField<
    TModel,
    TOptions,
    TNullable,
    TRequired,
    TImmutable,
    TAutoGenerated,
    TConditionalLogic,
    TDatabase,
    SanitizedInsertContext<TDatabase> | SanitizedUpdateContext<TDatabase>
  >,
) => TReturnValue | Promise<TReturnValue>

export type GenericSanitizedInputFilter = SanitizedInputFilter<
  any,
  Record<string, any>,
  boolean,
  boolean,
  boolean,
  boolean,
  ConditionalLogic | undefined,
  Database,
  any
>

export interface OrderedInputFilter<TInputFilter> {
  /**
   * Sets the filter's execution order.
   * Lower order filters run first.
   *
   * @default 10
   */
  order?: number

  /**
   * A filter function for setting or modifying a field's input value during INSERT or UPDATE queries.
   * Filter functions run regardless of whether an input value is provided in the query.
   *
   * It receives the following arguments in order:
   *
   * - `value` - The current input value to filter (`undefined` if no value is provided).
   * - `contextField` - The current context field object.
   *
   * The filter function should return a field value or a `Promise` that resolves to a field value.
   * Returning `undefined` will remove the corresponding field from the input data.
   *
   * @example
   * ```ts
   * {
   *   callback: (sanitizedValue, sanitizedContextField) => {
   *     return sanitizedContextField.context.operation === 'insert' ? Date.now() : sanitizedValue
   *   },
   * }
   * ```
   */
  callback: TInputFilter
}

export type InputFilters<
  TModel extends GenericFieldModel,
  TOptions extends TModel['TOptions'],
  TNullable extends boolean,
  TRequired extends boolean,
  TImmutable extends boolean,
  TAutoGenerated extends boolean,
  TConditionalLogic extends ConditionalLogic | undefined,
  TDatabase extends GenericDatabase,
> = {
  /**
   * A filter function for setting or modifying a field's input value during INSERT or UPDATE queries.
   * It runs before the input value is sanitized, regardless of whether an input value is provided in the query.
   *
   * It receives the following arguments in order:
   *
   * - `value` - The unprocessed (non-sanitized) input value of the field (`undefined` if no value is provided).
   * - `contextField` - The current context field object.
   *
   * The filter function should return a field value or a `Promise` that resolves to a field value.
   * Returning `undefined` will remove the corresponding field from the input data.
   *
   * Filters can be defined as functions or as objects with the following properties:
   *
   * - `order` - A number that determines the order in which the filter runs (defaults to `10`).
   * - `callback` - The filter function.
   *
   * Fields with a lower input filter `order` are processed before those with a higher `order`.
   *
   * @example
   * ```ts
   * {
   *   order: 0,
   *   callback: (rawValue, contextField) => {
   *     return contextField.context.operation === 'update' ? Date.now() : rawValue
   *   },
   * }
   * ```
   */
  beforeInputSanitization?:
    | InputFilter<
        TModel,
        TOptions,
        DefaultTrue<TNullable>,
        DefaultFalse<TRequired>,
        DefaultFalse<TImmutable>,
        DefaultFalse<TAutoGenerated>,
        TConditionalLogic,
        TDatabase
      >
    | OrderedInputFilter<
        InputFilter<
          TModel,
          TOptions,
          DefaultTrue<TNullable>,
          DefaultFalse<TRequired>,
          DefaultFalse<TImmutable>,
          DefaultFalse<TAutoGenerated>,
          TConditionalLogic,
          TDatabase
        >
      >

  /**
   * A filter function for setting or modifying a field's input value during INSERT or UPDATE queries.
   * It runs before the input value is validated, regardless of whether an input value is provided in the query.
   *
   * It receives the following arguments in order:
   *
   * - `value` - The sanitized input value of the field (`undefined` if no value is provided).
   * - `contextField` - The current context field object.
   *
   * The filter function should return a field value or a `Promise` that resolves to a field value.
   * Returning `undefined` will remove the corresponding field from the input data.
   *
   * Filters can be defined as functions or as objects with the following properties:
   *
   * - `order` - A number that determines the order in which the filter runs (defaults to `10`).
   * - `callback` - The filter function.
   *
   * Fields with a lower input filter `order` are processed before those with a higher `order`.
   *
   * @example
   * ```ts
   * {
   *   order: 0,
   *   callback: (sanitizedValue, contextField) => {
   *     return contextField.context.operation === 'update' ? Date.now() : sanitizedValue
   *   },
   * }
   * ```
   */
  beforeInputValidation?:
    | SanitizedInputFilter<
        TModel,
        TOptions,
        DefaultTrue<TNullable>,
        DefaultFalse<TRequired>,
        DefaultFalse<TImmutable>,
        DefaultFalse<TAutoGenerated>,
        TConditionalLogic,
        TDatabase
      >
    | OrderedInputFilter<
        SanitizedInputFilter<
          TModel,
          TOptions,
          DefaultTrue<TNullable>,
          DefaultFalse<TRequired>,
          DefaultFalse<TImmutable>,
          DefaultFalse<TAutoGenerated>,
          TConditionalLogic,
          TDatabase
        >
      >

  /**
   * A filter function for setting or modifying a field's input value during INSERT or UPDATE queries.
   * It runs before the query is executed, regardless of whether an input value is provided in the query.
   *
   * It receives the following arguments in order:
   *
   * - `value` - The sanitized input value of the field (`undefined` if no value is provided).
   * - `contextField` - The current context field object.
   *
   * The filter function should return a field value or a `Promise` that resolves to a field value.
   * Returning `undefined` will remove the corresponding field from the input data.
   *
   * Filters can be defined as functions or as objects with the following properties:
   *
   * - `order` - A number that determines the order in which the filter runs (defaults to `10`).
   * - `callback` - The filter function.
   *
   * Fields with a lower input filter `order` are processed before those with a higher `order`.
   *
   * @example
   * ```ts
   * {
   *   order: 0,
   *   callback: (sanitizedValue, sanitizedContextField) => {
   *     return sanitizedContextField.context.operation === 'insert' ? Date.now() : sanitizedValue
   *   },
   * }
   * ```
   */
  beforeQueryExecution?:
    | SanitizedInputFilter<
        TModel,
        TOptions,
        DefaultTrue<TNullable>,
        DefaultFalse<TRequired>,
        DefaultFalse<TImmutable>,
        DefaultFalse<TAutoGenerated>,
        TConditionalLogic,
        TDatabase
      >
    | OrderedInputFilter<
        SanitizedInputFilter<
          TModel,
          TOptions,
          DefaultTrue<TNullable>,
          DefaultFalse<TRequired>,
          DefaultFalse<TImmutable>,
          DefaultFalse<TAutoGenerated>,
          TConditionalLogic,
          TDatabase
        >
      >
}

export type GenericField = Field<
  any,
  Record<string, any>,
  boolean | undefined,
  boolean | undefined,
  boolean | undefined,
  boolean | undefined,
  ConditionalLogic | undefined,
  GenericDatabase
>

/**
 * Defines a new field.
 *
 * @example
 * ```ts
 * new Field({
 *   name: 'address',
 *   model: textFieldModel(),
 *   required: true,
 *   nullable: false,
 *   options: {},
 * })
 * ```
 */
export class Field<
  TModel extends GenericFieldModel,
  const TOptions extends TModel['TOptions'],
  const TNullable extends boolean | undefined,
  const TRequired extends boolean | undefined,
  const TImmutable extends boolean | undefined,
  const TAutoGenerated extends boolean | undefined,
  TConditionalLogic extends ConditionalLogic | undefined,
  TDatabase extends GenericDatabase,
> implements IField
{
  readonly key: string | undefined
  readonly model: TModel
  readonly options: { [K in keyof TOptions & string]: Required<TOptions>[K] } & TOptions & TModel['TOptions']
  readonly nullable: DefaultTrue<TNullable>
  readonly required: DefaultFalse<TRequired>
  readonly immutable: DefaultFalse<TImmutable>
  readonly autoGenerated: DefaultFalse<TAutoGenerated>
  readonly default: DefaultTrue<TNullable> extends true ? TModel['TCastedType'] | null : TModel['TCastedType']
  readonly conditionalLogic: TConditionalLogic
  readonly dependencies: string[]
  readonly validators: Validator<
    TModel,
    TOptions,
    DefaultTrue<TNullable>,
    DefaultFalse<TRequired>,
    DefaultFalse<TImmutable>,
    DefaultFalse<TAutoGenerated>,
    TConditionalLogic,
    TDatabase
  >[]
  readonly inputFilters: Required<
    FieldDefinition<TModel, TOptions, TNullable, TRequired, TImmutable, TAutoGenerated, TConditionalLogic, TDatabase>
  >['inputFilters']

  /**
   * Indicates whether the field has specified `conditionalLogic`.
   */
  readonly hasConditionalLogic: [TConditionalLogic] extends [ConditionalLogic] ? true : false

  constructor(
    definition: FieldDefinition<
      TModel,
      TOptions & TModel['TOptions'],
      TNullable,
      TRequired,
      TImmutable,
      TAutoGenerated,
      TConditionalLogic,
      TDatabase
    >,
  ) {
    this.key = definition.key
    this.model = definition.model
    this.options = cleanMerge(definition.model.defaultOptions, definition.options) as any
    this.nullable = definition.nullable ?? (true as any)
    this.required = definition.required ?? (false as any)
    this.immutable = definition.immutable ?? (false as any)
    this.autoGenerated = definition.autoGenerated ?? (false as any)
    this.default = isDefined(definition.default) ? definition.default : this.model.defaultValue
    this.conditionalLogic = definition.conditionalLogic as any
    this.dependencies = definition.dependencies ?? []
    this.hasConditionalLogic = !!definition.conditionalLogic as any
    this.validators = definition.validators ?? []
    this.inputFilters = definition.inputFilters ?? {}
  }

  /**
   * Extends this `Field` instance with additional `context` and runtime `data`.
   * The resulting `ContextField` can be accessed during query builder operations at runtime.
   */
  withContext<T extends Context<TDatabase>>(context: T, data: ContextFieldData) {
    return new ContextField<
      TModel,
      TOptions,
      TNullable,
      TRequired,
      TImmutable,
      TAutoGenerated,
      TConditionalLogic,
      TDatabase,
      T
    >(this, context, data)
  }

  /**
   * Extends this `Field` instance with additional `context` and runtime `data`.
   * The resulting `SanitizedContextField` can be accessed during query builder operations at runtime after sanitization.
   */
  withSanitizedContext<T extends Context<TDatabase>>(context: T, data: SanitizedContextFieldData) {
    return new SanitizedContextField<
      TModel,
      TOptions,
      TNullable,
      TRequired,
      TImmutable,
      TAutoGenerated,
      TConditionalLogic,
      TDatabase,
      T
    >(this, context, data)
  }
}

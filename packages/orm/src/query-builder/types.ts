import type { I18n } from '@pruvious/i18n'
import type { Booleanish } from '@pruvious/utils'
import type {
  Context,
  ExtractAutoGeneratedFieldNames,
  ExtractConditionalFieldNames,
  ExtractImmutableFieldNames,
  ExtractInputTypes,
  ExtractRequiredFieldNames,
  GenericCollection,
  GenericDatabase,
  GenericField,
} from '../core'
import type { ConditionalQueryBuilder } from './ConditionalQueryBuilder'

export type DatabaseOperation = 'insert' | 'select' | 'update' | 'delete'

export type QueryBuilderResult<TData, TInputErrors = Record<string, string>[]> =
  | QueryBuilderOutput<TData>
  | QueryBuilderError<TInputErrors>

export interface QueryBuilderOutput<TData> extends BaseQueryBuilderResult<TData, undefined> {
  success: true
  data: TData
  runtimeError: undefined
  inputErrors: undefined
}

export type QueryBuilderError<TInputErrors> = (TInputErrors extends undefined
  ? QueryBuilderRuntimeError
  : QueryBuilderRuntimeError | QueryBuilderInputErrors<TInputErrors>) &
  BaseQueryBuilderResult<undefined, TInputErrors>

export interface QueryBuilderRuntimeError extends BaseQueryBuilderResult<undefined, undefined> {
  success: false
  data: undefined
  runtimeError: string
  inputErrors: undefined
}

export interface QueryBuilderInputErrors<TInputErrors> extends BaseQueryBuilderResult<undefined, TInputErrors> {
  success: false
  data: undefined
  runtimeError: undefined
  inputErrors: TInputErrors
}

interface BaseQueryBuilderResult<TData, TInputErrors> {
  /**
   * Indicates whether the query was successful.
   */
  success: boolean

  /**
   * The final result produced by executing the query.
   *
   * This will be `undefined` if the query failed.
   */
  data: TData | undefined

  /**
   * An error message describing why the query failed or was not executed.
   *
   * Either `runtimeError` or `inputErrors` will be present, not both.
   */
  runtimeError: string | undefined

  /**
   * Field-specific errors for INSERT and UPDATE queries, structured as key-value pairs.
   * Keys use dot notation for field paths, and values are error messages.
   *
   * - For INSERT operations, an array of objects is returned.
   *   - The array index corresponds to the input array order.
   *   - Successful items have `undefined` error messages in mixed success/failure cases.
   * - For UPDATE operations, a single object is returned.
   *
   * Either `runtimeError` or `inputErrors` will be present, not both.
   *
   * @example
   * ```ts
   * // INSERT
   * const insertError: QueryBuilderError<Record<string, string>[]> = {
   *   success: false,
   *   data: undefined,
   *   runtimeError: undefined,
   *   inputErrors: [{
   *     'firstName': 'This field is required',
   *     'notes.0.text': 'This field is required',
   *   }],
   * }
   *
   * const multipleInputs: QueryBuilderError<Record<string, string>[]> = {
   *   success: false,
   *   data: undefined,
   *   runtimeError: undefined,
   *   inputErrors: [
   *     undefined, // 0 - Success
   *     undefined, // 1 - Success
   *     { ... },   // 2 - Failure
   *     undefined, // 3 - Success
   *     { ... },   // 4 - Failure
   *   ],
   * }
   *
   * // UPDATE
   * const updateError: QueryBuilderError<Record<string, string>> = {
   *   success: false,
   *   data: undefined,
   *   runtimeError: undefined,
   *   inputErrors: {
   *     'firstName': 'This field is required',
   *     'notes.0.text': 'This field is required',
   *   },
   * }
   * ```
   */
  inputErrors: TInputErrors | undefined
}

export interface Paginated<TData> {
  /**
   * Array of retrieved records for the current page.
   */
  records: TData[]

  /**
   * The current page number.
   */
  currentPage: number

  /**
   * The number of the last available page.
   */
  lastPage: number

  /**
   * Number of records displayed per page.
   */
  perPage: number

  /**
   * Total count of all records matching the query.
   */
  total: number
}

interface BaseValidationResult<TInputErrors> extends Pick<BaseQueryBuilderResult<any, TInputErrors>, 'inputErrors'> {
  /**
   * Indicates whether the validation was successful.
   */
  success: boolean

  /**
   * An error message describing why the query would fail if executed.
   *
   * Either `runtimeError` or `inputErrors` will be present, not both.
   */
  runtimeError: string | undefined
}

interface ValidationSuccess<TInputErrors> extends BaseValidationResult<TInputErrors> {
  success: true
  runtimeError: undefined
  inputErrors: undefined
}

interface ValidationRuntimeError<TInputErrors> extends BaseValidationResult<TInputErrors> {
  success: false
  runtimeError: string
  inputErrors: undefined
}

interface ValidationInputErrors<TInputErrors> extends BaseValidationResult<TInputErrors> {
  success: false
  runtimeError: undefined
  inputErrors: TInputErrors
}

export type ValidationResult<TInputErrors> =
  | ValidationSuccess<TInputErrors>
  | ValidationRuntimeError<TInputErrors>
  | ValidationInputErrors<TInputErrors>

export type QueryBuilderPrepareCallback = (context: Context<GenericDatabase>) => any

export type Operator =
  | '='
  | '!='
  | '<'
  | '<='
  | '>'
  | '>='
  | 'includes'
  | 'includesAny'
  | 'excludes'
  | 'excludesAny'
  | 'in'
  | 'notIn'
  | 'like'
  | 'notLike'
  | 'ilike'
  | 'notIlike'
  | 'between'
  | 'notBetween'

export type WhereOperator<TField extends GenericField> = TField['model']['dataType'] extends 'text'
  ? Exclude<Operator, '<' | '<=' | '>' | '>=' | 'between' | 'notBetween'>
  : TField['model']['dataType'] extends 'boolean'
    ? Extract<Operator, '=' | '!='>
    : Exclude<
        Operator,
        'includes' | 'includesAny' | 'excludes' | 'excludesAny' | 'like' | 'notLike' | 'ilike' | 'notIlike'
      >

export type WhereValue<
  TField extends GenericField,
  TOperator extends Operator,
  TValue =
    | (TField['model']['dataType'] extends 'bigint' | 'numeric' | 'text'
        ? number | string
        : TField['model']['dataType'] extends 'boolean'
          ? Booleanish
          : any)
    | (TField['nullable'] extends false ? never : null),
> = TOperator extends 'in' | 'notIn'
  ? NonNullable<TValue>[]
  : TOperator extends 'between' | 'notBetween'
    ? [NonNullable<TValue>, NonNullable<TValue>]
    : TOperator extends '<' | '<=' | '>' | '>=' | 'like' | 'notLike' | 'ilike' | 'notIlike'
      ? NonNullable<TValue>
      : TOperator extends 'includes' | 'includesAny' | 'excludes' | 'excludesAny'
        ? number | string | (number | string)[]
        : TValue

export type GenericWhereValue = string | (string | number | null)[] | number | [number, number] | null

export type DerivedExpressionBuilder<
  TCollections extends Record<string, GenericCollection>,
  TCollectionName extends string,
  TCollection extends GenericCollection,
  TI18n extends I18n,
> = Pick<ConditionalQueryBuilder<TCollections, TCollectionName, TCollection, TI18n>, 'where' | 'whereRaw' | 'orGroup'>

export interface WhereField<TColumnNames extends string = string> {
  /**
   * The field (column) name to filter by.
   */
  field: TColumnNames

  /**
   * The operator to use in the WHERE clause.
   */
  operator: Operator

  /**
   * The value to filter by.
   */
  value: GenericWhereValue
}

export interface WhereRaw {
  /**
   * A raw SQL string to include in the WHERE clause.
   */
  raw: string

  /**
   * Optional parameters to pass to the raw SQL string.
   */
  params?: Record<string, any>
}

export interface WhereOrGroup<TColumnNames extends string = string> {
  /**
   * An array of WHERE conditions to group together with an OR clause.
   */
  or: WhereCondition<TColumnNames>[][]
}

export interface ExplicitWhereOrGroup<TColumnNames extends string = string> {
  /**
   * An array of WHERE conditions to group together with an OR clause.
   */
  or: (WhereField<TColumnNames> | ExplicitWhereOrGroup<TColumnNames>)[][]
}

export type WhereCondition<TColumnNames extends string = string> =
  | WhereField<TColumnNames>
  | WhereRaw
  | WhereOrGroup<TColumnNames>

export type OmitReservedSQLParams<T> = {
  [K in keyof T as K extends `p${number}` ? never : K]: T[K]
}

export type InsertInput<TCollection extends Pick<GenericCollection, 'TInputTypes' | 'fields'>> = Omit<
  Pick<
    TCollection['TInputTypes'],
    Exclude<ExtractRequiredFieldNames<TCollection['fields']>, ExtractConditionalFieldNames<TCollection['fields']>>
  > &
    Partial<
      Omit<
        TCollection['TInputTypes'],
        Exclude<ExtractRequiredFieldNames<TCollection['fields']>, ExtractConditionalFieldNames<TCollection['fields']>>
      >
    >,
  ExtractAutoGeneratedFieldNames<TCollection['fields']>
>

export type UpdateInput<TCollection extends Pick<GenericCollection, 'fields'>> = Partial<
  Omit<
    ExtractInputTypes<TCollection['fields']>,
    ExtractAutoGeneratedFieldNames<TCollection['fields']> | ExtractImmutableFieldNames<TCollection['fields']>
  >
>

export type SubfieldsInput<
  TSubfields extends Record<string, GenericField>,
  TInputTypes extends ExtractInputTypes<TSubfields> = ExtractInputTypes<TSubfields>,
> = Omit<
  Pick<TInputTypes, Exclude<ExtractRequiredFieldNames<TSubfields>, ExtractConditionalFieldNames<TSubfields>>> &
    Partial<
      Omit<TInputTypes, Exclude<ExtractRequiredFieldNames<TSubfields>, ExtractConditionalFieldNames<TSubfields>>>
    >,
  ExtractAutoGeneratedFieldNames<TSubfields>
>

// Query params

export type FieldAccessControl<TColumnNames extends string = string> = {
  /**
   * An array of field (column) names to allow in the query parameter.
   * When defined, only these fields will be processed, and all others will be ignored.
   */
  allow?: TColumnNames[]

  /**
   * Specifies an array of field (column) names to exclude from the query parameter.
   * When defined, all fields will be processed except for those listed here.
   */
  deny?: TColumnNames[]
} & ({ allow: TColumnNames[]; deny?: undefined } | { allow?: undefined; deny: TColumnNames[] })

export type QueryBuilderParams<TColumnNames extends string = string> =
  | InsertQueryBuilderParams<TColumnNames>
  | SelectQueryBuilderParams<TColumnNames>
  | UpdateQueryBuilderParams<TColumnNames>
  | DeleteQueryBuilderParams<TColumnNames>

export interface ConditionalQueryBuilderParams<TColumnNames extends string = string> {
  /**
   * Filtering conditions for the query.
   *
   * @example
   * ```ts
   * {
   *   where: [
   *     { field: 'firstName', operator: '=', value: 'Harry' },
   *     { field: 'lastName', operator: 'like', value: 'P%' },
   *   ],
   * }
   * ```
   */
  where?: (WhereField<TColumnNames> | ExplicitWhereOrGroup<TColumnNames>)[]
}

export interface DefaultQueryBuilderParamsOptions {
  /**
   * Controls whether default values should be applied to unspecified parameters.
   *
   * @default false
   */
  withDefaults?: boolean
}

export interface ConditionalQueryBuilderParamsOptions<TColumnNames extends string = string> {
  /**
   * Controls how to handle the `where` parameter.
   *
   * - Set to `true` to handle all fields.
   * - Set to `false` to ignore the `where` parameter completely.
   * - Provide an object to define a custom allowlist or denylist of fields.
   *
   * @default true
   */
  where?:
    | boolean
    | {
        /**
         * Specifies an allowlist of fields and their permitted operators.
         * Only these fields and operators will be processed in the `where` parameter.
         *
         * @example
         * ```ts
         * {
         *   allow: [
         *     { field: 'firstName' },
         *     { field: 'lastName', operators: ['=', 'like'] },
         *   ],
         * }
         * // Only 'firstName' and 'lastName' fields will be allowed in the `where` clause,
         * // and 'lastName' will be limited to the '=' and 'like' operators.
         * ```
         */
        allow: {
          /**
           * The name of the field column to allow in the `where` clause.
           */
          field: TColumnNames

          /**
           * An array of permitted operators for this `field`.
           * If set, only these operators will be allowed.
           *
           * By default, all operators are allowed.
           *
           * @default undefined
           */
          operators?: Operator[]
        }[]
      }
    | {
        /**
         * Specifies a denylist of fields and their permitted operators.
         * These fields and operators will be excluded or limited in the `where` parameter.
         *
         * @example
         * ```ts
         * {
         *   deny: [
         *     { field: 'firstName' },
         *     { field: 'lastName', operators: ['=', 'like'] },
         *   ],
         * }
         * // 'firstName' will be excluded from the `where` clause,
         * // and 'lastName' will be allowed, but the '=' and 'like' operators will be blocked.
         * ```
         */
        deny: {
          /**
           * The name of the field column to exclude or limit in the `where` clause.
           */
          field: TColumnNames

          /**
           * An array of forbidden operators for this `field`.
           * If set, the `field` will be allowed, but these operators will be blocked.
           *
           * @default undefined
           */
          operators?: Operator[]
        }[]
      }
}

export interface InsertQueryBuilderParams<TColumnNames extends string = string> {
  /**
   * Fields to return after the INSERT operation.
   */
  returning?: TColumnNames[]

  /**
   * Determines if the query should run field populators and return populated field values.
   * This option only takes effect when the `returning` parameter is set.
   */
  populate?: boolean
}

export interface InsertQueryBuilderParamsOptions<TColumnNames extends string = string> {
  /**
   * Controls how to handle the `returning` parameter.
   *
   * - Set to `true` to handle all fields.
   * - Set to `false` to ignore the `returning` parameter completely.
   * - Provide an object to define a custom allowlist or denylist of fields.
   *
   * @default true
   */
  returning?: boolean | FieldAccessControl<TColumnNames>

  /**
   * Controls whether the `populate` parameter can be used in the query.
   *
   * @default true
   */
  populate?: boolean
}

export interface SelectQueryBuilderParams<TColumnNames extends string = string>
  extends ConditionalQueryBuilderParams<TColumnNames> {
  /**
   * Fields to retrieve.
   */
  select?: TColumnNames[]

  /**
   * Search criteria.
   */
  search?: {
    /**
     * The fields to search in.
     */
    fields: TColumnNames[]

    /**
     * The keywords to search for.
     */
    keywords: string[]
  }[]

  /**
   * Fields to group by.
   */
  groupBy?: TColumnNames[]

  /**
   * Fields to order by.
   */
  orderBy?: {
    /**
     * The field (column) name to order by.
     */
    field: TColumnNames

    /**
     * The direction to order by.
     *
     * @default 'asc'
     */
    direction?: 'asc' | 'desc'

    /**
     * The order of null values.
     *
     * - `nullsAuto` - Null values are ordered based on the specified direction (`nullsFirst` for `asc`, `nullsLast` for `desc`).
     * - `nullsFirst` - Null values are ordered first.
     * - `nullsLast` - Null values are ordered last.
     *
     * @default 'nullsAuto'
     */
    nulls?: 'nullsAuto' | 'nullsFirst' | 'nullsLast'
  }[]

  /**
   * Controls search result ordering based on relevance.
   */
  orderByRelevance?: 'high' | 'low' | false

  /**
   * The maximum number of rows to return.
   */
  limit?: number

  /**
   * The number of rows to skip before returning results.
   */
  offset?: number

  /**
   * The page number for paginated results.
   * If specified, the `perPage` parameter must also be set.
   *
   * If the `limit` or `offset` parameters are also set in the same query, the `page` and `perPage` parameters will be ignored.
   */
  page?: number

  /**
   * The number of items to display per page.
   *
   * If the `limit` or `offset` parameters are also set in the same query, the `page` and `perPage` parameters will be ignored.
   */
  perPage?: number

  /**
   * Determines if the query should run field populators and return populated field values.
   */
  populate?: boolean
}

export interface SelectQueryBuilderParamsOptions<TColumnNames extends string = string>
  extends ConditionalQueryBuilderParamsOptions<TColumnNames> {
  /**
   * Controls how to handle the `select` parameter.
   *
   * - Set to `true` to handle all fields.
   * - Set to `false` to ignore the `select` parameter completely.
   * - Provide an object to define a custom allowlist or denylist of fields.
   *
   * @default true
   */
  select?: boolean | FieldAccessControl<TColumnNames>

  /**
   * Controls how to handle the `search` parameter.
   *
   * - Set to `true` to handle all fields.
   * - Set to `false` to ignore the `search` parameter completely.
   * - Provide an object to define a custom allowlist or denylist of fields.
   *
   * @default true
   */
  search?: boolean | FieldAccessControl<TColumnNames>

  /**
   * Controls how to handle the `groupBy` parameter.
   *
   * - Set to `true` to handle all fields.
   * - Set to `false` to ignore the `groupBy` parameter completely.
   * - Provide an object to define a custom allowlist or denylist of fields.
   *
   * @default true
   */
  groupBy?: boolean | FieldAccessControl<TColumnNames>

  /**
   * Controls how to handle the `orderBy` parameter.
   *
   * - Set to `true` to handle all fields.
   * - Set to `false` to ignore the `orderBy` parameter completely.
   * - Provide an object to define a custom allowlist or denylist of fields.
   *
   * @default true
   */
  orderBy?: boolean | FieldAccessControl<TColumnNames>

  /**
   * Controls how to handle the `orderByRelevance` parameter.
   *
   * - Set to `true` to handle all fields.
   * - Set to `false` to ignore the `orderByRelevance` parameter completely.
   *
   * @default true
   */
  orderByRelevance?: boolean

  /**
   * Controls how to handle the `limit` parameter.
   *
   * - Set to `true` to allow any `limit`.
   * - Set to `false` to ignore the `limit` parameter completely.
   * - Provide a number to set a maximum allowed limit and always include it in the query.
   *
   * When `limit` and `offset` are both active, the `page` and `perPage` parameters become accessible for pagination.
   * The `perPage` parameter will inherit the settings of the `limit` parameter.
   * The `limit` parameter will always take precedence over `perPage`.
   *
   * @default true
   */
  limit?: boolean | number

  /**
   * Controls how to handle the `offset` parameter.
   *
   * - Set to `true` to allow the `offset` parameter.
   * - Set to `false` to ignore the `offset` parameter completely.
   *
   * When `limit` and `offset` are both active, the `page` and `perPage` parameters become accessible for pagination.
   * The `offset` parameter will always take precedence over `page`.
   *
   * @default true
   */
  offset?: boolean

  /**
   * Controls whether the `populate` parameter can be used in the query.
   *
   * @default true
   */
  populate?: boolean
}

export interface UpdateQueryBuilderParams<TColumnNames extends string = string>
  extends ConditionalQueryBuilderParams<TColumnNames> {
  /**
   * Fields to return after the UPDATE operation.
   */
  returning?: TColumnNames[]

  /**
   * Determines if the query should run field populators and return populated field values.
   * This option only takes effect when the `returning` parameter is set.
   */
  populate?: boolean
}

export interface UpdateQueryBuilderParamsOptions<TColumnNames extends string = string>
  extends ConditionalQueryBuilderParamsOptions<TColumnNames> {
  /**
   * Controls how to handle the `returning` parameter.
   *
   * - Set to `true` to handle all fields.
   * - Set to `false` to ignore the `returning` parameter completely.
   * - Provide an object to define a custom allowlist or denylist of fields.
   *
   * @default true
   */
  returning?: boolean | FieldAccessControl<TColumnNames>

  /**
   * Controls whether the `populate` parameter can be used in the query.
   *
   * @default true
   */
  populate?: boolean
}

export interface DeleteQueryBuilderParams<TColumnNames extends string = string>
  extends ConditionalQueryBuilderParams<TColumnNames> {
  /**
   * Fields to return after the DELETE operation.
   */
  returning?: TColumnNames[]

  /**
   * Determines if the query should run field populators and return populated field values.
   * This option only takes effect when the `returning` parameter is set.
   */
  populate?: boolean
}

export interface DeleteQueryBuilderParamsOptions<TColumnNames extends string = string>
  extends ConditionalQueryBuilderParamsOptions<TColumnNames> {
  /**
   * Controls how to handle the `returning` parameter.
   *
   * - Set to `true` to handle all fields.
   * - Set to `false` to ignore the `returning` parameter completely.
   * - Provide an object to define a custom allowlist or denylist of fields.
   *
   * @default true
   */
  returning?: boolean | FieldAccessControl<TColumnNames>

  /**
   * Controls whether the `populate` parameter can be used in the query.
   *
   * @default true
   */
  populate?: boolean
}
